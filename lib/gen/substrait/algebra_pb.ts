// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file substrait/algebra.proto (package substrait, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Any } from "../google/protobuf/any_pb";
import { file_google_protobuf_any } from "../google/protobuf/any_pb";
import type { AdvancedExtension } from "./extensions/extensions_pb";
import { file_substrait_extensions_extensions } from "./extensions/extensions_pb";
import type { NamedStruct, Type, Type_List, Type_Map, Type_Parameter } from "./type_pb";
import { file_substrait_type } from "./type_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file substrait/algebra.proto.
 */
export const file_substrait_algebra: GenFile = /*@__PURE__*/
  fileDesc("ChdzdWJzdHJhaXQvYWxnZWJyYS5wcm90bxIJc3Vic3RyYWl0IqgFCglSZWxDb21tb24SLQoGZGlyZWN0GAEgASgLMhsuc3Vic3RyYWl0LlJlbENvbW1vbi5EaXJlY3RIABIpCgRlbWl0GAIgASgLMhkuc3Vic3RyYWl0LlJlbENvbW1vbi5FbWl0SAASJwoEaGludBgDIAEoCzIZLnN1YnN0cmFpdC5SZWxDb21tb24uSGludBJDChJhZHZhbmNlZF9leHRlbnNpb24YBCABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhoICgZEaXJlY3QaHgoERW1pdBIWCg5vdXRwdXRfbWFwcGluZxgBIAMoBRqbAwoESGludBIuCgVzdGF0cxgBIAEoCzIfLnN1YnN0cmFpdC5SZWxDb21tb24uSGludC5TdGF0cxI/Cgpjb25zdHJhaW50GAIgASgLMisuc3Vic3RyYWl0LlJlbENvbW1vbi5IaW50LlJ1bnRpbWVDb25zdHJhaW50Eg0KBWFsaWFzGAMgASgJEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgKIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uGnQKBVN0YXRzEhEKCXJvd19jb3VudBgBIAEoARITCgtyZWNvcmRfc2l6ZRgCIAEoARJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhpYChFSdW50aW1lQ29uc3RyYWludBJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbkILCgllbWl0X2tpbmQiiQwKB1JlYWRSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIrCgtiYXNlX3NjaGVtYRgCIAEoCzIWLnN1YnN0cmFpdC5OYW1lZFN0cnVjdBIlCgZmaWx0ZXIYAyABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhIxChJiZXN0X2VmZm9ydF9maWx0ZXIYCyABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhI4Cgpwcm9qZWN0aW9uGAQgASgLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb24SQwoSYWR2YW5jZWRfZXh0ZW5zaW9uGAogASgLMicuc3Vic3RyYWl0LmV4dGVuc2lvbnMuQWR2YW5jZWRFeHRlbnNpb24SOAoNdmlydHVhbF90YWJsZRgFIAEoCzIfLnN1YnN0cmFpdC5SZWFkUmVsLlZpcnR1YWxUYWJsZUgAEjQKC2xvY2FsX2ZpbGVzGAYgASgLMh0uc3Vic3RyYWl0LlJlYWRSZWwuTG9jYWxGaWxlc0gAEjQKC25hbWVkX3RhYmxlGAcgASgLMh0uc3Vic3RyYWl0LlJlYWRSZWwuTmFtZWRUYWJsZUgAEjwKD2V4dGVuc2lvbl90YWJsZRgIIAEoCzIhLnN1YnN0cmFpdC5SZWFkUmVsLkV4dGVuc2lvblRhYmxlSAAaYAoKTmFtZWRUYWJsZRINCgVuYW1lcxgBIAMoCRJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhpECgxWaXJ0dWFsVGFibGUSNAoGdmFsdWVzGAEgAygLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5TdHJ1Y3QaNgoORXh0ZW5zaW9uVGFibGUSJAoGZGV0YWlsGAEgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueRqABgoKTG9jYWxGaWxlcxI4CgVpdGVtcxgBIAMoCzIpLnN1YnN0cmFpdC5SZWFkUmVsLkxvY2FsRmlsZXMuRmlsZU9yRmlsZXMSQwoSYWR2YW5jZWRfZXh0ZW5zaW9uGAogASgLMicuc3Vic3RyYWl0LmV4dGVuc2lvbnMuQWR2YW5jZWRFeHRlbnNpb24a8gQKC0ZpbGVPckZpbGVzEhIKCHVyaV9wYXRoGAEgASgJSAASFwoNdXJpX3BhdGhfZ2xvYhgCIAEoCUgAEhIKCHVyaV9maWxlGAMgASgJSAASFAoKdXJpX2ZvbGRlchgEIAEoCUgAEhcKD3BhcnRpdGlvbl9pbmRleBgGIAEoBBINCgVzdGFydBgHIAEoBBIOCgZsZW5ndGgYCCABKAQSTwoHcGFycXVldBgJIAEoCzI8LnN1YnN0cmFpdC5SZWFkUmVsLkxvY2FsRmlsZXMuRmlsZU9yRmlsZXMuUGFycXVldFJlYWRPcHRpb25zSAESSwoFYXJyb3cYCiABKAsyOi5zdWJzdHJhaXQuUmVhZFJlbC5Mb2NhbEZpbGVzLkZpbGVPckZpbGVzLkFycm93UmVhZE9wdGlvbnNIARJHCgNvcmMYCyABKAsyOC5zdWJzdHJhaXQuUmVhZFJlbC5Mb2NhbEZpbGVzLkZpbGVPckZpbGVzLk9yY1JlYWRPcHRpb25zSAESKQoJZXh0ZW5zaW9uGAwgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueUgBEkkKBGR3cmYYDSABKAsyOS5zdWJzdHJhaXQuUmVhZFJlbC5Mb2NhbEZpbGVzLkZpbGVPckZpbGVzLkR3cmZSZWFkT3B0aW9uc0gBGhQKElBhcnF1ZXRSZWFkT3B0aW9ucxoSChBBcnJvd1JlYWRPcHRpb25zGhAKDk9yY1JlYWRPcHRpb25zGhEKD0R3cmZSZWFkT3B0aW9uc0ILCglwYXRoX3R5cGVCDQoLZmlsZV9mb3JtYXRKBAgFEAZSBmZvcm1hdEILCglyZWFkX3R5cGUiwgEKClByb2plY3RSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSKgoLZXhwcmVzc2lvbnMYAyADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbiLxAwoHSm9pblJlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEhwKBGxlZnQYAiABKAsyDi5zdWJzdHJhaXQuUmVsEh0KBXJpZ2h0GAMgASgLMg4uc3Vic3RyYWl0LlJlbBIpCgpleHByZXNzaW9uGAQgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SLwoQcG9zdF9qb2luX2ZpbHRlchgFIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEikKBHR5cGUYBiABKA4yGy5zdWJzdHJhaXQuSm9pblJlbC5Kb2luVHlwZRJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbiK2AQoISm9pblR5cGUSGQoVSk9JTl9UWVBFX1VOU1BFQ0lGSUVEEAASEwoPSk9JTl9UWVBFX0lOTkVSEAESEwoPSk9JTl9UWVBFX09VVEVSEAISEgoOSk9JTl9UWVBFX0xFRlQQAxITCg9KT0lOX1RZUEVfUklHSFQQBBISCg5KT0lOX1RZUEVfU0VNSRAFEhIKDkpPSU5fVFlQRV9BTlRJEAYSFAoQSk9JTl9UWVBFX1NJTkdMRRAHIrIBCghDcm9zc1JlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEhwKBGxlZnQYAiABKAsyDi5zdWJzdHJhaXQuUmVsEh0KBXJpZ2h0GAMgASgLMg4uc3Vic3RyYWl0LlJlbBJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbiKzAQoIRmV0Y2hSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSDgoGb2Zmc2V0GAMgASgDEg0KBWNvdW50GAQgASgDEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgKIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uIqIDCgxBZ2dyZWdhdGVSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSMwoJZ3JvdXBpbmdzGAMgAygLMiAuc3Vic3RyYWl0LkFnZ3JlZ2F0ZVJlbC5Hcm91cGluZxIxCghtZWFzdXJlcxgEIAMoCzIfLnN1YnN0cmFpdC5BZ2dyZWdhdGVSZWwuTWVhc3VyZRJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbho/CghHcm91cGluZxIzChRncm91cGluZ19leHByZXNzaW9ucxgBIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uGl8KB01lYXN1cmUSLQoHbWVhc3VyZRgBIAEoCzIcLnN1YnN0cmFpdC5BZ2dyZWdhdGVGdW5jdGlvbhIlCgZmaWx0ZXIYAiABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbiLIBgocQ29uc2lzdGVudFBhcnRpdGlvbldpbmRvd1JlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEh0KBWlucHV0GAIgASgLMg4uc3Vic3RyYWl0LlJlbBJTChB3aW5kb3dfZnVuY3Rpb25zGAMgAygLMjkuc3Vic3RyYWl0LkNvbnNpc3RlbnRQYXJ0aXRpb25XaW5kb3dSZWwuV2luZG93UmVsRnVuY3Rpb24SNAoVcGFydGl0aW9uX2V4cHJlc3Npb25zGAQgAygLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SIwoFc29ydHMYBSADKAsyFC5zdWJzdHJhaXQuU29ydEZpZWxkEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgKIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uGu0DChFXaW5kb3dSZWxGdW5jdGlvbhIaChJmdW5jdGlvbl9yZWZlcmVuY2UYASABKA0SLgoJYXJndW1lbnRzGAkgAygLMhsuc3Vic3RyYWl0LkZ1bmN0aW9uQXJndW1lbnQSKgoHb3B0aW9ucxgLIAMoCzIZLnN1YnN0cmFpdC5GdW5jdGlvbk9wdGlvbhIkCgtvdXRwdXRfdHlwZRgHIAEoCzIPLnN1YnN0cmFpdC5UeXBlEioKBXBoYXNlGAYgASgOMhsuc3Vic3RyYWl0LkFnZ3JlZ2F0aW9uUGhhc2USRgoKaW52b2NhdGlvbhgKIAEoDjIyLnN1YnN0cmFpdC5BZ2dyZWdhdGVGdW5jdGlvbi5BZ2dyZWdhdGlvbkludm9jYXRpb24SPwoLbG93ZXJfYm91bmQYBSABKAsyKi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5XaW5kb3dGdW5jdGlvbi5Cb3VuZBI/Cgt1cHBlcl9ib3VuZBgEIAEoCzIqLnN1YnN0cmFpdC5FeHByZXNzaW9uLldpbmRvd0Z1bmN0aW9uLkJvdW5kEkQKC2JvdW5kc190eXBlGAwgASgOMi8uc3Vic3RyYWl0LkV4cHJlc3Npb24uV2luZG93RnVuY3Rpb24uQm91bmRzVHlwZSK4AQoHU29ydFJlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEh0KBWlucHV0GAIgASgLMg4uc3Vic3RyYWl0LlJlbBIjCgVzb3J0cxgDIAMoCzIULnN1YnN0cmFpdC5Tb3J0RmllbGQSQwoSYWR2YW5jZWRfZXh0ZW5zaW9uGAogASgLMicuc3Vic3RyYWl0LmV4dGVuc2lvbnMuQWR2YW5jZWRFeHRlbnNpb24ivwEKCUZpbHRlclJlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEh0KBWlucHV0GAIgASgLMg4uc3Vic3RyYWl0LlJlbBIoCgljb25kaXRpb24YAyABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbiKDAwoGU2V0UmVsEiQKBmNvbW1vbhgBIAEoCzIULnN1YnN0cmFpdC5SZWxDb21tb24SHgoGaW5wdXRzGAIgAygLMg4uc3Vic3RyYWl0LlJlbBIjCgJvcBgDIAEoDjIXLnN1YnN0cmFpdC5TZXRSZWwuU2V0T3ASQwoSYWR2YW5jZWRfZXh0ZW5zaW9uGAogASgLMicuc3Vic3RyYWl0LmV4dGVuc2lvbnMuQWR2YW5jZWRFeHRlbnNpb24iyAEKBVNldE9wEhYKElNFVF9PUF9VTlNQRUNJRklFRBAAEhgKFFNFVF9PUF9NSU5VU19QUklNQVJZEAESGQoVU0VUX09QX01JTlVTX01VTFRJU0VUEAISHwobU0VUX09QX0lOVEVSU0VDVElPTl9QUklNQVJZEAMSIAocU0VUX09QX0lOVEVSU0VDVElPTl9NVUxUSVNFVBAEEhkKFVNFVF9PUF9VTklPTl9ESVNUSU5DVBAFEhQKEFNFVF9PUF9VTklPTl9BTEwQBiJ/ChJFeHRlbnNpb25TaW5nbGVSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSJAoGZGV0YWlsGAMgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueSJeChBFeHRlbnNpb25MZWFmUmVsEiQKBmNvbW1vbhgBIAEoCzIULnN1YnN0cmFpdC5SZWxDb21tb24SJAoGZGV0YWlsGAIgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueSJ/ChFFeHRlbnNpb25NdWx0aVJlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEh4KBmlucHV0cxgCIAMoCzIOLnN1YnN0cmFpdC5SZWwSJAoGZGV0YWlsGAMgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueSLDBwoLRXhjaGFuZ2VSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSFwoPcGFydGl0aW9uX2NvdW50GAMgASgFEjYKB3RhcmdldHMYBCADKAsyJS5zdWJzdHJhaXQuRXhjaGFuZ2VSZWwuRXhjaGFuZ2VUYXJnZXQSQQoRc2NhdHRlcl9ieV9maWVsZHMYBSABKAsyJC5zdWJzdHJhaXQuRXhjaGFuZ2VSZWwuU2NhdHRlckZpZWxkc0gAEkYKDXNpbmdsZV90YXJnZXQYBiABKAsyLS5zdWJzdHJhaXQuRXhjaGFuZ2VSZWwuU2luZ2xlQnVja2V0RXhwcmVzc2lvbkgAEkQKDG11bHRpX3RhcmdldBgHIAEoCzIsLnN1YnN0cmFpdC5FeGNoYW5nZVJlbC5NdWx0aUJ1Y2tldEV4cHJlc3Npb25IABI4Cgtyb3VuZF9yb2JpbhgIIAEoCzIhLnN1YnN0cmFpdC5FeGNoYW5nZVJlbC5Sb3VuZFJvYmluSAASNQoJYnJvYWRjYXN0GAkgASgLMiAuc3Vic3RyYWl0LkV4Y2hhbmdlUmVsLkJyb2FkY2FzdEgAEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgKIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uGkUKDVNjYXR0ZXJGaWVsZHMSNAoGZmllbGRzGAEgAygLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uRmllbGRSZWZlcmVuY2UaQwoWU2luZ2xlQnVja2V0RXhwcmVzc2lvbhIpCgpleHByZXNzaW9uGAEgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24aYAoVTXVsdGlCdWNrZXRFeHByZXNzaW9uEikKCmV4cHJlc3Npb24YASABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhIcChRjb25zdHJhaW5lZF90b19jb3VudBgCIAEoCBoLCglCcm9hZGNhc3QaGwoKUm91bmRSb2JpbhINCgVleGFjdBgBIAEoCBpuCg5FeGNoYW5nZVRhcmdldBIUCgxwYXJ0aXRpb25faWQYASADKAUSDQoDdXJpGAIgASgJSAASKAoIZXh0ZW5kZWQYAyABKAsyFC5nb29nbGUucHJvdG9idWYuQW55SABCDQoLdGFyZ2V0X3R5cGVCDwoNZXhjaGFuZ2Vfa2luZCLQAgoJRXhwYW5kUmVsEiQKBmNvbW1vbhgBIAEoCzIULnN1YnN0cmFpdC5SZWxDb21tb24SHQoFaW5wdXQYAiABKAsyDi5zdWJzdHJhaXQuUmVsEjAKBmZpZWxkcxgEIAMoCzIgLnN1YnN0cmFpdC5FeHBhbmRSZWwuRXhwYW5kRmllbGQajgEKC0V4cGFuZEZpZWxkEj4KD3N3aXRjaGluZ19maWVsZBgCIAEoCzIjLnN1YnN0cmFpdC5FeHBhbmRSZWwuU3dpdGNoaW5nRmllbGRIABIxChBjb25zaXN0ZW50X2ZpZWxkGAMgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb25IAEIMCgpmaWVsZF90eXBlGjsKDlN3aXRjaGluZ0ZpZWxkEikKCmR1cGxpY2F0ZXMYASADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbiI3CgdSZWxSb290Eh0KBWlucHV0GAEgASgLMg4uc3Vic3RyYWl0LlJlbBINCgVuYW1lcxgCIAMoCSKxBwoDUmVsEiIKBHJlYWQYASABKAsyEi5zdWJzdHJhaXQuUmVhZFJlbEgAEiYKBmZpbHRlchgCIAEoCzIULnN1YnN0cmFpdC5GaWx0ZXJSZWxIABIkCgVmZXRjaBgDIAEoCzITLnN1YnN0cmFpdC5GZXRjaFJlbEgAEiwKCWFnZ3JlZ2F0ZRgEIAEoCzIXLnN1YnN0cmFpdC5BZ2dyZWdhdGVSZWxIABIiCgRzb3J0GAUgASgLMhIuc3Vic3RyYWl0LlNvcnRSZWxIABIiCgRqb2luGAYgASgLMhIuc3Vic3RyYWl0LkpvaW5SZWxIABIoCgdwcm9qZWN0GAcgASgLMhUuc3Vic3RyYWl0LlByb2plY3RSZWxIABIgCgNzZXQYCCABKAsyES5zdWJzdHJhaXQuU2V0UmVsSAASOQoQZXh0ZW5zaW9uX3NpbmdsZRgJIAEoCzIdLnN1YnN0cmFpdC5FeHRlbnNpb25TaW5nbGVSZWxIABI3Cg9leHRlbnNpb25fbXVsdGkYCiABKAsyHC5zdWJzdHJhaXQuRXh0ZW5zaW9uTXVsdGlSZWxIABI1Cg5leHRlbnNpb25fbGVhZhgLIAEoCzIbLnN1YnN0cmFpdC5FeHRlbnNpb25MZWFmUmVsSAASJAoFY3Jvc3MYDCABKAsyEy5zdWJzdHJhaXQuQ3Jvc3NSZWxIABIsCglyZWZlcmVuY2UYFSABKAsyFy5zdWJzdHJhaXQuUmVmZXJlbmNlUmVsSAASJAoFd3JpdGUYEyABKAsyEy5zdWJzdHJhaXQuV3JpdGVSZWxIABIgCgNkZGwYFCABKAsyES5zdWJzdHJhaXQuRGRsUmVsSAASKwoJaGFzaF9qb2luGA0gASgLMhYuc3Vic3RyYWl0Lkhhc2hKb2luUmVsSAASLQoKbWVyZ2Vfam9pbhgOIAEoCzIXLnN1YnN0cmFpdC5NZXJnZUpvaW5SZWxIABI4ChBuZXN0ZWRfbG9vcF9qb2luGBIgASgLMhwuc3Vic3RyYWl0Lk5lc3RlZExvb3BKb2luUmVsSAASOQoGd2luZG93GBEgASgLMicuc3Vic3RyYWl0LkNvbnNpc3RlbnRQYXJ0aXRpb25XaW5kb3dSZWxIABIqCghleGNoYW5nZRgPIAEoCzIWLnN1YnN0cmFpdC5FeGNoYW5nZVJlbEgAEiYKBmV4cGFuZBgQIAEoCzIULnN1YnN0cmFpdC5FeHBhbmRSZWxIAEIKCghyZWxfdHlwZSJmChBOYW1lZE9iamVjdFdyaXRlEg0KBW5hbWVzGAEgAygJEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgKIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uIjcKD0V4dGVuc2lvbk9iamVjdBIkCgZkZXRhaWwYASABKAsyFC5nb29nbGUucHJvdG9idWYuQW55IvQECgZEZGxSZWwSMwoMbmFtZWRfb2JqZWN0GAEgASgLMhsuc3Vic3RyYWl0Lk5hbWVkT2JqZWN0V3JpdGVIABI2ChBleHRlbnNpb25fb2JqZWN0GAIgASgLMhouc3Vic3RyYWl0LkV4dGVuc2lvbk9iamVjdEgAEiwKDHRhYmxlX3NjaGVtYRgDIAEoCzIWLnN1YnN0cmFpdC5OYW1lZFN0cnVjdBI8Cg50YWJsZV9kZWZhdWx0cxgEIAEoCzIkLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwuU3RydWN0EisKBm9iamVjdBgFIAEoDjIbLnN1YnN0cmFpdC5EZGxSZWwuRGRsT2JqZWN0EiMKAm9wGAYgASgOMhcuc3Vic3RyYWl0LkRkbFJlbC5EZGxPcBInCg92aWV3X2RlZmluaXRpb24YByABKAsyDi5zdWJzdHJhaXQuUmVsEiQKBmNvbW1vbhgIIAEoCzIULnN1YnN0cmFpdC5SZWxDb21tb24iUgoJRGRsT2JqZWN0EhoKFkRETF9PQkpFQ1RfVU5TUEVDSUZJRUQQABIUChBERExfT0JKRUNUX1RBQkxFEAESEwoPRERMX09CSkVDVF9WSUVXEAIijQEKBURkbE9wEhYKEkRETF9PUF9VTlNQRUNJRklFRBAAEhEKDURETF9PUF9DUkVBVEUQARIcChhERExfT1BfQ1JFQVRFX09SX1JFUExBQ0UQAhIQCgxERExfT1BfQUxURVIQAxIPCgtERExfT1BfRFJPUBAEEhgKFERETF9PUF9EUk9QX0lGX0VYSVNUEAVCDAoKd3JpdGVfdHlwZSKuBAoIV3JpdGVSZWwSMgoLbmFtZWRfdGFibGUYASABKAsyGy5zdWJzdHJhaXQuTmFtZWRPYmplY3RXcml0ZUgAEjUKD2V4dGVuc2lvbl90YWJsZRgCIAEoCzIaLnN1YnN0cmFpdC5FeHRlbnNpb25PYmplY3RIABIsCgx0YWJsZV9zY2hlbWEYAyABKAsyFi5zdWJzdHJhaXQuTmFtZWRTdHJ1Y3QSJwoCb3AYBCABKA4yGy5zdWJzdHJhaXQuV3JpdGVSZWwuV3JpdGVPcBIdCgVpbnB1dBgFIAEoCzIOLnN1YnN0cmFpdC5SZWwSLgoGb3V0cHV0GAYgASgOMh4uc3Vic3RyYWl0LldyaXRlUmVsLk91dHB1dE1vZGUSJAoGY29tbW9uGAcgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbiJ1CgdXcml0ZU9wEhgKFFdSSVRFX09QX1VOU1BFQ0lGSUVEEAASEwoPV1JJVEVfT1BfSU5TRVJUEAESEwoPV1JJVEVfT1BfREVMRVRFEAISEwoPV1JJVEVfT1BfVVBEQVRFEAMSEQoNV1JJVEVfT1BfQ1RBUxAEImYKCk91dHB1dE1vZGUSGwoXT1VUUFVUX01PREVfVU5TUEVDSUZJRUQQABIZChVPVVRQVVRfTU9ERV9OT19PVVRQVVQQARIgChxPVVRQVVRfTU9ERV9NT0RJRklFRF9SRUNPUkRTEAJCDAoKd3JpdGVfdHlwZSKBBAoRQ29tcGFyaXNvbkpvaW5LZXkSMgoEbGVmdBgBIAEoCzIkLnN1YnN0cmFpdC5FeHByZXNzaW9uLkZpZWxkUmVmZXJlbmNlEjMKBXJpZ2h0GAIgASgLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uRmllbGRSZWZlcmVuY2USPwoKY29tcGFyaXNvbhgDIAEoCzIrLnN1YnN0cmFpdC5Db21wYXJpc29uSm9pbktleS5Db21wYXJpc29uVHlwZRqIAQoOQ29tcGFyaXNvblR5cGUSQwoGc2ltcGxlGAEgASgOMjEuc3Vic3RyYWl0LkNvbXBhcmlzb25Kb2luS2V5LlNpbXBsZUNvbXBhcmlzb25UeXBlSAASIwoZY3VzdG9tX2Z1bmN0aW9uX3JlZmVyZW5jZRgCIAEoDUgAQgwKCmlubmVyX3R5cGUitgEKFFNpbXBsZUNvbXBhcmlzb25UeXBlEiYKIlNJTVBMRV9DT01QQVJJU09OX1RZUEVfVU5TUEVDSUZJRUQQABIdChlTSU1QTEVfQ09NUEFSSVNPTl9UWVBFX0VREAESLworU0lNUExFX0NPTVBBUklTT05fVFlQRV9JU19OT1RfRElTVElOQ1RfRlJPTRACEiYKIlNJTVBMRV9DT01QQVJJU09OX1RZUEVfTUlHSFRfRVFVQUwQAyKdBQoLSGFzaEpvaW5SZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIcCgRsZWZ0GAIgASgLMg4uc3Vic3RyYWl0LlJlbBIdCgVyaWdodBgDIAEoCzIOLnN1YnN0cmFpdC5SZWwSOwoJbGVmdF9rZXlzGAQgAygLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uRmllbGRSZWZlcmVuY2VCAhgBEjwKCnJpZ2h0X2tleXMYBSADKAsyJC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5GaWVsZFJlZmVyZW5jZUICGAESKgoEa2V5cxgIIAMoCzIcLnN1YnN0cmFpdC5Db21wYXJpc29uSm9pbktleRIvChBwb3N0X2pvaW5fZmlsdGVyGAYgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SLQoEdHlwZRgHIAEoDjIfLnN1YnN0cmFpdC5IYXNoSm9pblJlbC5Kb2luVHlwZRJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbiLeAQoISm9pblR5cGUSGQoVSk9JTl9UWVBFX1VOU1BFQ0lGSUVEEAASEwoPSk9JTl9UWVBFX0lOTkVSEAESEwoPSk9JTl9UWVBFX09VVEVSEAISEgoOSk9JTl9UWVBFX0xFRlQQAxITCg9KT0lOX1RZUEVfUklHSFQQBBIXChNKT0lOX1RZUEVfTEVGVF9TRU1JEAUSGAoUSk9JTl9UWVBFX1JJR0hUX1NFTUkQBhIXChNKT0lOX1RZUEVfTEVGVF9BTlRJEAcSGAoUSk9JTl9UWVBFX1JJR0hUX0FOVEkQCCKfBQoMTWVyZ2VKb2luUmVsEiQKBmNvbW1vbhgBIAEoCzIULnN1YnN0cmFpdC5SZWxDb21tb24SHAoEbGVmdBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSHQoFcmlnaHQYAyABKAsyDi5zdWJzdHJhaXQuUmVsEjsKCWxlZnRfa2V5cxgEIAMoCzIkLnN1YnN0cmFpdC5FeHByZXNzaW9uLkZpZWxkUmVmZXJlbmNlQgIYARI8CgpyaWdodF9rZXlzGAUgAygLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uRmllbGRSZWZlcmVuY2VCAhgBEioKBGtleXMYCCADKAsyHC5zdWJzdHJhaXQuQ29tcGFyaXNvbkpvaW5LZXkSLwoQcG9zdF9qb2luX2ZpbHRlchgGIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEi4KBHR5cGUYByABKA4yIC5zdWJzdHJhaXQuTWVyZ2VKb2luUmVsLkpvaW5UeXBlEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgKIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uIt4BCghKb2luVHlwZRIZChVKT0lOX1RZUEVfVU5TUEVDSUZJRUQQABITCg9KT0lOX1RZUEVfSU5ORVIQARITCg9KT0lOX1RZUEVfT1VURVIQAhISCg5KT0lOX1RZUEVfTEVGVBADEhMKD0pPSU5fVFlQRV9SSUdIVBAEEhcKE0pPSU5fVFlQRV9MRUZUX1NFTUkQBRIYChRKT0lOX1RZUEVfUklHSFRfU0VNSRAGEhcKE0pPSU5fVFlQRV9MRUZUX0FOVEkQBxIYChRKT0lOX1RZUEVfUklHSFRfQU5USRAIIvwDChFOZXN0ZWRMb29wSm9pblJlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEhwKBGxlZnQYAiABKAsyDi5zdWJzdHJhaXQuUmVsEh0KBXJpZ2h0GAMgASgLMg4uc3Vic3RyYWl0LlJlbBIpCgpleHByZXNzaW9uGAQgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SMwoEdHlwZRgFIAEoDjIlLnN1YnN0cmFpdC5OZXN0ZWRMb29wSm9pblJlbC5Kb2luVHlwZRJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbiLeAQoISm9pblR5cGUSGQoVSk9JTl9UWVBFX1VOU1BFQ0lGSUVEEAASEwoPSk9JTl9UWVBFX0lOTkVSEAESEwoPSk9JTl9UWVBFX09VVEVSEAISEgoOSk9JTl9UWVBFX0xFRlQQAxITCg9KT0lOX1RZUEVfUklHSFQQBBIXChNKT0lOX1RZUEVfTEVGVF9TRU1JEAUSGAoUSk9JTl9UWVBFX1JJR0hUX1NFTUkQBhIXChNKT0lOX1RZUEVfTEVGVF9BTlRJEAcSGAoUSk9JTl9UWVBFX1JJR0hUX0FOVEkQCCJ3ChBGdW5jdGlvbkFyZ3VtZW50Eg4KBGVudW0YASABKAlIABIfCgR0eXBlGAIgASgLMg8uc3Vic3RyYWl0LlR5cGVIABImCgV2YWx1ZRgDIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uSABCCgoIYXJnX3R5cGUiMgoORnVuY3Rpb25PcHRpb24SDAoEbmFtZRgBIAEoCRISCgpwcmVmZXJlbmNlGAIgAygJIpVJCgpFeHByZXNzaW9uEjAKB2xpdGVyYWwYASABKAsyHS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsSAASOQoJc2VsZWN0aW9uGAIgASgLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uRmllbGRSZWZlcmVuY2VIABI/Cg9zY2FsYXJfZnVuY3Rpb24YAyABKAsyJC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5TY2FsYXJGdW5jdGlvbkgAEj8KD3dpbmRvd19mdW5jdGlvbhgFIAEoCzIkLnN1YnN0cmFpdC5FeHByZXNzaW9uLldpbmRvd0Z1bmN0aW9uSAASLwoHaWZfdGhlbhgGIAEoCzIcLnN1YnN0cmFpdC5FeHByZXNzaW9uLklmVGhlbkgAEkMKEXN3aXRjaF9leHByZXNzaW9uGAcgASgLMiYuc3Vic3RyYWl0LkV4cHJlc3Npb24uU3dpdGNoRXhwcmVzc2lvbkgAEkAKEHNpbmd1bGFyX29yX2xpc3QYCCABKAsyJC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5TaW5ndWxhck9yTGlzdEgAEjoKDW11bHRpX29yX2xpc3QYCSABKAsyIS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NdWx0aU9yTGlzdEgAEioKBGNhc3QYCyABKAsyGi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5DYXN0SAASMgoIc3VicXVlcnkYDCABKAsyHi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5TdWJxdWVyeUgAEi4KBm5lc3RlZBgNIAEoCzIcLnN1YnN0cmFpdC5FeHByZXNzaW9uLk5lc3RlZEgAEi4KBGVudW0YCiABKAsyGi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5FbnVtQgIYAUgAGnIKBEVudW0SEwoJc3BlY2lmaWVkGAEgASgJSAASNwoLdW5zcGVjaWZpZWQYAiABKAsyIC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5FbnVtLkVtcHR5SAAaCwoFRW1wdHk6AhgBOgIYAUILCgllbnVtX2tpbmQajg8KB0xpdGVyYWwSEQoHYm9vbGVhbhgBIAEoCEgAEgwKAmk4GAIgASgFSAASDQoDaTE2GAMgASgFSAASDQoDaTMyGAUgASgFSAASDQoDaTY0GAcgASgDSAASDgoEZnAzMhgKIAEoAkgAEg4KBGZwNjQYCyABKAFIABIQCgZzdHJpbmcYDCABKAlIABIQCgZiaW5hcnkYDSABKAxIABIXCgl0aW1lc3RhbXAYDiABKANCAhgBSAASDgoEZGF0ZRgQIAEoBUgAEg4KBHRpbWUYESABKANIABJTChZpbnRlcnZhbF95ZWFyX3RvX21vbnRoGBMgASgLMjEuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5JbnRlcnZhbFllYXJUb01vbnRoSAASUwoWaW50ZXJ2YWxfZGF5X3RvX3NlY29uZBgUIAEoCzIxLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwuSW50ZXJ2YWxEYXlUb1NlY29uZEgAEhQKCmZpeGVkX2NoYXIYFSABKAlIABI5Cgh2YXJfY2hhchgWIAEoCzIlLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwuVmFyQ2hhckgAEhYKDGZpeGVkX2JpbmFyeRgXIAEoDEgAEjgKB2RlY2ltYWwYGCABKAsyJS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsLkRlY2ltYWxIABJPChNwcmVjaXNpb25fdGltZXN0YW1wGCIgASgLMjAuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5QcmVjaXNpb25UaW1lc3RhbXBIABJSChZwcmVjaXNpb25fdGltZXN0YW1wX3R6GCMgASgLMjAuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5QcmVjaXNpb25UaW1lc3RhbXBIABI2CgZzdHJ1Y3QYGSABKAsyJC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsLlN0cnVjdEgAEjAKA21hcBgaIAEoCzIhLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwuTWFwSAASGgoMdGltZXN0YW1wX3R6GBsgASgDQgIYAUgAEg4KBHV1aWQYHCABKAxIABIfCgRudWxsGB0gASgLMg8uc3Vic3RyYWl0LlR5cGVIABIyCgRsaXN0GB4gASgLMiIuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5MaXN0SAASKgoKZW1wdHlfbGlzdBgfIAEoCzIULnN1YnN0cmFpdC5UeXBlLkxpc3RIABIoCgllbXB0eV9tYXAYICABKAsyEy5zdWJzdHJhaXQuVHlwZS5NYXBIABJBCgx1c2VyX2RlZmluZWQYISABKAsyKS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsLlVzZXJEZWZpbmVkSAASEAoIbnVsbGFibGUYMiABKAgSIAoYdHlwZV92YXJpYXRpb25fcmVmZXJlbmNlGDMgASgNGigKB1ZhckNoYXISDQoFdmFsdWUYASABKAkSDgoGbGVuZ3RoGAIgASgNGjoKB0RlY2ltYWwSDQoFdmFsdWUYASABKAwSEQoJcHJlY2lzaW9uGAIgASgFEg0KBXNjYWxlGAMgASgFGjYKElByZWNpc2lvblRpbWVzdGFtcBIRCglwcmVjaXNpb24YASABKAUSDQoFdmFsdWUYAiABKAQaqwEKA01hcBI+CgprZXlfdmFsdWVzGAEgAygLMiouc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5NYXAuS2V5VmFsdWUaZAoIS2V5VmFsdWUSKgoDa2V5GAEgASgLMh0uc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbBIsCgV2YWx1ZRgCIAEoCzIdLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwaNAoTSW50ZXJ2YWxZZWFyVG9Nb250aBINCgV5ZWFycxgBIAEoBRIOCgZtb250aHMYAiABKAUaSgoTSW50ZXJ2YWxEYXlUb1NlY29uZBIMCgRkYXlzGAEgASgFEg8KB3NlY29uZHMYAiABKAUSFAoMbWljcm9zZWNvbmRzGAMgASgFGjcKBlN0cnVjdBItCgZmaWVsZHMYASADKAsyHS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsGjUKBExpc3QSLQoGdmFsdWVzGAEgAygLMh0uc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbBq/AQoLVXNlckRlZmluZWQSFgoOdHlwZV9yZWZlcmVuY2UYASABKA0SMgoPdHlwZV9wYXJhbWV0ZXJzGAMgAygLMhkuc3Vic3RyYWl0LlR5cGUuUGFyYW1ldGVyEiUKBXZhbHVlGAIgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueUgAEjYKBnN0cnVjdBgEIAEoCzIkLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwuU3RydWN0SABCBQoDdmFsQg4KDGxpdGVyYWxfdHlwZRrjAwoGTmVzdGVkEhAKCG51bGxhYmxlGAEgASgIEiAKGHR5cGVfdmFyaWF0aW9uX3JlZmVyZW5jZRgCIAEoDRI1CgZzdHJ1Y3QYAyABKAsyIy5zdWJzdHJhaXQuRXhwcmVzc2lvbi5OZXN0ZWQuU3RydWN0SAASMQoEbGlzdBgEIAEoCzIhLnN1YnN0cmFpdC5FeHByZXNzaW9uLk5lc3RlZC5MaXN0SAASLwoDbWFwGAUgASgLMiAuc3Vic3RyYWl0LkV4cHJlc3Npb24uTmVzdGVkLk1hcEgAGpoBCgNNYXASPQoKa2V5X3ZhbHVlcxgBIAMoCzIpLnN1YnN0cmFpdC5FeHByZXNzaW9uLk5lc3RlZC5NYXAuS2V5VmFsdWUaVAoIS2V5VmFsdWUSIgoDa2V5GAEgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SJAoFdmFsdWUYAiABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhovCgZTdHJ1Y3QSJQoGZmllbGRzGAEgAygLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24aLQoETGlzdBIlCgZ2YWx1ZXMYASADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbkINCgtuZXN0ZWRfdHlwZRrXAQoOU2NhbGFyRnVuY3Rpb24SGgoSZnVuY3Rpb25fcmVmZXJlbmNlGAEgASgNEi4KCWFyZ3VtZW50cxgEIAMoCzIbLnN1YnN0cmFpdC5GdW5jdGlvbkFyZ3VtZW50EioKB29wdGlvbnMYBSADKAsyGS5zdWJzdHJhaXQuRnVuY3Rpb25PcHRpb24SJAoLb3V0cHV0X3R5cGUYAyABKAsyDy5zdWJzdHJhaXQuVHlwZRInCgRhcmdzGAIgAygLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb25CAhgBGtEICg5XaW5kb3dGdW5jdGlvbhIaChJmdW5jdGlvbl9yZWZlcmVuY2UYASABKA0SLgoJYXJndW1lbnRzGAkgAygLMhsuc3Vic3RyYWl0LkZ1bmN0aW9uQXJndW1lbnQSKgoHb3B0aW9ucxgLIAMoCzIZLnN1YnN0cmFpdC5GdW5jdGlvbk9wdGlvbhIkCgtvdXRwdXRfdHlwZRgHIAEoCzIPLnN1YnN0cmFpdC5UeXBlEioKBXBoYXNlGAYgASgOMhsuc3Vic3RyYWl0LkFnZ3JlZ2F0aW9uUGhhc2USIwoFc29ydHMYAyADKAsyFC5zdWJzdHJhaXQuU29ydEZpZWxkEkYKCmludm9jYXRpb24YCiABKA4yMi5zdWJzdHJhaXQuQWdncmVnYXRlRnVuY3Rpb24uQWdncmVnYXRpb25JbnZvY2F0aW9uEikKCnBhcnRpdGlvbnMYAiADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhJECgtib3VuZHNfdHlwZRgMIAEoDjIvLnN1YnN0cmFpdC5FeHByZXNzaW9uLldpbmRvd0Z1bmN0aW9uLkJvdW5kc1R5cGUSPwoLbG93ZXJfYm91bmQYBSABKAsyKi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5XaW5kb3dGdW5jdGlvbi5Cb3VuZBI/Cgt1cHBlcl9ib3VuZBgEIAEoCzIqLnN1YnN0cmFpdC5FeHByZXNzaW9uLldpbmRvd0Z1bmN0aW9uLkJvdW5kEicKBGFyZ3MYCCADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbkICGAEakwMKBUJvdW5kEkkKCXByZWNlZGluZxgBIAEoCzI0LnN1YnN0cmFpdC5FeHByZXNzaW9uLldpbmRvd0Z1bmN0aW9uLkJvdW5kLlByZWNlZGluZ0gAEkkKCWZvbGxvd2luZxgCIAEoCzI0LnN1YnN0cmFpdC5FeHByZXNzaW9uLldpbmRvd0Z1bmN0aW9uLkJvdW5kLkZvbGxvd2luZ0gAEkwKC2N1cnJlbnRfcm93GAMgASgLMjUuc3Vic3RyYWl0LkV4cHJlc3Npb24uV2luZG93RnVuY3Rpb24uQm91bmQuQ3VycmVudFJvd0gAEkkKCXVuYm91bmRlZBgEIAEoCzI0LnN1YnN0cmFpdC5FeHByZXNzaW9uLldpbmRvd0Z1bmN0aW9uLkJvdW5kLlVuYm91bmRlZEgAGhsKCVByZWNlZGluZxIOCgZvZmZzZXQYASABKAMaGwoJRm9sbG93aW5nEg4KBm9mZnNldBgBIAEoAxoMCgpDdXJyZW50Um93GgsKCVVuYm91bmRlZEIGCgRraW5kIlYKCkJvdW5kc1R5cGUSGwoXQk9VTkRTX1RZUEVfVU5TUEVDSUZJRUQQABIUChBCT1VORFNfVFlQRV9ST1dTEAESFQoRQk9VTkRTX1RZUEVfUkFOR0UQAhq1AQoGSWZUaGVuEjIKA2lmcxgBIAMoCzIlLnN1YnN0cmFpdC5FeHByZXNzaW9uLklmVGhlbi5JZkNsYXVzZRIjCgRlbHNlGAIgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24aUgoISWZDbGF1c2USIQoCaWYYASABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhIjCgR0aGVuGAIgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24ajgIKBENhc3QSHQoEdHlwZRgBIAEoCzIPLnN1YnN0cmFpdC5UeXBlEiQKBWlucHV0GAIgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SRAoQZmFpbHVyZV9iZWhhdmlvchgDIAEoDjIqLnN1YnN0cmFpdC5FeHByZXNzaW9uLkNhc3QuRmFpbHVyZUJlaGF2aW9yInsKD0ZhaWx1cmVCZWhhdmlvchIgChxGQUlMVVJFX0JFSEFWSU9SX1VOU1BFQ0lGSUVEEAASIAocRkFJTFVSRV9CRUhBVklPUl9SRVRVUk5fTlVMTBABEiQKIEZBSUxVUkVfQkVIQVZJT1JfVEhST1dfRVhDRVBUSU9OEAIa9QEKEFN3aXRjaEV4cHJlc3Npb24SJAoFbWF0Y2gYAyABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhI7CgNpZnMYASADKAsyLi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5Td2l0Y2hFeHByZXNzaW9uLklmVmFsdWUSIwoEZWxzZRgCIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uGlkKB0lmVmFsdWUSKQoCaWYYASABKAsyHS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsEiMKBHRoZW4YAiABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhpeCg5TaW5ndWxhck9yTGlzdBIkCgV2YWx1ZRgBIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEiYKB29wdGlvbnMYAiADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhqfAQoLTXVsdGlPckxpc3QSJAoFdmFsdWUYASADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhI5CgdvcHRpb25zGAIgAygLMiguc3Vic3RyYWl0LkV4cHJlc3Npb24uTXVsdGlPckxpc3QuUmVjb3JkGi8KBlJlY29yZBIlCgZmaWVsZHMYASADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhqjAwoQRW1iZWRkZWRGdW5jdGlvbhIoCglhcmd1bWVudHMYASADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhIkCgtvdXRwdXRfdHlwZRgCIAEoCzIPLnN1YnN0cmFpdC5UeXBlEl0KFnB5dGhvbl9waWNrbGVfZnVuY3Rpb24YAyABKAsyOy5zdWJzdHJhaXQuRXhwcmVzc2lvbi5FbWJlZGRlZEZ1bmN0aW9uLlB5dGhvblBpY2tsZUZ1bmN0aW9uSAASWwoVd2ViX2Fzc2VtYmx5X2Z1bmN0aW9uGAQgASgLMjouc3Vic3RyYWl0LkV4cHJlc3Npb24uRW1iZWRkZWRGdW5jdGlvbi5XZWJBc3NlbWJseUZ1bmN0aW9uSAAaPgoUUHl0aG9uUGlja2xlRnVuY3Rpb24SEAoIZnVuY3Rpb24YASABKAwSFAoMcHJlcmVxdWlzaXRlGAIgAygJGjsKE1dlYkFzc2VtYmx5RnVuY3Rpb24SDgoGc2NyaXB0GAEgASgMEhQKDHByZXJlcXVpc2l0ZRgCIAMoCUIGCgRraW5kGpoEChBSZWZlcmVuY2VTZWdtZW50EkAKB21hcF9rZXkYASABKAsyLS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5SZWZlcmVuY2VTZWdtZW50Lk1hcEtleUgAEkoKDHN0cnVjdF9maWVsZBgCIAEoCzIyLnN1YnN0cmFpdC5FeHByZXNzaW9uLlJlZmVyZW5jZVNlZ21lbnQuU3RydWN0RmllbGRIABJKCgxsaXN0X2VsZW1lbnQYAyABKAsyMi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5SZWZlcmVuY2VTZWdtZW50Lkxpc3RFbGVtZW50SAAabwoGTWFwS2V5Ei4KB21hcF9rZXkYASABKAsyHS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsEjUKBWNoaWxkGAIgASgLMiYuc3Vic3RyYWl0LkV4cHJlc3Npb24uUmVmZXJlbmNlU2VnbWVudBpTCgtTdHJ1Y3RGaWVsZBINCgVmaWVsZBgBIAEoBRI1CgVjaGlsZBgCIAEoCzImLnN1YnN0cmFpdC5FeHByZXNzaW9uLlJlZmVyZW5jZVNlZ21lbnQaVAoLTGlzdEVsZW1lbnQSDgoGb2Zmc2V0GAEgASgFEjUKBWNoaWxkGAIgASgLMiYuc3Vic3RyYWl0LkV4cHJlc3Npb24uUmVmZXJlbmNlU2VnbWVudEIQCg5yZWZlcmVuY2VfdHlwZRrwCQoOTWFza0V4cHJlc3Npb24SQQoGc2VsZWN0GAEgASgLMjEuc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb24uU3RydWN0U2VsZWN0EiAKGG1haW50YWluX3Npbmd1bGFyX3N0cnVjdBgCIAEoCBrVAQoGU2VsZWN0EkMKBnN0cnVjdBgBIAEoCzIxLnN1YnN0cmFpdC5FeHByZXNzaW9uLk1hc2tFeHByZXNzaW9uLlN0cnVjdFNlbGVjdEgAEj8KBGxpc3QYAiABKAsyLy5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NYXNrRXhwcmVzc2lvbi5MaXN0U2VsZWN0SAASPQoDbWFwGAMgASgLMi4uc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb24uTWFwU2VsZWN0SABCBgoEdHlwZRpVCgxTdHJ1Y3RTZWxlY3QSRQoMc3RydWN0X2l0ZW1zGAEgAygLMi8uc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb24uU3RydWN0SXRlbRpXCgpTdHJ1Y3RJdGVtEg0KBWZpZWxkGAEgASgFEjoKBWNoaWxkGAIgASgLMisuc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb24uU2VsZWN0GrQDCgpMaXN0U2VsZWN0ElEKCXNlbGVjdGlvbhgBIAMoCzI+LnN1YnN0cmFpdC5FeHByZXNzaW9uLk1hc2tFeHByZXNzaW9uLkxpc3RTZWxlY3QuTGlzdFNlbGVjdEl0ZW0SOgoFY2hpbGQYAiABKAsyKy5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NYXNrRXhwcmVzc2lvbi5TZWxlY3QalgIKDkxpc3RTZWxlY3RJdGVtEloKBGl0ZW0YASABKAsySi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NYXNrRXhwcmVzc2lvbi5MaXN0U2VsZWN0Lkxpc3RTZWxlY3RJdGVtLkxpc3RFbGVtZW50SAASWQoFc2xpY2UYAiABKAsySC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NYXNrRXhwcmVzc2lvbi5MaXN0U2VsZWN0Lkxpc3RTZWxlY3RJdGVtLkxpc3RTbGljZUgAGhwKC0xpc3RFbGVtZW50Eg0KBWZpZWxkGAEgASgFGicKCUxpc3RTbGljZRINCgVzdGFydBgBIAEoBRILCgNlbmQYAiABKAVCBgoEdHlwZRq5AgoJTWFwU2VsZWN0EkQKA2tleRgBIAEoCzI1LnN1YnN0cmFpdC5FeHByZXNzaW9uLk1hc2tFeHByZXNzaW9uLk1hcFNlbGVjdC5NYXBLZXlIABJVCgpleHByZXNzaW9uGAIgASgLMj8uc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb24uTWFwU2VsZWN0Lk1hcEtleUV4cHJlc3Npb25IABI6CgVjaGlsZBgDIAEoCzIrLnN1YnN0cmFpdC5FeHByZXNzaW9uLk1hc2tFeHByZXNzaW9uLlNlbGVjdBoZCgZNYXBLZXkSDwoHbWFwX2tleRgBIAEoCRouChBNYXBLZXlFeHByZXNzaW9uEhoKEm1hcF9rZXlfZXhwcmVzc2lvbhgBIAEoCUIICgZzZWxlY3QatgMKDkZpZWxkUmVmZXJlbmNlEkIKEGRpcmVjdF9yZWZlcmVuY2UYASABKAsyJi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5SZWZlcmVuY2VTZWdtZW50SAASQAoQbWFza2VkX3JlZmVyZW5jZRgCIAEoCzIkLnN1YnN0cmFpdC5FeHByZXNzaW9uLk1hc2tFeHByZXNzaW9uSAASKwoKZXhwcmVzc2lvbhgDIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uSAESTAoOcm9vdF9yZWZlcmVuY2UYBCABKAsyMi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5GaWVsZFJlZmVyZW5jZS5Sb290UmVmZXJlbmNlSAESTgoPb3V0ZXJfcmVmZXJlbmNlGAUgASgLMjMuc3Vic3RyYWl0LkV4cHJlc3Npb24uRmllbGRSZWZlcmVuY2UuT3V0ZXJSZWZlcmVuY2VIARoPCg1Sb290UmVmZXJlbmNlGiMKDk91dGVyUmVmZXJlbmNlEhEKCXN0ZXBzX291dBgBIAEoDUIQCg5yZWZlcmVuY2VfdHlwZUILCglyb290X3R5cGUajAkKCFN1YnF1ZXJ5EjcKBnNjYWxhchgBIAEoCzIlLnN1YnN0cmFpdC5FeHByZXNzaW9uLlN1YnF1ZXJ5LlNjYWxhckgAEkIKDGluX3ByZWRpY2F0ZRgCIAEoCzIqLnN1YnN0cmFpdC5FeHByZXNzaW9uLlN1YnF1ZXJ5LkluUHJlZGljYXRlSAASRAoNc2V0X3ByZWRpY2F0ZRgDIAEoCzIrLnN1YnN0cmFpdC5FeHByZXNzaW9uLlN1YnF1ZXJ5LlNldFByZWRpY2F0ZUgAEkYKDnNldF9jb21wYXJpc29uGAQgASgLMiwuc3Vic3RyYWl0LkV4cHJlc3Npb24uU3VicXVlcnkuU2V0Q29tcGFyaXNvbkgAGicKBlNjYWxhchIdCgVpbnB1dBgBIAEoCzIOLnN1YnN0cmFpdC5SZWwaVwoLSW5QcmVkaWNhdGUSJgoHbmVlZGxlcxgBIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEiAKCGhheXN0YWNrGAIgASgLMg4uc3Vic3RyYWl0LlJlbBrcAQoMU2V0UHJlZGljYXRlEk0KDHByZWRpY2F0ZV9vcBgBIAEoDjI3LnN1YnN0cmFpdC5FeHByZXNzaW9uLlN1YnF1ZXJ5LlNldFByZWRpY2F0ZS5QcmVkaWNhdGVPcBIeCgZ0dXBsZXMYAiABKAsyDi5zdWJzdHJhaXQuUmVsIl0KC1ByZWRpY2F0ZU9wEhwKGFBSRURJQ0FURV9PUF9VTlNQRUNJRklFRBAAEhcKE1BSRURJQ0FURV9PUF9FWElTVFMQARIXChNQUkVESUNBVEVfT1BfVU5JUVVFEAIaggQKDVNldENvbXBhcmlzb24STgoMcmVkdWN0aW9uX29wGAEgASgOMjguc3Vic3RyYWl0LkV4cHJlc3Npb24uU3VicXVlcnkuU2V0Q29tcGFyaXNvbi5SZWR1Y3Rpb25PcBJQCg1jb21wYXJpc29uX29wGAIgASgOMjkuc3Vic3RyYWl0LkV4cHJlc3Npb24uU3VicXVlcnkuU2V0Q29tcGFyaXNvbi5Db21wYXJpc29uT3ASIwoEbGVmdBgDIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEh0KBXJpZ2h0GAQgASgLMg4uc3Vic3RyYWl0LlJlbCKxAQoMQ29tcGFyaXNvbk9wEh0KGUNPTVBBUklTT05fT1BfVU5TUEVDSUZJRUQQABIUChBDT01QQVJJU09OX09QX0VREAESFAoQQ09NUEFSSVNPTl9PUF9ORRACEhQKEENPTVBBUklTT05fT1BfTFQQAxIUChBDT01QQVJJU09OX09QX0dUEAQSFAoQQ09NUEFSSVNPTl9PUF9MRRAFEhQKEENPTVBBUklTT05fT1BfR0UQBiJXCgtSZWR1Y3Rpb25PcBIcChhSRURVQ1RJT05fT1BfVU5TUEVDSUZJRUQQABIUChBSRURVQ1RJT05fT1BfQU5ZEAESFAoQUkVEVUNUSU9OX09QX0FMTBACQg8KDXN1YnF1ZXJ5X3R5cGVCCgoIcmV4X3R5cGUi/wIKCVNvcnRGaWVsZBIjCgRleHByGAEgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SNwoJZGlyZWN0aW9uGAIgASgOMiIuc3Vic3RyYWl0LlNvcnRGaWVsZC5Tb3J0RGlyZWN0aW9uSAASJwodY29tcGFyaXNvbl9mdW5jdGlvbl9yZWZlcmVuY2UYAyABKA1IACLdAQoNU29ydERpcmVjdGlvbhIeChpTT1JUX0RJUkVDVElPTl9VTlNQRUNJRklFRBAAEiIKHlNPUlRfRElSRUNUSU9OX0FTQ19OVUxMU19GSVJTVBABEiEKHVNPUlRfRElSRUNUSU9OX0FTQ19OVUxMU19MQVNUEAISIwofU09SVF9ESVJFQ1RJT05fREVTQ19OVUxMU19GSVJTVBADEiIKHlNPUlRfRElSRUNUSU9OX0RFU0NfTlVMTFNfTEFTVBAEEhwKGFNPUlRfRElSRUNUSU9OX0NMVVNURVJFRBAFQgsKCXNvcnRfa2luZCL6AwoRQWdncmVnYXRlRnVuY3Rpb24SGgoSZnVuY3Rpb25fcmVmZXJlbmNlGAEgASgNEi4KCWFyZ3VtZW50cxgHIAMoCzIbLnN1YnN0cmFpdC5GdW5jdGlvbkFyZ3VtZW50EioKB29wdGlvbnMYCCADKAsyGS5zdWJzdHJhaXQuRnVuY3Rpb25PcHRpb24SJAoLb3V0cHV0X3R5cGUYBSABKAsyDy5zdWJzdHJhaXQuVHlwZRIqCgVwaGFzZRgEIAEoDjIbLnN1YnN0cmFpdC5BZ2dyZWdhdGlvblBoYXNlEiMKBXNvcnRzGAMgAygLMhQuc3Vic3RyYWl0LlNvcnRGaWVsZBJGCgppbnZvY2F0aW9uGAYgASgOMjIuc3Vic3RyYWl0LkFnZ3JlZ2F0ZUZ1bmN0aW9uLkFnZ3JlZ2F0aW9uSW52b2NhdGlvbhInCgRhcmdzGAIgAygLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb25CAhgBIoQBChVBZ2dyZWdhdGlvbkludm9jYXRpb24SJgoiQUdHUkVHQVRJT05fSU5WT0NBVElPTl9VTlNQRUNJRklFRBAAEh4KGkFHR1JFR0FUSU9OX0lOVk9DQVRJT05fQUxMEAESIwofQUdHUkVHQVRJT05fSU5WT0NBVElPTl9ESVNUSU5DVBACIicKDFJlZmVyZW5jZVJlbBIXCg9zdWJ0cmVlX29yZGluYWwYASABKAUq7wEKEEFnZ3JlZ2F0aW9uUGhhc2USIQodQUdHUkVHQVRJT05fUEhBU0VfVU5TUEVDSUZJRUQQABItCilBR0dSRUdBVElPTl9QSEFTRV9JTklUSUFMX1RPX0lOVEVSTUVESUFURRABEjIKLkFHR1JFR0FUSU9OX1BIQVNFX0lOVEVSTUVESUFURV9UT19JTlRFUk1FRElBVEUQAhInCiNBR0dSRUdBVElPTl9QSEFTRV9JTklUSUFMX1RPX1JFU1VMVBADEiwKKEFHR1JFR0FUSU9OX1BIQVNFX0lOVEVSTUVESUFURV9UT19SRVNVTFQQBEJXChJpby5zdWJzdHJhaXQucHJvdG9QAVoqZ2l0aHViLmNvbS9zdWJzdHJhaXQtaW8vc3Vic3RyYWl0LWdvL3Byb3RvqgISU3Vic3RyYWl0LlByb3RvYnVmYgZwcm90bzM", [file_google_protobuf_any, file_substrait_extensions_extensions, file_substrait_type]);

/**
 * Common fields for all relational operators
 *
 * @generated from message substrait.RelCommon
 */
export type RelCommon = Message<"substrait.RelCommon"> & {
  /**
   * @generated from oneof substrait.RelCommon.emit_kind
   */
  emitKind: {
    /**
     * The underlying relation is output as is (no reordering or projection of columns)
     *
     * @generated from field: substrait.RelCommon.Direct direct = 1;
     */
    value: RelCommon_Direct;
    case: "direct";
  } | {
    /**
     * Allows to control for order and inclusion of fields
     *
     * @generated from field: substrait.RelCommon.Emit emit = 2;
     */
    value: RelCommon_Emit;
    case: "emit";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: substrait.RelCommon.Hint hint = 3;
   */
  hint?: RelCommon_Hint;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 4;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.RelCommon.
 * Use `create(RelCommonSchema)` to create a new message.
 */
export const RelCommonSchema: GenMessage<RelCommon> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0);

/**
 * Direct indicates no change on presence and ordering of fields in the output
 *
 * @generated from message substrait.RelCommon.Direct
 */
export type RelCommon_Direct = Message<"substrait.RelCommon.Direct"> & {
};

/**
 * Describes the message substrait.RelCommon.Direct.
 * Use `create(RelCommon_DirectSchema)` to create a new message.
 */
export const RelCommon_DirectSchema: GenMessage<RelCommon_Direct> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 0);

/**
 * Remap which fields are output and in which order
 *
 * @generated from message substrait.RelCommon.Emit
 */
export type RelCommon_Emit = Message<"substrait.RelCommon.Emit"> & {
  /**
   * @generated from field: repeated int32 output_mapping = 1;
   */
  outputMapping: number[];
};

/**
 * Describes the message substrait.RelCommon.Emit.
 * Use `create(RelCommon_EmitSchema)` to create a new message.
 */
export const RelCommon_EmitSchema: GenMessage<RelCommon_Emit> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 1);

/**
 * Changes to the operation that can influence efficiency/performance but
 * should not impact correctness.
 *
 * @generated from message substrait.RelCommon.Hint
 */
export type RelCommon_Hint = Message<"substrait.RelCommon.Hint"> & {
  /**
   * @generated from field: substrait.RelCommon.Hint.Stats stats = 1;
   */
  stats?: RelCommon_Hint_Stats;

  /**
   * @generated from field: substrait.RelCommon.Hint.RuntimeConstraint constraint = 2;
   */
  constraint?: RelCommon_Hint_RuntimeConstraint;

  /**
   * Name (alias) for this relation. Can be used for e.g. qualifying the relation (see e.g.
   * Spark's SubqueryAlias), or debugging.
   *
   * @generated from field: string alias = 3;
   */
  alias: string;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.RelCommon.Hint.
 * Use `create(RelCommon_HintSchema)` to create a new message.
 */
export const RelCommon_HintSchema: GenMessage<RelCommon_Hint> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 2);

/**
 * The statistics related to a hint (physical properties of records)
 *
 * @generated from message substrait.RelCommon.Hint.Stats
 */
export type RelCommon_Hint_Stats = Message<"substrait.RelCommon.Hint.Stats"> & {
  /**
   * @generated from field: double row_count = 1;
   */
  rowCount: number;

  /**
   * @generated from field: double record_size = 2;
   */
  recordSize: number;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.RelCommon.Hint.Stats.
 * Use `create(RelCommon_Hint_StatsSchema)` to create a new message.
 */
export const RelCommon_Hint_StatsSchema: GenMessage<RelCommon_Hint_Stats> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 2, 0);

/**
 * TODO: nodes, cpu threads/%, memory, iops, etc.
 *
 * @generated from message substrait.RelCommon.Hint.RuntimeConstraint
 */
export type RelCommon_Hint_RuntimeConstraint = Message<"substrait.RelCommon.Hint.RuntimeConstraint"> & {
  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.RelCommon.Hint.RuntimeConstraint.
 * Use `create(RelCommon_Hint_RuntimeConstraintSchema)` to create a new message.
 */
export const RelCommon_Hint_RuntimeConstraintSchema: GenMessage<RelCommon_Hint_RuntimeConstraint> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 2, 1);

/**
 * The scan operator of base data (physical or virtual), including filtering and projection.
 *
 * @generated from message substrait.ReadRel
 */
export type ReadRel = Message<"substrait.ReadRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.NamedStruct base_schema = 2;
   */
  baseSchema?: NamedStruct;

  /**
   * @generated from field: substrait.Expression filter = 3;
   */
  filter?: Expression;

  /**
   * @generated from field: substrait.Expression best_effort_filter = 11;
   */
  bestEffortFilter?: Expression;

  /**
   * @generated from field: substrait.Expression.MaskExpression projection = 4;
   */
  projection?: Expression_MaskExpression;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;

  /**
   * Definition of which type of scan operation is to be performed
   *
   * @generated from oneof substrait.ReadRel.read_type
   */
  readType: {
    /**
     * @generated from field: substrait.ReadRel.VirtualTable virtual_table = 5;
     */
    value: ReadRel_VirtualTable;
    case: "virtualTable";
  } | {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles local_files = 6;
     */
    value: ReadRel_LocalFiles;
    case: "localFiles";
  } | {
    /**
     * @generated from field: substrait.ReadRel.NamedTable named_table = 7;
     */
    value: ReadRel_NamedTable;
    case: "namedTable";
  } | {
    /**
     * @generated from field: substrait.ReadRel.ExtensionTable extension_table = 8;
     */
    value: ReadRel_ExtensionTable;
    case: "extensionTable";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ReadRel.
 * Use `create(ReadRelSchema)` to create a new message.
 */
export const ReadRelSchema: GenMessage<ReadRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1);

/**
 * A base table. The list of string is used to represent namespacing (e.g., mydb.mytable).
 * This assumes shared catalog between systems exchanging a message.
 *
 * @generated from message substrait.ReadRel.NamedTable
 */
export type ReadRel_NamedTable = Message<"substrait.ReadRel.NamedTable"> & {
  /**
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.ReadRel.NamedTable.
 * Use `create(ReadRel_NamedTableSchema)` to create a new message.
 */
export const ReadRel_NamedTableSchema: GenMessage<ReadRel_NamedTable> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 0);

/**
 * A table composed of literals.
 *
 * @generated from message substrait.ReadRel.VirtualTable
 */
export type ReadRel_VirtualTable = Message<"substrait.ReadRel.VirtualTable"> & {
  /**
   * @generated from field: repeated substrait.Expression.Literal.Struct values = 1;
   */
  values: Expression_Literal_Struct[];
};

/**
 * Describes the message substrait.ReadRel.VirtualTable.
 * Use `create(ReadRel_VirtualTableSchema)` to create a new message.
 */
export const ReadRel_VirtualTableSchema: GenMessage<ReadRel_VirtualTable> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 1);

/**
 * A stub type that can be used to extend/introduce new table types outside
 * the specification.
 *
 * @generated from message substrait.ReadRel.ExtensionTable
 */
export type ReadRel_ExtensionTable = Message<"substrait.ReadRel.ExtensionTable"> & {
  /**
   * @generated from field: google.protobuf.Any detail = 1;
   */
  detail?: Any;
};

/**
 * Describes the message substrait.ReadRel.ExtensionTable.
 * Use `create(ReadRel_ExtensionTableSchema)` to create a new message.
 */
export const ReadRel_ExtensionTableSchema: GenMessage<ReadRel_ExtensionTable> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 2);

/**
 * Represents a list of files in input of a scan operation
 *
 * @generated from message substrait.ReadRel.LocalFiles
 */
export type ReadRel_LocalFiles = Message<"substrait.ReadRel.LocalFiles"> & {
  /**
   * @generated from field: repeated substrait.ReadRel.LocalFiles.FileOrFiles items = 1;
   */
  items: ReadRel_LocalFiles_FileOrFiles[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.
 * Use `create(ReadRel_LocalFilesSchema)` to create a new message.
 */
export const ReadRel_LocalFilesSchema: GenMessage<ReadRel_LocalFiles> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 3);

/**
 * Many files consist of indivisible chunks (e.g. parquet row groups
 * or CSV rows).  If a slice partially selects an indivisible chunk
 * then the consumer should employ some rule to decide which slice to
 * include the chunk in (e.g. include it in the slice that contains
 * the midpoint of the chunk)
 *
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles
 */
export type ReadRel_LocalFiles_FileOrFiles = Message<"substrait.ReadRel.LocalFiles.FileOrFiles"> & {
  /**
   * @generated from oneof substrait.ReadRel.LocalFiles.FileOrFiles.path_type
   */
  pathType: {
    /**
     * A URI that can refer to either a single folder or a single file
     *
     * @generated from field: string uri_path = 1;
     */
    value: string;
    case: "uriPath";
  } | {
    /**
     * A URI where the path portion is a glob expression that can
     * identify zero or more paths.
     * Consumers should support the POSIX syntax.  The recursive
     * globstar (**) may not be supported.
     *
     * @generated from field: string uri_path_glob = 2;
     */
    value: string;
    case: "uriPathGlob";
  } | {
    /**
     * A URI that refers to a single file
     *
     * @generated from field: string uri_file = 3;
     */
    value: string;
    case: "uriFile";
  } | {
    /**
     * A URI that refers to a single folder
     *
     * @generated from field: string uri_folder = 4;
     */
    value: string;
    case: "uriFolder";
  } | { case: undefined; value?: undefined };

  /**
   * The index of the partition this item belongs to
   *
   * @generated from field: uint64 partition_index = 6;
   */
  partitionIndex: bigint;

  /**
   * The start position in byte to read from this item
   *
   * @generated from field: uint64 start = 7;
   */
  start: bigint;

  /**
   * The length in byte to read from this item
   *
   * @generated from field: uint64 length = 8;
   */
  length: bigint;

  /**
   * The format of the files.
   *
   * @generated from oneof substrait.ReadRel.LocalFiles.FileOrFiles.file_format
   */
  fileFormat: {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions parquet = 9;
     */
    value: ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions;
    case: "parquet";
  } | {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions arrow = 10;
     */
    value: ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions;
    case: "arrow";
  } | {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions orc = 11;
     */
    value: ReadRel_LocalFiles_FileOrFiles_OrcReadOptions;
    case: "orc";
  } | {
    /**
     * @generated from field: google.protobuf.Any extension = 12;
     */
    value: Any;
    case: "extension";
  } | {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions dwrf = 13;
     */
    value: ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions;
    case: "dwrf";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.
 * Use `create(ReadRel_LocalFiles_FileOrFilesSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFilesSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 3, 0);

/**
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions
 */
export type ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions = Message<"substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions"> & {
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions.
 * Use `create(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptionsSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptionsSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 3, 0, 0);

/**
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions
 */
export type ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions = Message<"substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions"> & {
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions.
 * Use `create(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptionsSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptionsSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 3, 0, 1);

/**
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions
 */
export type ReadRel_LocalFiles_FileOrFiles_OrcReadOptions = Message<"substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions"> & {
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions.
 * Use `create(ReadRel_LocalFiles_FileOrFiles_OrcReadOptionsSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFiles_OrcReadOptionsSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles_OrcReadOptions> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 3, 0, 2);

/**
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions
 */
export type ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions = Message<"substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions"> & {
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions.
 * Use `create(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptionsSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptionsSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 3, 0, 3);

/**
 * This operator allows to represent calculated expressions of fields (e.g., a+b). Direct/Emit are used to represent classical relational projections
 *
 * @generated from message substrait.ProjectRel
 */
export type ProjectRel = Message<"substrait.ProjectRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: repeated substrait.Expression expressions = 3;
   */
  expressions: Expression[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.ProjectRel.
 * Use `create(ProjectRelSchema)` to create a new message.
 */
export const ProjectRelSchema: GenMessage<ProjectRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 2);

/**
 * The binary JOIN relational operator left-join-right, including various join types, a join condition and post_join_filter expression
 *
 * @generated from message substrait.JoinRel
 */
export type JoinRel = Message<"substrait.JoinRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel left = 2;
   */
  left?: Rel;

  /**
   * @generated from field: substrait.Rel right = 3;
   */
  right?: Rel;

  /**
   * @generated from field: substrait.Expression expression = 4;
   */
  expression?: Expression;

  /**
   * @generated from field: substrait.Expression post_join_filter = 5;
   */
  postJoinFilter?: Expression;

  /**
   * @generated from field: substrait.JoinRel.JoinType type = 6;
   */
  type: JoinRel_JoinType;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.JoinRel.
 * Use `create(JoinRelSchema)` to create a new message.
 */
export const JoinRelSchema: GenMessage<JoinRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 3);

/**
 * @generated from enum substrait.JoinRel.JoinType
 */
export enum JoinRel_JoinType {
  /**
   * @generated from enum value: JOIN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: JOIN_TYPE_INNER = 1;
   */
  INNER = 1,

  /**
   * @generated from enum value: JOIN_TYPE_OUTER = 2;
   */
  OUTER = 2,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT = 3;
   */
  LEFT = 3,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT = 4;
   */
  RIGHT = 4,

  /**
   * @generated from enum value: JOIN_TYPE_SEMI = 5;
   */
  SEMI = 5,

  /**
   * @generated from enum value: JOIN_TYPE_ANTI = 6;
   */
  ANTI = 6,

  /**
   * This join is useful for nested sub-queries where we need exactly one record in output (or throw exception)
   * See Section 3.2 of https://15721.courses.cs.cmu.edu/spring2018/papers/16-optimizer2/hyperjoins-btw2017.pdf
   *
   * @generated from enum value: JOIN_TYPE_SINGLE = 7;
   */
  SINGLE = 7,
}

/**
 * Describes the enum substrait.JoinRel.JoinType.
 */
export const JoinRel_JoinTypeSchema: GenEnum<JoinRel_JoinType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 3, 0);

/**
 * Cartesian product relational operator of two tables (left and right)
 *
 * @generated from message substrait.CrossRel
 */
export type CrossRel = Message<"substrait.CrossRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel left = 2;
   */
  left?: Rel;

  /**
   * @generated from field: substrait.Rel right = 3;
   */
  right?: Rel;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.CrossRel.
 * Use `create(CrossRelSchema)` to create a new message.
 */
export const CrossRelSchema: GenMessage<CrossRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 4);

/**
 * The relational operator representing LIMIT/OFFSET or TOP type semantics.
 *
 * @generated from message substrait.FetchRel
 */
export type FetchRel = Message<"substrait.FetchRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * the offset expressed in number of records
   *
   * @generated from field: int64 offset = 3;
   */
  offset: bigint;

  /**
   * the amount of records to return
   * use -1 to signal that ALL records should be returned
   *
   * @generated from field: int64 count = 4;
   */
  count: bigint;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.FetchRel.
 * Use `create(FetchRelSchema)` to create a new message.
 */
export const FetchRelSchema: GenMessage<FetchRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 5);

/**
 * The relational operator representing a GROUP BY Aggregate
 *
 * @generated from message substrait.AggregateRel
 */
export type AggregateRel = Message<"substrait.AggregateRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * Input of the aggregation
   *
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * A list of one or more grouping expression sets that the aggregation measures should be calculated for.
   * Required if there are no measures.
   *
   * @generated from field: repeated substrait.AggregateRel.Grouping groupings = 3;
   */
  groupings: AggregateRel_Grouping[];

  /**
   * A list of one or more aggregate expressions along with an optional filter.
   * Required if there are no groupings.
   *
   * @generated from field: repeated substrait.AggregateRel.Measure measures = 4;
   */
  measures: AggregateRel_Measure[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.AggregateRel.
 * Use `create(AggregateRelSchema)` to create a new message.
 */
export const AggregateRelSchema: GenMessage<AggregateRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 6);

/**
 * @generated from message substrait.AggregateRel.Grouping
 */
export type AggregateRel_Grouping = Message<"substrait.AggregateRel.Grouping"> & {
  /**
   * @generated from field: repeated substrait.Expression grouping_expressions = 1;
   */
  groupingExpressions: Expression[];
};

/**
 * Describes the message substrait.AggregateRel.Grouping.
 * Use `create(AggregateRel_GroupingSchema)` to create a new message.
 */
export const AggregateRel_GroupingSchema: GenMessage<AggregateRel_Grouping> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 6, 0);

/**
 * @generated from message substrait.AggregateRel.Measure
 */
export type AggregateRel_Measure = Message<"substrait.AggregateRel.Measure"> & {
  /**
   * @generated from field: substrait.AggregateFunction measure = 1;
   */
  measure?: AggregateFunction;

  /**
   * An optional boolean expression that acts to filter which records are
   * included in the measure. True means include this record for calculation
   * within the measure.
   * Helps to support SUM(<c>) FILTER(WHERE...) syntax without masking opportunities for optimization
   *
   * @generated from field: substrait.Expression filter = 2;
   */
  filter?: Expression;
};

/**
 * Describes the message substrait.AggregateRel.Measure.
 * Use `create(AggregateRel_MeasureSchema)` to create a new message.
 */
export const AggregateRel_MeasureSchema: GenMessage<AggregateRel_Measure> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 6, 1);

/**
 * ConsistentPartitionWindowRel provides the ability to perform calculations across sets of rows
 * that are related to the current query row. It can be used to execute window functions where
 * all the windows share the same partitioning and ordering.
 *
 * @generated from message substrait.ConsistentPartitionWindowRel
 */
export type ConsistentPartitionWindowRel = Message<"substrait.ConsistentPartitionWindowRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: repeated substrait.ConsistentPartitionWindowRel.WindowRelFunction window_functions = 3;
   */
  windowFunctions: ConsistentPartitionWindowRel_WindowRelFunction[];

  /**
   * @generated from field: repeated substrait.Expression partition_expressions = 4;
   */
  partitionExpressions: Expression[];

  /**
   * @generated from field: repeated substrait.SortField sorts = 5;
   */
  sorts: SortField[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.ConsistentPartitionWindowRel.
 * Use `create(ConsistentPartitionWindowRelSchema)` to create a new message.
 */
export const ConsistentPartitionWindowRelSchema: GenMessage<ConsistentPartitionWindowRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 7);

/**
 * This message mirrors the `WindowFunction` message but removes the fields defining the partition,
 * sorts, and bounds, since those must be consistent across the various functions in this rel.  Refer
 * to the `WindowFunction` message for a description of these fields.
 *
 * @generated from message substrait.ConsistentPartitionWindowRel.WindowRelFunction
 */
export type ConsistentPartitionWindowRel_WindowRelFunction = Message<"substrait.ConsistentPartitionWindowRel.WindowRelFunction"> & {
  /**
   * @generated from field: uint32 function_reference = 1;
   */
  functionReference: number;

  /**
   * @generated from field: repeated substrait.FunctionArgument arguments = 9;
   */
  arguments: FunctionArgument[];

  /**
   * @generated from field: repeated substrait.FunctionOption options = 11;
   */
  options: FunctionOption[];

  /**
   * @generated from field: substrait.Type output_type = 7;
   */
  outputType?: Type;

  /**
   * @generated from field: substrait.AggregationPhase phase = 6;
   */
  phase: AggregationPhase;

  /**
   * @generated from field: substrait.AggregateFunction.AggregationInvocation invocation = 10;
   */
  invocation: AggregateFunction_AggregationInvocation;

  /**
   * @generated from field: substrait.Expression.WindowFunction.Bound lower_bound = 5;
   */
  lowerBound?: Expression_WindowFunction_Bound;

  /**
   * @generated from field: substrait.Expression.WindowFunction.Bound upper_bound = 4;
   */
  upperBound?: Expression_WindowFunction_Bound;

  /**
   * @generated from field: substrait.Expression.WindowFunction.BoundsType bounds_type = 12;
   */
  boundsType: Expression_WindowFunction_BoundsType;
};

/**
 * Describes the message substrait.ConsistentPartitionWindowRel.WindowRelFunction.
 * Use `create(ConsistentPartitionWindowRel_WindowRelFunctionSchema)` to create a new message.
 */
export const ConsistentPartitionWindowRel_WindowRelFunctionSchema: GenMessage<ConsistentPartitionWindowRel_WindowRelFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 7, 0);

/**
 * The ORDERY BY (or sorting) relational operator. Beside describing a base relation, it includes a list of fields to sort on
 *
 * @generated from message substrait.SortRel
 */
export type SortRel = Message<"substrait.SortRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: repeated substrait.SortField sorts = 3;
   */
  sorts: SortField[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.SortRel.
 * Use `create(SortRelSchema)` to create a new message.
 */
export const SortRelSchema: GenMessage<SortRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 8);

/**
 * The relational operator capturing simple FILTERs (as in the WHERE clause of SQL)
 *
 * @generated from message substrait.FilterRel
 */
export type FilterRel = Message<"substrait.FilterRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: substrait.Expression condition = 3;
   */
  condition?: Expression;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.FilterRel.
 * Use `create(FilterRelSchema)` to create a new message.
 */
export const FilterRelSchema: GenMessage<FilterRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 9);

/**
 * The relational set operators (intersection/union/etc..)
 *
 * @generated from message substrait.SetRel
 */
export type SetRel = Message<"substrait.SetRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * The first input is the primary input, the remaining are secondary
   * inputs.  There must be at least two inputs.
   *
   * @generated from field: repeated substrait.Rel inputs = 2;
   */
  inputs: Rel[];

  /**
   * @generated from field: substrait.SetRel.SetOp op = 3;
   */
  op: SetRel_SetOp;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.SetRel.
 * Use `create(SetRelSchema)` to create a new message.
 */
export const SetRelSchema: GenMessage<SetRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 10);

/**
 * @generated from enum substrait.SetRel.SetOp
 */
export enum SetRel_SetOp {
  /**
   * @generated from enum value: SET_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SET_OP_MINUS_PRIMARY = 1;
   */
  MINUS_PRIMARY = 1,

  /**
   * @generated from enum value: SET_OP_MINUS_MULTISET = 2;
   */
  MINUS_MULTISET = 2,

  /**
   * @generated from enum value: SET_OP_INTERSECTION_PRIMARY = 3;
   */
  INTERSECTION_PRIMARY = 3,

  /**
   * @generated from enum value: SET_OP_INTERSECTION_MULTISET = 4;
   */
  INTERSECTION_MULTISET = 4,

  /**
   * @generated from enum value: SET_OP_UNION_DISTINCT = 5;
   */
  UNION_DISTINCT = 5,

  /**
   * @generated from enum value: SET_OP_UNION_ALL = 6;
   */
  UNION_ALL = 6,
}

/**
 * Describes the enum substrait.SetRel.SetOp.
 */
export const SetRel_SetOpSchema: GenEnum<SetRel_SetOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 10, 0);

/**
 * Stub to support extension with a single input
 *
 * @generated from message substrait.ExtensionSingleRel
 */
export type ExtensionSingleRel = Message<"substrait.ExtensionSingleRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: google.protobuf.Any detail = 3;
   */
  detail?: Any;
};

/**
 * Describes the message substrait.ExtensionSingleRel.
 * Use `create(ExtensionSingleRelSchema)` to create a new message.
 */
export const ExtensionSingleRelSchema: GenMessage<ExtensionSingleRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 11);

/**
 * Stub to support extension with a zero inputs
 *
 * @generated from message substrait.ExtensionLeafRel
 */
export type ExtensionLeafRel = Message<"substrait.ExtensionLeafRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: google.protobuf.Any detail = 2;
   */
  detail?: Any;
};

/**
 * Describes the message substrait.ExtensionLeafRel.
 * Use `create(ExtensionLeafRelSchema)` to create a new message.
 */
export const ExtensionLeafRelSchema: GenMessage<ExtensionLeafRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 12);

/**
 * Stub to support extension with multiple inputs
 *
 * @generated from message substrait.ExtensionMultiRel
 */
export type ExtensionMultiRel = Message<"substrait.ExtensionMultiRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: repeated substrait.Rel inputs = 2;
   */
  inputs: Rel[];

  /**
   * @generated from field: google.protobuf.Any detail = 3;
   */
  detail?: Any;
};

/**
 * Describes the message substrait.ExtensionMultiRel.
 * Use `create(ExtensionMultiRelSchema)` to create a new message.
 */
export const ExtensionMultiRelSchema: GenMessage<ExtensionMultiRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 13);

/**
 * A redistribution operation
 *
 * @generated from message substrait.ExchangeRel
 */
export type ExchangeRel = Message<"substrait.ExchangeRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: int32 partition_count = 3;
   */
  partitionCount: number;

  /**
   * @generated from field: repeated substrait.ExchangeRel.ExchangeTarget targets = 4;
   */
  targets: ExchangeRel_ExchangeTarget[];

  /**
   * the type of exchange used
   *
   * @generated from oneof substrait.ExchangeRel.exchange_kind
   */
  exchangeKind: {
    /**
     * @generated from field: substrait.ExchangeRel.ScatterFields scatter_by_fields = 5;
     */
    value: ExchangeRel_ScatterFields;
    case: "scatterByFields";
  } | {
    /**
     * @generated from field: substrait.ExchangeRel.SingleBucketExpression single_target = 6;
     */
    value: ExchangeRel_SingleBucketExpression;
    case: "singleTarget";
  } | {
    /**
     * @generated from field: substrait.ExchangeRel.MultiBucketExpression multi_target = 7;
     */
    value: ExchangeRel_MultiBucketExpression;
    case: "multiTarget";
  } | {
    /**
     * @generated from field: substrait.ExchangeRel.RoundRobin round_robin = 8;
     */
    value: ExchangeRel_RoundRobin;
    case: "roundRobin";
  } | {
    /**
     * @generated from field: substrait.ExchangeRel.Broadcast broadcast = 9;
     */
    value: ExchangeRel_Broadcast;
    case: "broadcast";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.ExchangeRel.
 * Use `create(ExchangeRelSchema)` to create a new message.
 */
export const ExchangeRelSchema: GenMessage<ExchangeRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14);

/**
 * @generated from message substrait.ExchangeRel.ScatterFields
 */
export type ExchangeRel_ScatterFields = Message<"substrait.ExchangeRel.ScatterFields"> & {
  /**
   * @generated from field: repeated substrait.Expression.FieldReference fields = 1;
   */
  fields: Expression_FieldReference[];
};

/**
 * Describes the message substrait.ExchangeRel.ScatterFields.
 * Use `create(ExchangeRel_ScatterFieldsSchema)` to create a new message.
 */
export const ExchangeRel_ScatterFieldsSchema: GenMessage<ExchangeRel_ScatterFields> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 0);

/**
 * Returns a single bucket number per record.
 *
 * @generated from message substrait.ExchangeRel.SingleBucketExpression
 */
export type ExchangeRel_SingleBucketExpression = Message<"substrait.ExchangeRel.SingleBucketExpression"> & {
  /**
   * @generated from field: substrait.Expression expression = 1;
   */
  expression?: Expression;
};

/**
 * Describes the message substrait.ExchangeRel.SingleBucketExpression.
 * Use `create(ExchangeRel_SingleBucketExpressionSchema)` to create a new message.
 */
export const ExchangeRel_SingleBucketExpressionSchema: GenMessage<ExchangeRel_SingleBucketExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 1);

/**
 * Returns zero or more bucket numbers per record
 *
 * @generated from message substrait.ExchangeRel.MultiBucketExpression
 */
export type ExchangeRel_MultiBucketExpression = Message<"substrait.ExchangeRel.MultiBucketExpression"> & {
  /**
   * @generated from field: substrait.Expression expression = 1;
   */
  expression?: Expression;

  /**
   * @generated from field: bool constrained_to_count = 2;
   */
  constrainedToCount: boolean;
};

/**
 * Describes the message substrait.ExchangeRel.MultiBucketExpression.
 * Use `create(ExchangeRel_MultiBucketExpressionSchema)` to create a new message.
 */
export const ExchangeRel_MultiBucketExpressionSchema: GenMessage<ExchangeRel_MultiBucketExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 2);

/**
 * Send all data to every target.
 *
 * @generated from message substrait.ExchangeRel.Broadcast
 */
export type ExchangeRel_Broadcast = Message<"substrait.ExchangeRel.Broadcast"> & {
};

/**
 * Describes the message substrait.ExchangeRel.Broadcast.
 * Use `create(ExchangeRel_BroadcastSchema)` to create a new message.
 */
export const ExchangeRel_BroadcastSchema: GenMessage<ExchangeRel_Broadcast> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 3);

/**
 * Route approximately
 *
 * @generated from message substrait.ExchangeRel.RoundRobin
 */
export type ExchangeRel_RoundRobin = Message<"substrait.ExchangeRel.RoundRobin"> & {
  /**
   * whether the round robin behavior is required to exact (per record) or
   * approximate. Defaults to approximate.
   *
   * @generated from field: bool exact = 1;
   */
  exact: boolean;
};

/**
 * Describes the message substrait.ExchangeRel.RoundRobin.
 * Use `create(ExchangeRel_RoundRobinSchema)` to create a new message.
 */
export const ExchangeRel_RoundRobinSchema: GenMessage<ExchangeRel_RoundRobin> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 4);

/**
 * The message to describe partition targets of an exchange
 *
 * @generated from message substrait.ExchangeRel.ExchangeTarget
 */
export type ExchangeRel_ExchangeTarget = Message<"substrait.ExchangeRel.ExchangeTarget"> & {
  /**
   * Describes the partition id(s) to send. If this is empty, all data is sent
   * to this target.
   *
   * @generated from field: repeated int32 partition_id = 1;
   */
  partitionId: number[];

  /**
   * @generated from oneof substrait.ExchangeRel.ExchangeTarget.target_type
   */
  targetType: {
    /**
     * @generated from field: string uri = 2;
     */
    value: string;
    case: "uri";
  } | {
    /**
     * @generated from field: google.protobuf.Any extended = 3;
     */
    value: Any;
    case: "extended";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ExchangeRel.ExchangeTarget.
 * Use `create(ExchangeRel_ExchangeTargetSchema)` to create a new message.
 */
export const ExchangeRel_ExchangeTargetSchema: GenMessage<ExchangeRel_ExchangeTarget> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 5);

/**
 * Duplicates records by emitting one or more rows per input row.  The number of rows emitted per
 * input row is the same for all input rows.
 *
 * In addition to a field being emitted per input field an extra int64 field is emitted which
 * contains a zero-indexed ordinal corresponding to the duplicate definition.
 *
 * @generated from message substrait.ExpandRel
 */
export type ExpandRel = Message<"substrait.ExpandRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * There should be one definition here for each input field.  Any fields beyond the provided
   * definitions will be emitted as is (as if a consistent_field record with an identity
   * expression was provided).
   *
   * @generated from field: repeated substrait.ExpandRel.ExpandField fields = 4;
   */
  fields: ExpandRel_ExpandField[];
};

/**
 * Describes the message substrait.ExpandRel.
 * Use `create(ExpandRelSchema)` to create a new message.
 */
export const ExpandRelSchema: GenMessage<ExpandRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 15);

/**
 * @generated from message substrait.ExpandRel.ExpandField
 */
export type ExpandRel_ExpandField = Message<"substrait.ExpandRel.ExpandField"> & {
  /**
   * @generated from oneof substrait.ExpandRel.ExpandField.field_type
   */
  fieldType: {
    /**
     * Field that switches output based on which duplicate is being output.  Every
     * switching_field should contain the same number of duplicates (so that the output rows
     * are of consistent size and type).  If there are not enough switching field definitions
     * to match the other field definitions NULL will be returned to fill the extras.
     *
     * @generated from field: substrait.ExpandRel.SwitchingField switching_field = 2;
     */
    value: ExpandRel_SwitchingField;
    case: "switchingField";
  } | {
    /**
     * Field that outputs the same value no matter which duplicate is being output.  Equivalent
     * to a switching_field that lists the same expression multiple times.
     *
     * @generated from field: substrait.Expression consistent_field = 3;
     */
    value: Expression;
    case: "consistentField";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ExpandRel.ExpandField.
 * Use `create(ExpandRel_ExpandFieldSchema)` to create a new message.
 */
export const ExpandRel_ExpandFieldSchema: GenMessage<ExpandRel_ExpandField> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 15, 0);

/**
 * @generated from message substrait.ExpandRel.SwitchingField
 */
export type ExpandRel_SwitchingField = Message<"substrait.ExpandRel.SwitchingField"> & {
  /**
   * All duplicates must return the same type class but may differ in nullability.  The effective
   * type of the output field will be nullable if any of the duplicate expressions are nullable.
   *
   * @generated from field: repeated substrait.Expression duplicates = 1;
   */
  duplicates: Expression[];
};

/**
 * Describes the message substrait.ExpandRel.SwitchingField.
 * Use `create(ExpandRel_SwitchingFieldSchema)` to create a new message.
 */
export const ExpandRel_SwitchingFieldSchema: GenMessage<ExpandRel_SwitchingField> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 15, 1);

/**
 * A relation with output field names.
 *
 * This is for use at the root of a `Rel` tree.
 *
 * @generated from message substrait.RelRoot
 */
export type RelRoot = Message<"substrait.RelRoot"> & {
  /**
   * A relation
   *
   * @generated from field: substrait.Rel input = 1;
   */
  input?: Rel;

  /**
   * Field names in depth-first order
   *
   * @generated from field: repeated string names = 2;
   */
  names: string[];
};

/**
 * Describes the message substrait.RelRoot.
 * Use `create(RelRootSchema)` to create a new message.
 */
export const RelRootSchema: GenMessage<RelRoot> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 16);

/**
 * A relation (used internally in a plan)
 *
 * @generated from message substrait.Rel
 */
export type Rel = Message<"substrait.Rel"> & {
  /**
   * @generated from oneof substrait.Rel.rel_type
   */
  relType: {
    /**
     * @generated from field: substrait.ReadRel read = 1;
     */
    value: ReadRel;
    case: "read";
  } | {
    /**
     * @generated from field: substrait.FilterRel filter = 2;
     */
    value: FilterRel;
    case: "filter";
  } | {
    /**
     * @generated from field: substrait.FetchRel fetch = 3;
     */
    value: FetchRel;
    case: "fetch";
  } | {
    /**
     * @generated from field: substrait.AggregateRel aggregate = 4;
     */
    value: AggregateRel;
    case: "aggregate";
  } | {
    /**
     * @generated from field: substrait.SortRel sort = 5;
     */
    value: SortRel;
    case: "sort";
  } | {
    /**
     * @generated from field: substrait.JoinRel join = 6;
     */
    value: JoinRel;
    case: "join";
  } | {
    /**
     * @generated from field: substrait.ProjectRel project = 7;
     */
    value: ProjectRel;
    case: "project";
  } | {
    /**
     * @generated from field: substrait.SetRel set = 8;
     */
    value: SetRel;
    case: "set";
  } | {
    /**
     * @generated from field: substrait.ExtensionSingleRel extension_single = 9;
     */
    value: ExtensionSingleRel;
    case: "extensionSingle";
  } | {
    /**
     * @generated from field: substrait.ExtensionMultiRel extension_multi = 10;
     */
    value: ExtensionMultiRel;
    case: "extensionMulti";
  } | {
    /**
     * @generated from field: substrait.ExtensionLeafRel extension_leaf = 11;
     */
    value: ExtensionLeafRel;
    case: "extensionLeaf";
  } | {
    /**
     * @generated from field: substrait.CrossRel cross = 12;
     */
    value: CrossRel;
    case: "cross";
  } | {
    /**
     * @generated from field: substrait.ReferenceRel reference = 21;
     */
    value: ReferenceRel;
    case: "reference";
  } | {
    /**
     * @generated from field: substrait.WriteRel write = 19;
     */
    value: WriteRel;
    case: "write";
  } | {
    /**
     * @generated from field: substrait.DdlRel ddl = 20;
     */
    value: DdlRel;
    case: "ddl";
  } | {
    /**
     * Physical relations
     *
     * @generated from field: substrait.HashJoinRel hash_join = 13;
     */
    value: HashJoinRel;
    case: "hashJoin";
  } | {
    /**
     * @generated from field: substrait.MergeJoinRel merge_join = 14;
     */
    value: MergeJoinRel;
    case: "mergeJoin";
  } | {
    /**
     * @generated from field: substrait.NestedLoopJoinRel nested_loop_join = 18;
     */
    value: NestedLoopJoinRel;
    case: "nestedLoopJoin";
  } | {
    /**
     * @generated from field: substrait.ConsistentPartitionWindowRel window = 17;
     */
    value: ConsistentPartitionWindowRel;
    case: "window";
  } | {
    /**
     * @generated from field: substrait.ExchangeRel exchange = 15;
     */
    value: ExchangeRel;
    case: "exchange";
  } | {
    /**
     * @generated from field: substrait.ExpandRel expand = 16;
     */
    value: ExpandRel;
    case: "expand";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Rel.
 * Use `create(RelSchema)` to create a new message.
 */
export const RelSchema: GenMessage<Rel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 17);

/**
 * A base object for writing (e.g., a table or a view).
 *
 * @generated from message substrait.NamedObjectWrite
 */
export type NamedObjectWrite = Message<"substrait.NamedObjectWrite"> & {
  /**
   * The list of string is used to represent namespacing (e.g., mydb.mytable).
   * This assumes shared catalog between systems exchanging a message.
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.NamedObjectWrite.
 * Use `create(NamedObjectWriteSchema)` to create a new message.
 */
export const NamedObjectWriteSchema: GenMessage<NamedObjectWrite> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 18);

/**
 * A stub type that can be used to extend/introduce new table types outside
 * the specification.
 *
 * @generated from message substrait.ExtensionObject
 */
export type ExtensionObject = Message<"substrait.ExtensionObject"> & {
  /**
   * @generated from field: google.protobuf.Any detail = 1;
   */
  detail?: Any;
};

/**
 * Describes the message substrait.ExtensionObject.
 * Use `create(ExtensionObjectSchema)` to create a new message.
 */
export const ExtensionObjectSchema: GenMessage<ExtensionObject> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 19);

/**
 * @generated from message substrait.DdlRel
 */
export type DdlRel = Message<"substrait.DdlRel"> & {
  /**
   * Definition of which type of object we are operating on
   *
   * @generated from oneof substrait.DdlRel.write_type
   */
  writeType: {
    /**
     * @generated from field: substrait.NamedObjectWrite named_object = 1;
     */
    value: NamedObjectWrite;
    case: "namedObject";
  } | {
    /**
     * @generated from field: substrait.ExtensionObject extension_object = 2;
     */
    value: ExtensionObject;
    case: "extensionObject";
  } | { case: undefined; value?: undefined };

  /**
   * The columns that will be modified (representing after-image of a schema change)
   *
   * @generated from field: substrait.NamedStruct table_schema = 3;
   */
  tableSchema?: NamedStruct;

  /**
   * The default values for the columns (representing after-image of a schema change)
   * E.g., in case of an ALTER TABLE that changes some of the column default values, we expect
   * the table_defaults Struct to report a full list of default values reflecting the result of applying
   * the ALTER TABLE operator successfully
   *
   * @generated from field: substrait.Expression.Literal.Struct table_defaults = 4;
   */
  tableDefaults?: Expression_Literal_Struct;

  /**
   * Which type of object we operate on
   *
   * @generated from field: substrait.DdlRel.DdlObject object = 5;
   */
  object: DdlRel_DdlObject;

  /**
   * The type of operation to perform
   *
   * @generated from field: substrait.DdlRel.DdlOp op = 6;
   */
  op: DdlRel_DdlOp;

  /**
   * The body of the CREATE VIEW
   *
   * @generated from field: substrait.Rel view_definition = 7;
   */
  viewDefinition?: Rel;

  /**
   * @generated from field: substrait.RelCommon common = 8;
   */
  common?: RelCommon;
};

/**
 * Describes the message substrait.DdlRel.
 * Use `create(DdlRelSchema)` to create a new message.
 */
export const DdlRelSchema: GenMessage<DdlRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 20);

/**
 * @generated from enum substrait.DdlRel.DdlObject
 */
export enum DdlRel_DdlObject {
  /**
   * @generated from enum value: DDL_OBJECT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * A Table object in the system
   *
   * @generated from enum value: DDL_OBJECT_TABLE = 1;
   */
  TABLE = 1,

  /**
   * A View object in the system
   *
   * @generated from enum value: DDL_OBJECT_VIEW = 2;
   */
  VIEW = 2,
}

/**
 * Describes the enum substrait.DdlRel.DdlObject.
 */
export const DdlRel_DdlObjectSchema: GenEnum<DdlRel_DdlObject> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 20, 0);

/**
 * @generated from enum substrait.DdlRel.DdlOp
 */
export enum DdlRel_DdlOp {
  /**
   * @generated from enum value: DDL_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * A create operation (for any object)
   *
   * @generated from enum value: DDL_OP_CREATE = 1;
   */
  CREATE = 1,

  /**
   * A create operation if the object does not exist, or replaces it (equivalent to a DROP + CREATE) if the object already exists
   *
   * @generated from enum value: DDL_OP_CREATE_OR_REPLACE = 2;
   */
  CREATE_OR_REPLACE = 2,

  /**
   * An operation that modifies the schema (e.g., column names, types, default values) for the target object
   *
   * @generated from enum value: DDL_OP_ALTER = 3;
   */
  ALTER = 3,

  /**
   * An operation that removes an object from the system
   *
   * @generated from enum value: DDL_OP_DROP = 4;
   */
  DROP = 4,

  /**
   * An operation that removes an object from the system (without throwing an exception if the object did not exist)
   *
   * @generated from enum value: DDL_OP_DROP_IF_EXIST = 5;
   */
  DROP_IF_EXIST = 5,
}

/**
 * Describes the enum substrait.DdlRel.DdlOp.
 */
export const DdlRel_DdlOpSchema: GenEnum<DdlRel_DdlOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 20, 1);

/**
 * The operator that modifies the content of a database (operates on 1 table at a time, but record-selection/source can be
 * based on joining of multiple tables).
 *
 * @generated from message substrait.WriteRel
 */
export type WriteRel = Message<"substrait.WriteRel"> & {
  /**
   * Definition of which TABLE we are operating on
   *
   * @generated from oneof substrait.WriteRel.write_type
   */
  writeType: {
    /**
     * @generated from field: substrait.NamedObjectWrite named_table = 1;
     */
    value: NamedObjectWrite;
    case: "namedTable";
  } | {
    /**
     * @generated from field: substrait.ExtensionObject extension_table = 2;
     */
    value: ExtensionObject;
    case: "extensionTable";
  } | { case: undefined; value?: undefined };

  /**
   * The schema of the table (must align with Rel input (e.g., number of leaf fields must match))
   *
   * @generated from field: substrait.NamedStruct table_schema = 3;
   */
  tableSchema?: NamedStruct;

  /**
   * The type of operation to perform
   *
   * @generated from field: substrait.WriteRel.WriteOp op = 4;
   */
  op: WriteRel_WriteOp;

  /**
   * The relation that determines the records to add/remove/modify
   * the schema must match with table_schema. Default values must be explicitly stated
   * in a ProjectRel at the top of the input. The match must also
   * occur in case of DELETE to ensure multi-engine plans are unequivocal.
   *
   * @generated from field: substrait.Rel input = 5;
   */
  input?: Rel;

  /**
   * Output mode determines what is the output of executing this rel
   *
   * @generated from field: substrait.WriteRel.OutputMode output = 6;
   */
  output: WriteRel_OutputMode;

  /**
   * @generated from field: substrait.RelCommon common = 7;
   */
  common?: RelCommon;
};

/**
 * Describes the message substrait.WriteRel.
 * Use `create(WriteRelSchema)` to create a new message.
 */
export const WriteRelSchema: GenMessage<WriteRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 21);

/**
 * @generated from enum substrait.WriteRel.WriteOp
 */
export enum WriteRel_WriteOp {
  /**
   * @generated from enum value: WRITE_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The insert of new records in a table
   *
   * @generated from enum value: WRITE_OP_INSERT = 1;
   */
  INSERT = 1,

  /**
   * The removal of records from a table
   *
   * @generated from enum value: WRITE_OP_DELETE = 2;
   */
  DELETE = 2,

  /**
   * The modification of existing records within a table
   *
   * @generated from enum value: WRITE_OP_UPDATE = 3;
   */
  UPDATE = 3,

  /**
   * The Creation of a new table, and the insert of new records in the table
   *
   * @generated from enum value: WRITE_OP_CTAS = 4;
   */
  CTAS = 4,
}

/**
 * Describes the enum substrait.WriteRel.WriteOp.
 */
export const WriteRel_WriteOpSchema: GenEnum<WriteRel_WriteOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 21, 0);

/**
 * @generated from enum substrait.WriteRel.OutputMode
 */
export enum WriteRel_OutputMode {
  /**
   * @generated from enum value: OUTPUT_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * return no records at all
   *
   * @generated from enum value: OUTPUT_MODE_NO_OUTPUT = 1;
   */
  NO_OUTPUT = 1,

  /**
   * this mode makes the operator return all the record INSERTED/DELETED/UPDATED by the operator.
   * The operator returns the AFTER-image of any change. This can be further manipulated by operators upstreams
   * (e.g., retunring the typical "count of modified records").
   * For scenarios in which the BEFORE image is required, the user must implement a spool (via references to
   * subplans in the body of the Rel input) and return those with anounter PlanRel.relations.
   *
   * @generated from enum value: OUTPUT_MODE_MODIFIED_RECORDS = 2;
   */
  MODIFIED_RECORDS = 2,
}

/**
 * Describes the enum substrait.WriteRel.OutputMode.
 */
export const WriteRel_OutputModeSchema: GenEnum<WriteRel_OutputMode> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 21, 1);

/**
 * Hash joins and merge joins are a specialization of the general join where the join
 * expression is an series of comparisons between fields that are ANDed together.  The
 * behavior of this comparison is flexible
 *
 * @generated from message substrait.ComparisonJoinKey
 */
export type ComparisonJoinKey = Message<"substrait.ComparisonJoinKey"> & {
  /**
   * The key to compare from the left table
   *
   * @generated from field: substrait.Expression.FieldReference left = 1;
   */
  left?: Expression_FieldReference;

  /**
   * The key to compare from the right table
   *
   * @generated from field: substrait.Expression.FieldReference right = 2;
   */
  right?: Expression_FieldReference;

  /**
   * Describes how to compare the two keys
   *
   * @generated from field: substrait.ComparisonJoinKey.ComparisonType comparison = 3;
   */
  comparison?: ComparisonJoinKey_ComparisonType;
};

/**
 * Describes the message substrait.ComparisonJoinKey.
 * Use `create(ComparisonJoinKeySchema)` to create a new message.
 */
export const ComparisonJoinKeySchema: GenMessage<ComparisonJoinKey> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 22);

/**
 * Describes how the relation should consider if two rows are a match
 *
 * @generated from message substrait.ComparisonJoinKey.ComparisonType
 */
export type ComparisonJoinKey_ComparisonType = Message<"substrait.ComparisonJoinKey.ComparisonType"> & {
  /**
   * @generated from oneof substrait.ComparisonJoinKey.ComparisonType.inner_type
   */
  innerType: {
    /**
     * One of the simple comparison behaviors is used
     *
     * @generated from field: substrait.ComparisonJoinKey.SimpleComparisonType simple = 1;
     */
    value: ComparisonJoinKey_SimpleComparisonType;
    case: "simple";
  } | {
    /**
     * A custom comparison behavior is used.  This can happen, for example, when using
     * collations, where we might want to do something like a case-insensitive comparison.
     *
     * This must be a binary function with a boolean return type
     *
     * @generated from field: uint32 custom_function_reference = 2;
     */
    value: number;
    case: "customFunctionReference";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ComparisonJoinKey.ComparisonType.
 * Use `create(ComparisonJoinKey_ComparisonTypeSchema)` to create a new message.
 */
export const ComparisonJoinKey_ComparisonTypeSchema: GenMessage<ComparisonJoinKey_ComparisonType> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 22, 0);

/**
 * Most joins will use one of the following behaviors.  To avoid the complexity
 * of a function lookup we define the common behaviors here
 *
 * @generated from enum substrait.ComparisonJoinKey.SimpleComparisonType
 */
export enum ComparisonJoinKey_SimpleComparisonType {
  /**
   * @generated from enum value: SIMPLE_COMPARISON_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Returns true only if both values are equal and not null
   *
   * @generated from enum value: SIMPLE_COMPARISON_TYPE_EQ = 1;
   */
  EQ = 1,

  /**
   * Returns true if both values are equal and not null
   * Returns true if both values are null
   * Returns false if one value is null and the other value is not null
   *
   * This can be expressed as a = b OR (isnull(a) AND isnull(b))
   *
   * @generated from enum value: SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM = 2;
   */
  IS_NOT_DISTINCT_FROM = 2,

  /**
   * Returns true if both values are equal and not null
   * Returns true if either value is null
   *
   * This can be expressed as a = b OR isnull(a = b)
   *
   * @generated from enum value: SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL = 3;
   */
  MIGHT_EQUAL = 3,
}

/**
 * Describes the enum substrait.ComparisonJoinKey.SimpleComparisonType.
 */
export const ComparisonJoinKey_SimpleComparisonTypeSchema: GenEnum<ComparisonJoinKey_SimpleComparisonType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 22, 0);

/**
 * The hash equijoin join operator will build a hash table out of the right input based on a set of join keys.
 * It will then probe that hash table for incoming inputs, finding matches.
 *
 * Two rows are a match if the comparison function returns true for all keys
 *
 * @generated from message substrait.HashJoinRel
 */
export type HashJoinRel = Message<"substrait.HashJoinRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel left = 2;
   */
  left?: Rel;

  /**
   * @generated from field: substrait.Rel right = 3;
   */
  right?: Rel;

  /**
   * These fields are deprecated in favor of `keys`.  If they are set then
   * the two lists (left_keys and right_keys) must have the same length and
   * the comparion function is considered to be SimpleEqualityType::EQ
   *
   * @generated from field: repeated substrait.Expression.FieldReference left_keys = 4 [deprecated = true];
   * @deprecated
   */
  leftKeys: Expression_FieldReference[];

  /**
   * @generated from field: repeated substrait.Expression.FieldReference right_keys = 5 [deprecated = true];
   * @deprecated
   */
  rightKeys: Expression_FieldReference[];

  /**
   * One or more keys to join on.  The relation is invalid if this is empty
   * (unless the deprecated left_keys/right_keys fields are being used).
   *
   * If a custom comparison function is used then it must be consistent with
   * the hash function used for the keys.
   *
   * In other words, the hash function must return the same hash code when the
   * comparison returns true.  For example, if the comparison function is
   * "equals ignoring case" then the hash function must return the same hash
   * code for strings that differ only by case.  Note: the hash function is not
   * specified here.  It is the responsibility of the consumer to find an appropriate
   * hash function for a given comparsion function or to reject the plan if it cannot
   * do so.
   *
   * @generated from field: repeated substrait.ComparisonJoinKey keys = 8;
   */
  keys: ComparisonJoinKey[];

  /**
   * @generated from field: substrait.Expression post_join_filter = 6;
   */
  postJoinFilter?: Expression;

  /**
   * @generated from field: substrait.HashJoinRel.JoinType type = 7;
   */
  type: HashJoinRel_JoinType;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.HashJoinRel.
 * Use `create(HashJoinRelSchema)` to create a new message.
 */
export const HashJoinRelSchema: GenMessage<HashJoinRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 23);

/**
 * @generated from enum substrait.HashJoinRel.JoinType
 */
export enum HashJoinRel_JoinType {
  /**
   * @generated from enum value: JOIN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: JOIN_TYPE_INNER = 1;
   */
  INNER = 1,

  /**
   * @generated from enum value: JOIN_TYPE_OUTER = 2;
   */
  OUTER = 2,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT = 3;
   */
  LEFT = 3,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT = 4;
   */
  RIGHT = 4,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SEMI = 5;
   */
  LEFT_SEMI = 5,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SEMI = 6;
   */
  RIGHT_SEMI = 6,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_ANTI = 7;
   */
  LEFT_ANTI = 7,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_ANTI = 8;
   */
  RIGHT_ANTI = 8,
}

/**
 * Describes the enum substrait.HashJoinRel.JoinType.
 */
export const HashJoinRel_JoinTypeSchema: GenEnum<HashJoinRel_JoinType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 23, 0);

/**
 * The merge equijoin does a join by taking advantage of two sets that are sorted on the join keys.
 * This allows the join operation to be done in a streaming fashion.
 *
 * @generated from message substrait.MergeJoinRel
 */
export type MergeJoinRel = Message<"substrait.MergeJoinRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel left = 2;
   */
  left?: Rel;

  /**
   * @generated from field: substrait.Rel right = 3;
   */
  right?: Rel;

  /**
   * These fields are deprecated in favor of `keys`.  If they are set then
   * the two lists (left_keys and right_keys) must have the same length and
   * the comparion function is considered to be SimpleEqualityType::EQ
   *
   * @generated from field: repeated substrait.Expression.FieldReference left_keys = 4 [deprecated = true];
   * @deprecated
   */
  leftKeys: Expression_FieldReference[];

  /**
   * @generated from field: repeated substrait.Expression.FieldReference right_keys = 5 [deprecated = true];
   * @deprecated
   */
  rightKeys: Expression_FieldReference[];

  /**
   * One or more keys to join on.  The relation is invalid if this is empty
   * (unless the deprecated left_keys/right_keys fields are being used).
   *
   * If a custom comparison function is used then it must be consistent with
   * the ordering of the input data.  For example, if the comparison function
   * is "<" then we generally expect the data to be sorted in ascending order.
   *
   * If the comparison function is something like "less than ignoring case" then
   * the data should be sorted appropriately (e.g. both "A" and "a" should come
   * before "b")
   *
   * The sort order is not specified here.  It is typically the responsibility of
   * the producer to ensure the plan sorts the data if needed (although the consumer
   * is free to do so as well).  If possible, the consumer should verify the sort
   * order and reject invalid plans.
   *
   * @generated from field: repeated substrait.ComparisonJoinKey keys = 8;
   */
  keys: ComparisonJoinKey[];

  /**
   * @generated from field: substrait.Expression post_join_filter = 6;
   */
  postJoinFilter?: Expression;

  /**
   * @generated from field: substrait.MergeJoinRel.JoinType type = 7;
   */
  type: MergeJoinRel_JoinType;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.MergeJoinRel.
 * Use `create(MergeJoinRelSchema)` to create a new message.
 */
export const MergeJoinRelSchema: GenMessage<MergeJoinRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 24);

/**
 * @generated from enum substrait.MergeJoinRel.JoinType
 */
export enum MergeJoinRel_JoinType {
  /**
   * @generated from enum value: JOIN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: JOIN_TYPE_INNER = 1;
   */
  INNER = 1,

  /**
   * @generated from enum value: JOIN_TYPE_OUTER = 2;
   */
  OUTER = 2,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT = 3;
   */
  LEFT = 3,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT = 4;
   */
  RIGHT = 4,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SEMI = 5;
   */
  LEFT_SEMI = 5,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SEMI = 6;
   */
  RIGHT_SEMI = 6,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_ANTI = 7;
   */
  LEFT_ANTI = 7,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_ANTI = 8;
   */
  RIGHT_ANTI = 8,
}

/**
 * Describes the enum substrait.MergeJoinRel.JoinType.
 */
export const MergeJoinRel_JoinTypeSchema: GenEnum<MergeJoinRel_JoinType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 24, 0);

/**
 * The nested loop join (NLJ) operator will hold the entire right input and iterate over it using the
 * left input, evaluating the join expression on the Cartesian product of all rows.
 *
 * @generated from message substrait.NestedLoopJoinRel
 */
export type NestedLoopJoinRel = Message<"substrait.NestedLoopJoinRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel left = 2;
   */
  left?: Rel;

  /**
   * @generated from field: substrait.Rel right = 3;
   */
  right?: Rel;

  /**
   * optional, defaults to true (a cartesian join)
   *
   * @generated from field: substrait.Expression expression = 4;
   */
  expression?: Expression;

  /**
   * @generated from field: substrait.NestedLoopJoinRel.JoinType type = 5;
   */
  type: NestedLoopJoinRel_JoinType;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.NestedLoopJoinRel.
 * Use `create(NestedLoopJoinRelSchema)` to create a new message.
 */
export const NestedLoopJoinRelSchema: GenMessage<NestedLoopJoinRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 25);

/**
 * @generated from enum substrait.NestedLoopJoinRel.JoinType
 */
export enum NestedLoopJoinRel_JoinType {
  /**
   * @generated from enum value: JOIN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: JOIN_TYPE_INNER = 1;
   */
  INNER = 1,

  /**
   * @generated from enum value: JOIN_TYPE_OUTER = 2;
   */
  OUTER = 2,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT = 3;
   */
  LEFT = 3,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT = 4;
   */
  RIGHT = 4,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SEMI = 5;
   */
  LEFT_SEMI = 5,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SEMI = 6;
   */
  RIGHT_SEMI = 6,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_ANTI = 7;
   */
  LEFT_ANTI = 7,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_ANTI = 8;
   */
  RIGHT_ANTI = 8,
}

/**
 * Describes the enum substrait.NestedLoopJoinRel.JoinType.
 */
export const NestedLoopJoinRel_JoinTypeSchema: GenEnum<NestedLoopJoinRel_JoinType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 25, 0);

/**
 * The argument of a function
 *
 * @generated from message substrait.FunctionArgument
 */
export type FunctionArgument = Message<"substrait.FunctionArgument"> & {
  /**
   * @generated from oneof substrait.FunctionArgument.arg_type
   */
  argType: {
    /**
     * @generated from field: string enum = 1;
     */
    value: string;
    case: "enum";
  } | {
    /**
     * @generated from field: substrait.Type type = 2;
     */
    value: Type;
    case: "type";
  } | {
    /**
     * @generated from field: substrait.Expression value = 3;
     */
    value: Expression;
    case: "value";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.FunctionArgument.
 * Use `create(FunctionArgumentSchema)` to create a new message.
 */
export const FunctionArgumentSchema: GenMessage<FunctionArgument> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 26);

/**
 * An optional function argument.  Typically used for specifying behavior in
 * invalid or corner cases.
 *
 * @generated from message substrait.FunctionOption
 */
export type FunctionOption = Message<"substrait.FunctionOption"> & {
  /**
   * Name of the option to set. If the consumer does not recognize the
   * option, it must reject the plan. The name is matched case-insensitively
   * with option names defined for the function.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * List of behavior options allowed by the producer. At least one must be
   * specified; to leave an option unspecified, simply don't add an entry to
   * `options`. The consumer must use the first option from the list that it
   * supports. If the consumer supports none of the specified options, it
   * must reject the plan. The name is matched case-insensitively and must
   * match one of the option values defined for the option.
   *
   * @generated from field: repeated string preference = 2;
   */
  preference: string[];
};

/**
 * Describes the message substrait.FunctionOption.
 * Use `create(FunctionOptionSchema)` to create a new message.
 */
export const FunctionOptionSchema: GenMessage<FunctionOption> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 27);

/**
 * @generated from message substrait.Expression
 */
export type Expression = Message<"substrait.Expression"> & {
  /**
   * @generated from oneof substrait.Expression.rex_type
   */
  rexType: {
    /**
     * @generated from field: substrait.Expression.Literal literal = 1;
     */
    value: Expression_Literal;
    case: "literal";
  } | {
    /**
     * @generated from field: substrait.Expression.FieldReference selection = 2;
     */
    value: Expression_FieldReference;
    case: "selection";
  } | {
    /**
     * @generated from field: substrait.Expression.ScalarFunction scalar_function = 3;
     */
    value: Expression_ScalarFunction;
    case: "scalarFunction";
  } | {
    /**
     * @generated from field: substrait.Expression.WindowFunction window_function = 5;
     */
    value: Expression_WindowFunction;
    case: "windowFunction";
  } | {
    /**
     * @generated from field: substrait.Expression.IfThen if_then = 6;
     */
    value: Expression_IfThen;
    case: "ifThen";
  } | {
    /**
     * @generated from field: substrait.Expression.SwitchExpression switch_expression = 7;
     */
    value: Expression_SwitchExpression;
    case: "switchExpression";
  } | {
    /**
     * @generated from field: substrait.Expression.SingularOrList singular_or_list = 8;
     */
    value: Expression_SingularOrList;
    case: "singularOrList";
  } | {
    /**
     * @generated from field: substrait.Expression.MultiOrList multi_or_list = 9;
     */
    value: Expression_MultiOrList;
    case: "multiOrList";
  } | {
    /**
     * @generated from field: substrait.Expression.Cast cast = 11;
     */
    value: Expression_Cast;
    case: "cast";
  } | {
    /**
     * @generated from field: substrait.Expression.Subquery subquery = 12;
     */
    value: Expression_Subquery;
    case: "subquery";
  } | {
    /**
     * @generated from field: substrait.Expression.Nested nested = 13;
     */
    value: Expression_Nested;
    case: "nested";
  } | {
    /**
     * deprecated: enum literals are only sensible in the context of
     * function arguments, for which FunctionArgument should now be
     * used
     *
     * @generated from field: substrait.Expression.Enum enum = 10 [deprecated = true];
     * @deprecated
     */
    value: Expression_Enum;
    case: "enum";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.
 * Use `create(ExpressionSchema)` to create a new message.
 */
export const ExpressionSchema: GenMessage<Expression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28);

/**
 * @generated from message substrait.Expression.Enum
 * @deprecated
 */
export type Expression_Enum = Message<"substrait.Expression.Enum"> & {
  /**
   * @generated from oneof substrait.Expression.Enum.enum_kind
   * @deprecated
   */
  enumKind: {
    /**
     * @generated from field: string specified = 1;
     */
    value: string;
    case: "specified";
  } | {
    /**
     * @generated from field: substrait.Expression.Enum.Empty unspecified = 2;
     */
    value: Expression_Enum_Empty;
    case: "unspecified";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.Enum.
 * Use `create(Expression_EnumSchema)` to create a new message.
 * @deprecated
 */
export const Expression_EnumSchema: GenMessage<Expression_Enum> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 0);

/**
 * @generated from message substrait.Expression.Enum.Empty
 * @deprecated
 */
export type Expression_Enum_Empty = Message<"substrait.Expression.Enum.Empty"> & {
};

/**
 * Describes the message substrait.Expression.Enum.Empty.
 * Use `create(Expression_Enum_EmptySchema)` to create a new message.
 * @deprecated
 */
export const Expression_Enum_EmptySchema: GenMessage<Expression_Enum_Empty> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 0, 0);

/**
 * @generated from message substrait.Expression.Literal
 */
export type Expression_Literal = Message<"substrait.Expression.Literal"> & {
  /**
   * @generated from oneof substrait.Expression.Literal.literal_type
   */
  literalType: {
    /**
     * @generated from field: bool boolean = 1;
     */
    value: boolean;
    case: "boolean";
  } | {
    /**
     * @generated from field: int32 i8 = 2;
     */
    value: number;
    case: "i8";
  } | {
    /**
     * @generated from field: int32 i16 = 3;
     */
    value: number;
    case: "i16";
  } | {
    /**
     * @generated from field: int32 i32 = 5;
     */
    value: number;
    case: "i32";
  } | {
    /**
     * @generated from field: int64 i64 = 7;
     */
    value: bigint;
    case: "i64";
  } | {
    /**
     * @generated from field: float fp32 = 10;
     */
    value: number;
    case: "fp32";
  } | {
    /**
     * @generated from field: double fp64 = 11;
     */
    value: number;
    case: "fp64";
  } | {
    /**
     * @generated from field: string string = 12;
     */
    value: string;
    case: "string";
  } | {
    /**
     * @generated from field: bytes binary = 13;
     */
    value: Uint8Array;
    case: "binary";
  } | {
    /**
     * Timestamp in units of microseconds since the UNIX epoch.
     * Deprecated in favor of `precision_timestamp`
     *
     * @generated from field: int64 timestamp = 14 [deprecated = true];
     * @deprecated
     */
    value: bigint;
    case: "timestamp";
  } | {
    /**
     * Date in units of days since the UNIX epoch.
     *
     * @generated from field: int32 date = 16;
     */
    value: number;
    case: "date";
  } | {
    /**
     * Time in units of microseconds past midnight
     *
     * @generated from field: int64 time = 17;
     */
    value: bigint;
    case: "time";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 19;
     */
    value: Expression_Literal_IntervalYearToMonth;
    case: "intervalYearToMonth";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 20;
     */
    value: Expression_Literal_IntervalDayToSecond;
    case: "intervalDayToSecond";
  } | {
    /**
     * @generated from field: string fixed_char = 21;
     */
    value: string;
    case: "fixedChar";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.VarChar var_char = 22;
     */
    value: Expression_Literal_VarChar;
    case: "varChar";
  } | {
    /**
     * @generated from field: bytes fixed_binary = 23;
     */
    value: Uint8Array;
    case: "fixedBinary";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.Decimal decimal = 24;
     */
    value: Expression_Literal_Decimal;
    case: "decimal";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.PrecisionTimestamp precision_timestamp = 34;
     */
    value: Expression_Literal_PrecisionTimestamp;
    case: "precisionTimestamp";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.PrecisionTimestamp precision_timestamp_tz = 35;
     */
    value: Expression_Literal_PrecisionTimestamp;
    case: "precisionTimestampTz";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.Struct struct = 25;
     */
    value: Expression_Literal_Struct;
    case: "struct";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.Map map = 26;
     */
    value: Expression_Literal_Map;
    case: "map";
  } | {
    /**
     * Timestamp in units of microseconds since the UNIX epoch.
     * Deprecated in favor of `precision_timestamp_tz`
     *
     * @generated from field: int64 timestamp_tz = 27 [deprecated = true];
     * @deprecated
     */
    value: bigint;
    case: "timestampTz";
  } | {
    /**
     * @generated from field: bytes uuid = 28;
     */
    value: Uint8Array;
    case: "uuid";
  } | {
    /**
     * a typed null literal
     *
     * @generated from field: substrait.Type null = 29;
     */
    value: Type;
    case: "null";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.List list = 30;
     */
    value: Expression_Literal_List;
    case: "list";
  } | {
    /**
     * @generated from field: substrait.Type.List empty_list = 31;
     */
    value: Type_List;
    case: "emptyList";
  } | {
    /**
     * @generated from field: substrait.Type.Map empty_map = 32;
     */
    value: Type_Map;
    case: "emptyMap";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.UserDefined user_defined = 33;
     */
    value: Expression_Literal_UserDefined;
    case: "userDefined";
  } | { case: undefined; value?: undefined };

  /**
   * Whether the literal_type above should be treated as a nullable type.
   * Applies to all members of the literal_type oneof EXCEPT:
   *  * Type null             (must be nullable by definition)
   *  * Type.List empty_list  (use Type.List::nullability)
   *  * Type.Map empty_map    (use Type.Map::nullability)
   *
   * @generated from field: bool nullable = 50;
   */
  nullable: boolean;

  /**
   * optionally points to a type_variation_anchor defined in this plan.
   * Applies to all members of union other than the Typed null (which should
   * directly declare the type variation).
   *
   * @generated from field: uint32 type_variation_reference = 51;
   */
  typeVariationReference: number;
};

/**
 * Describes the message substrait.Expression.Literal.
 * Use `create(Expression_LiteralSchema)` to create a new message.
 */
export const Expression_LiteralSchema: GenMessage<Expression_Literal> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1);

/**
 * @generated from message substrait.Expression.Literal.VarChar
 */
export type Expression_Literal_VarChar = Message<"substrait.Expression.Literal.VarChar"> & {
  /**
   * @generated from field: string value = 1;
   */
  value: string;

  /**
   * @generated from field: uint32 length = 2;
   */
  length: number;
};

/**
 * Describes the message substrait.Expression.Literal.VarChar.
 * Use `create(Expression_Literal_VarCharSchema)` to create a new message.
 */
export const Expression_Literal_VarCharSchema: GenMessage<Expression_Literal_VarChar> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1, 0);

/**
 * @generated from message substrait.Expression.Literal.Decimal
 */
export type Expression_Literal_Decimal = Message<"substrait.Expression.Literal.Decimal"> & {
  /**
   * little-endian twos-complement integer representation of complete value
   * (ignoring precision) Always 16 bytes in length
   *
   * @generated from field: bytes value = 1;
   */
  value: Uint8Array;

  /**
   * The maximum number of digits allowed in the value.
   * the maximum precision is 38.
   *
   * @generated from field: int32 precision = 2;
   */
  precision: number;

  /**
   * declared scale of decimal literal
   *
   * @generated from field: int32 scale = 3;
   */
  scale: number;
};

/**
 * Describes the message substrait.Expression.Literal.Decimal.
 * Use `create(Expression_Literal_DecimalSchema)` to create a new message.
 */
export const Expression_Literal_DecimalSchema: GenMessage<Expression_Literal_Decimal> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1, 1);

/**
 * @generated from message substrait.Expression.Literal.PrecisionTimestamp
 */
export type Expression_Literal_PrecisionTimestamp = Message<"substrait.Expression.Literal.PrecisionTimestamp"> & {
  /**
   * Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds
   *
   * @generated from field: int32 precision = 1;
   */
  precision: number;

  /**
   * Time passed since 1970-01-01 00:00:00.000000 in UTC for PrecisionTimestampTZ and unspecified timezone for PrecisionTimestamp
   *
   * @generated from field: uint64 value = 2;
   */
  value: bigint;
};

/**
 * Describes the message substrait.Expression.Literal.PrecisionTimestamp.
 * Use `create(Expression_Literal_PrecisionTimestampSchema)` to create a new message.
 */
export const Expression_Literal_PrecisionTimestampSchema: GenMessage<Expression_Literal_PrecisionTimestamp> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1, 2);

/**
 * @generated from message substrait.Expression.Literal.Map
 */
export type Expression_Literal_Map = Message<"substrait.Expression.Literal.Map"> & {
  /**
   * @generated from field: repeated substrait.Expression.Literal.Map.KeyValue key_values = 1;
   */
  keyValues: Expression_Literal_Map_KeyValue[];
};

/**
 * Describes the message substrait.Expression.Literal.Map.
 * Use `create(Expression_Literal_MapSchema)` to create a new message.
 */
export const Expression_Literal_MapSchema: GenMessage<Expression_Literal_Map> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1, 3);

/**
 * @generated from message substrait.Expression.Literal.Map.KeyValue
 */
export type Expression_Literal_Map_KeyValue = Message<"substrait.Expression.Literal.Map.KeyValue"> & {
  /**
   * @generated from field: substrait.Expression.Literal key = 1;
   */
  key?: Expression_Literal;

  /**
   * @generated from field: substrait.Expression.Literal value = 2;
   */
  value?: Expression_Literal;
};

/**
 * Describes the message substrait.Expression.Literal.Map.KeyValue.
 * Use `create(Expression_Literal_Map_KeyValueSchema)` to create a new message.
 */
export const Expression_Literal_Map_KeyValueSchema: GenMessage<Expression_Literal_Map_KeyValue> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1, 3, 0);

/**
 * @generated from message substrait.Expression.Literal.IntervalYearToMonth
 */
export type Expression_Literal_IntervalYearToMonth = Message<"substrait.Expression.Literal.IntervalYearToMonth"> & {
  /**
   * @generated from field: int32 years = 1;
   */
  years: number;

  /**
   * @generated from field: int32 months = 2;
   */
  months: number;
};

/**
 * Describes the message substrait.Expression.Literal.IntervalYearToMonth.
 * Use `create(Expression_Literal_IntervalYearToMonthSchema)` to create a new message.
 */
export const Expression_Literal_IntervalYearToMonthSchema: GenMessage<Expression_Literal_IntervalYearToMonth> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1, 4);

/**
 * @generated from message substrait.Expression.Literal.IntervalDayToSecond
 */
export type Expression_Literal_IntervalDayToSecond = Message<"substrait.Expression.Literal.IntervalDayToSecond"> & {
  /**
   * @generated from field: int32 days = 1;
   */
  days: number;

  /**
   * @generated from field: int32 seconds = 2;
   */
  seconds: number;

  /**
   * @generated from field: int32 microseconds = 3;
   */
  microseconds: number;
};

/**
 * Describes the message substrait.Expression.Literal.IntervalDayToSecond.
 * Use `create(Expression_Literal_IntervalDayToSecondSchema)` to create a new message.
 */
export const Expression_Literal_IntervalDayToSecondSchema: GenMessage<Expression_Literal_IntervalDayToSecond> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1, 5);

/**
 * @generated from message substrait.Expression.Literal.Struct
 */
export type Expression_Literal_Struct = Message<"substrait.Expression.Literal.Struct"> & {
  /**
   * A possibly heterogeneously typed list of literals
   *
   * @generated from field: repeated substrait.Expression.Literal fields = 1;
   */
  fields: Expression_Literal[];
};

/**
 * Describes the message substrait.Expression.Literal.Struct.
 * Use `create(Expression_Literal_StructSchema)` to create a new message.
 */
export const Expression_Literal_StructSchema: GenMessage<Expression_Literal_Struct> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1, 6);

/**
 * @generated from message substrait.Expression.Literal.List
 */
export type Expression_Literal_List = Message<"substrait.Expression.Literal.List"> & {
  /**
   * A homogeneously typed list of literals
   *
   * @generated from field: repeated substrait.Expression.Literal values = 1;
   */
  values: Expression_Literal[];
};

/**
 * Describes the message substrait.Expression.Literal.List.
 * Use `create(Expression_Literal_ListSchema)` to create a new message.
 */
export const Expression_Literal_ListSchema: GenMessage<Expression_Literal_List> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1, 7);

/**
 * @generated from message substrait.Expression.Literal.UserDefined
 */
export type Expression_Literal_UserDefined = Message<"substrait.Expression.Literal.UserDefined"> & {
  /**
   * points to a type_anchor defined in this plan
   *
   * @generated from field: uint32 type_reference = 1;
   */
  typeReference: number;

  /**
   * The parameters to be bound to the type class, if the type class is
   * parameterizable.
   *
   * @generated from field: repeated substrait.Type.Parameter type_parameters = 3;
   */
  typeParameters: Type_Parameter[];

  /**
   * a user-defined literal can be encoded in one of two ways
   *
   * @generated from oneof substrait.Expression.Literal.UserDefined.val
   */
  val: {
    /**
     * the value of the literal, serialized using some type-specific protobuf message
     *
     * @generated from field: google.protobuf.Any value = 2;
     */
    value: Any;
    case: "value";
  } | {
    /**
     * the value of the literal, serialized using the structure definition in its declaration
     *
     * @generated from field: substrait.Expression.Literal.Struct struct = 4;
     */
    value: Expression_Literal_Struct;
    case: "struct";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.Literal.UserDefined.
 * Use `create(Expression_Literal_UserDefinedSchema)` to create a new message.
 */
export const Expression_Literal_UserDefinedSchema: GenMessage<Expression_Literal_UserDefined> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 1, 8);

/**
 * Expression to dynamically construct nested types.
 *
 * @generated from message substrait.Expression.Nested
 */
export type Expression_Nested = Message<"substrait.Expression.Nested"> & {
  /**
   * Whether the returned nested type is nullable.
   *
   * @generated from field: bool nullable = 1;
   */
  nullable: boolean;

  /**
   * Optionally points to a type_variation_anchor defined in this plan for
   * the returned nested type.
   *
   * @generated from field: uint32 type_variation_reference = 2;
   */
  typeVariationReference: number;

  /**
   * @generated from oneof substrait.Expression.Nested.nested_type
   */
  nestedType: {
    /**
     * @generated from field: substrait.Expression.Nested.Struct struct = 3;
     */
    value: Expression_Nested_Struct;
    case: "struct";
  } | {
    /**
     * @generated from field: substrait.Expression.Nested.List list = 4;
     */
    value: Expression_Nested_List;
    case: "list";
  } | {
    /**
     * @generated from field: substrait.Expression.Nested.Map map = 5;
     */
    value: Expression_Nested_Map;
    case: "map";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.Nested.
 * Use `create(Expression_NestedSchema)` to create a new message.
 */
export const Expression_NestedSchema: GenMessage<Expression_Nested> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 2);

/**
 * @generated from message substrait.Expression.Nested.Map
 */
export type Expression_Nested_Map = Message<"substrait.Expression.Nested.Map"> & {
  /**
   * One or more key-value pairs. To specify an empty map, use
   * Literal.empty_map (otherwise type information would be missing).
   *
   * @generated from field: repeated substrait.Expression.Nested.Map.KeyValue key_values = 1;
   */
  keyValues: Expression_Nested_Map_KeyValue[];
};

/**
 * Describes the message substrait.Expression.Nested.Map.
 * Use `create(Expression_Nested_MapSchema)` to create a new message.
 */
export const Expression_Nested_MapSchema: GenMessage<Expression_Nested_Map> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 2, 0);

/**
 * @generated from message substrait.Expression.Nested.Map.KeyValue
 */
export type Expression_Nested_Map_KeyValue = Message<"substrait.Expression.Nested.Map.KeyValue"> & {
  /**
   * Mandatory key/value expressions.
   *
   * @generated from field: substrait.Expression key = 1;
   */
  key?: Expression;

  /**
   * @generated from field: substrait.Expression value = 2;
   */
  value?: Expression;
};

/**
 * Describes the message substrait.Expression.Nested.Map.KeyValue.
 * Use `create(Expression_Nested_Map_KeyValueSchema)` to create a new message.
 */
export const Expression_Nested_Map_KeyValueSchema: GenMessage<Expression_Nested_Map_KeyValue> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 2, 0, 0);

/**
 * @generated from message substrait.Expression.Nested.Struct
 */
export type Expression_Nested_Struct = Message<"substrait.Expression.Nested.Struct"> & {
  /**
   * Zero or more possibly heterogeneously-typed list of expressions that
   * form the struct fields.
   *
   * @generated from field: repeated substrait.Expression fields = 1;
   */
  fields: Expression[];
};

/**
 * Describes the message substrait.Expression.Nested.Struct.
 * Use `create(Expression_Nested_StructSchema)` to create a new message.
 */
export const Expression_Nested_StructSchema: GenMessage<Expression_Nested_Struct> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 2, 1);

/**
 * @generated from message substrait.Expression.Nested.List
 */
export type Expression_Nested_List = Message<"substrait.Expression.Nested.List"> & {
  /**
   * A homogeneously-typed list of one or more expressions that form the
   * list entries. To specify an empty list, use Literal.empty_list
   * (otherwise type information would be missing).
   *
   * @generated from field: repeated substrait.Expression values = 1;
   */
  values: Expression[];
};

/**
 * Describes the message substrait.Expression.Nested.List.
 * Use `create(Expression_Nested_ListSchema)` to create a new message.
 */
export const Expression_Nested_ListSchema: GenMessage<Expression_Nested_List> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 2, 2);

/**
 * A scalar function call.
 *
 * @generated from message substrait.Expression.ScalarFunction
 */
export type Expression_ScalarFunction = Message<"substrait.Expression.ScalarFunction"> & {
  /**
   * Points to a function_anchor defined in this plan, which must refer
   * to a scalar function in the associated YAML file. Required; avoid
   * using anchor/reference zero.
   *
   * @generated from field: uint32 function_reference = 1;
   */
  functionReference: number;

  /**
   * The arguments to be bound to the function. This must have exactly the
   * number of arguments specified in the function definition, and the
   * argument types must also match exactly:
   *
   *  - Value arguments must be bound using FunctionArgument.value, and
   *    the expression in that must yield a value of a type that a function
   *    overload is defined for.
   *  - Type arguments must be bound using FunctionArgument.type.
   *  - Enum arguments must be bound using FunctionArgument.enum
   *    followed by Enum.specified, with a string that case-insensitively
   *    matches one of the allowed options.
   *
   * @generated from field: repeated substrait.FunctionArgument arguments = 4;
   */
  arguments: FunctionArgument[];

  /**
   * Options to specify behavior for corner cases, or leave behavior
   * unspecified if the consumer does not need specific behavior in these
   * cases.
   *
   * @generated from field: repeated substrait.FunctionOption options = 5;
   */
  options: FunctionOption[];

  /**
   * Must be set to the return type of the function, exactly as derived
   * using the declaration in the extension.
   *
   * @generated from field: substrait.Type output_type = 3;
   */
  outputType?: Type;

  /**
   * Deprecated; use arguments instead.
   *
   * @generated from field: repeated substrait.Expression args = 2 [deprecated = true];
   * @deprecated
   */
  args: Expression[];
};

/**
 * Describes the message substrait.Expression.ScalarFunction.
 * Use `create(Expression_ScalarFunctionSchema)` to create a new message.
 */
export const Expression_ScalarFunctionSchema: GenMessage<Expression_ScalarFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 3);

/**
 * A window function call.
 *
 * @generated from message substrait.Expression.WindowFunction
 */
export type Expression_WindowFunction = Message<"substrait.Expression.WindowFunction"> & {
  /**
   * Points to a function_anchor defined in this plan. The function must be:
   *  - a window function
   *  - an aggregate function
   *
   * An aggregate function referenced here should be treated as a window
   * function with Window Type STREAMING
   *
   * Required; 0 is considered to be a valid anchor/reference.
   *
   * @generated from field: uint32 function_reference = 1;
   */
  functionReference: number;

  /**
   * The arguments to be bound to the function. This must have exactly the
   * number of arguments specified in the function definition, and the
   * argument types must also match exactly:
   *
   *  - Value arguments must be bound using FunctionArgument.value, and
   *    the expression in that must yield a value of a type that a function
   *    overload is defined for.
   *  - Type arguments must be bound using FunctionArgument.type, and a
   *    function overload must be defined for that type.
   *  - Enum arguments must be bound using FunctionArgument.enum
   *    followed by Enum.specified, with a string that case-insensitively
   *    matches one of the allowed options.
   *
   * @generated from field: repeated substrait.FunctionArgument arguments = 9;
   */
  arguments: FunctionArgument[];

  /**
   * Options to specify behavior for corner cases, or leave behavior
   * unspecified if the consumer does not need specific behavior in these
   * cases.
   *
   * @generated from field: repeated substrait.FunctionOption options = 11;
   */
  options: FunctionOption[];

  /**
   * Must be set to the return type of the function, exactly as derived
   * using the declaration in the extension.
   *
   * @generated from field: substrait.Type output_type = 7;
   */
  outputType?: Type;

  /**
   * Describes which part of the window function to perform within the
   * context of distributed algorithms. Required. Must be set to
   * INITIAL_TO_RESULT for window functions that are not decomposable.
   *
   * @generated from field: substrait.AggregationPhase phase = 6;
   */
  phase: AggregationPhase;

  /**
   * If specified, the records that are part of the window defined by
   * upper_bound and lower_bound are ordered according to this list
   * before they are aggregated. The first sort field has the highest
   * priority; only if a sort field determines two records to be equivalent
   * is the next field queried. This field is optional, and is only allowed
   * if the window function is defined to support sorting.
   *
   * @generated from field: repeated substrait.SortField sorts = 3;
   */
  sorts: SortField[];

  /**
   * Specifies whether equivalent records are merged before being aggregated.
   * Optional, defaults to AGGREGATION_INVOCATION_ALL.
   *
   * @generated from field: substrait.AggregateFunction.AggregationInvocation invocation = 10;
   */
  invocation: AggregateFunction_AggregationInvocation;

  /**
   * When one or more partition expressions are specified, two records are
   * considered to be in the same partition if and only if these expressions
   * yield an equal record of values for both. When computing the window
   * function, only the subset of records within the bounds that are also in
   * the same partition as the current record are aggregated.
   *
   * @generated from field: repeated substrait.Expression partitions = 2;
   */
  partitions: Expression[];

  /**
   * Defines the bounds type: ROWS, RANGE
   *
   * @generated from field: substrait.Expression.WindowFunction.BoundsType bounds_type = 12;
   */
  boundsType: Expression_WindowFunction_BoundsType;

  /**
   * Defines the record relative to the current record from which the window
   * extends. The bound is inclusive. If the lower bound indexes a record
   * greater than the upper bound, TODO (null range/no records passed?
   * wrapping around as if lower/upper were swapped? error? null?).
   * Optional; defaults to the start of the partition.
   *
   * @generated from field: substrait.Expression.WindowFunction.Bound lower_bound = 5;
   */
  lowerBound?: Expression_WindowFunction_Bound;

  /**
   * Defines the record relative to the current record up to which the window
   * extends. The bound is inclusive. If the upper bound indexes a record
   * less than the lower bound, TODO (null range/no records passed?
   * wrapping around as if lower/upper were swapped? error? null?).
   * Optional; defaults to the end of the partition.
   *
   * @generated from field: substrait.Expression.WindowFunction.Bound upper_bound = 4;
   */
  upperBound?: Expression_WindowFunction_Bound;

  /**
   * Deprecated; use arguments instead.
   *
   * @generated from field: repeated substrait.Expression args = 8 [deprecated = true];
   * @deprecated
   */
  args: Expression[];
};

/**
 * Describes the message substrait.Expression.WindowFunction.
 * Use `create(Expression_WindowFunctionSchema)` to create a new message.
 */
export const Expression_WindowFunctionSchema: GenMessage<Expression_WindowFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 4);

/**
 * Defines one of the two boundaries for the window of a window function.
 *
 * @generated from message substrait.Expression.WindowFunction.Bound
 */
export type Expression_WindowFunction_Bound = Message<"substrait.Expression.WindowFunction.Bound"> & {
  /**
   * @generated from oneof substrait.Expression.WindowFunction.Bound.kind
   */
  kind: {
    /**
     * The bound extends some number of records behind the current record.
     *
     * @generated from field: substrait.Expression.WindowFunction.Bound.Preceding preceding = 1;
     */
    value: Expression_WindowFunction_Bound_Preceding;
    case: "preceding";
  } | {
    /**
     * The bound extends some number of records ahead of the current
     * record.
     *
     * @generated from field: substrait.Expression.WindowFunction.Bound.Following following = 2;
     */
    value: Expression_WindowFunction_Bound_Following;
    case: "following";
  } | {
    /**
     * The bound extends to the current record.
     *
     * @generated from field: substrait.Expression.WindowFunction.Bound.CurrentRow current_row = 3;
     */
    value: Expression_WindowFunction_Bound_CurrentRow;
    case: "currentRow";
  } | {
    /**
     * The bound extends to the start of the partition or the end of the
     * partition, depending on whether this represents the upper or lower
     * bound.
     *
     * @generated from field: substrait.Expression.WindowFunction.Bound.Unbounded unbounded = 4;
     */
    value: Expression_WindowFunction_Bound_Unbounded;
    case: "unbounded";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.WindowFunction.Bound.
 * Use `create(Expression_WindowFunction_BoundSchema)` to create a new message.
 */
export const Expression_WindowFunction_BoundSchema: GenMessage<Expression_WindowFunction_Bound> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 4, 0);

/**
 * Defines that the bound extends this far back from the current record.
 *
 * @generated from message substrait.Expression.WindowFunction.Bound.Preceding
 */
export type Expression_WindowFunction_Bound_Preceding = Message<"substrait.Expression.WindowFunction.Bound.Preceding"> & {
  /**
   * A strictly positive integer specifying the number of records that
   * the window extends back from the current record. Required. Use
   * CurrentRow for offset zero and Following for negative offsets.
   *
   * @generated from field: int64 offset = 1;
   */
  offset: bigint;
};

/**
 * Describes the message substrait.Expression.WindowFunction.Bound.Preceding.
 * Use `create(Expression_WindowFunction_Bound_PrecedingSchema)` to create a new message.
 */
export const Expression_WindowFunction_Bound_PrecedingSchema: GenMessage<Expression_WindowFunction_Bound_Preceding> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 4, 0, 0);

/**
 * Defines that the bound extends this far ahead of the current record.
 *
 * @generated from message substrait.Expression.WindowFunction.Bound.Following
 */
export type Expression_WindowFunction_Bound_Following = Message<"substrait.Expression.WindowFunction.Bound.Following"> & {
  /**
   * A strictly positive integer specifying the number of records that
   * the window extends ahead of the current record. Required. Use
   * CurrentRow for offset zero and Preceding for negative offsets.
   *
   * @generated from field: int64 offset = 1;
   */
  offset: bigint;
};

/**
 * Describes the message substrait.Expression.WindowFunction.Bound.Following.
 * Use `create(Expression_WindowFunction_Bound_FollowingSchema)` to create a new message.
 */
export const Expression_WindowFunction_Bound_FollowingSchema: GenMessage<Expression_WindowFunction_Bound_Following> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 4, 0, 1);

/**
 * Defines that the bound extends to or from the current record.
 *
 * @generated from message substrait.Expression.WindowFunction.Bound.CurrentRow
 */
export type Expression_WindowFunction_Bound_CurrentRow = Message<"substrait.Expression.WindowFunction.Bound.CurrentRow"> & {
};

/**
 * Describes the message substrait.Expression.WindowFunction.Bound.CurrentRow.
 * Use `create(Expression_WindowFunction_Bound_CurrentRowSchema)` to create a new message.
 */
export const Expression_WindowFunction_Bound_CurrentRowSchema: GenMessage<Expression_WindowFunction_Bound_CurrentRow> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 4, 0, 2);

/**
 * Defines an "unbounded bound": for lower bounds this means the start
 * of the partition, and for upper bounds this means the end of the
 * partition.
 *
 * @generated from message substrait.Expression.WindowFunction.Bound.Unbounded
 */
export type Expression_WindowFunction_Bound_Unbounded = Message<"substrait.Expression.WindowFunction.Bound.Unbounded"> & {
};

/**
 * Describes the message substrait.Expression.WindowFunction.Bound.Unbounded.
 * Use `create(Expression_WindowFunction_Bound_UnboundedSchema)` to create a new message.
 */
export const Expression_WindowFunction_Bound_UnboundedSchema: GenMessage<Expression_WindowFunction_Bound_Unbounded> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 4, 0, 3);

/**
 * @generated from enum substrait.Expression.WindowFunction.BoundsType
 */
export enum Expression_WindowFunction_BoundsType {
  /**
   * @generated from enum value: BOUNDS_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The lower and upper bound specify how many rows before and after the current row
   * the window should extend.
   *
   * @generated from enum value: BOUNDS_TYPE_ROWS = 1;
   */
  ROWS = 1,

  /**
   * The lower and upper bound describe a range of values.  The window should include all rows
   * where the value of the ordering column is greater than or equal to (current_value - lower bound)
   * and less than or equal to (current_value + upper bound).  This bounds type is only valid if there
   * is a single ordering column.
   *
   * @generated from enum value: BOUNDS_TYPE_RANGE = 2;
   */
  RANGE = 2,
}

/**
 * Describes the enum substrait.Expression.WindowFunction.BoundsType.
 */
export const Expression_WindowFunction_BoundsTypeSchema: GenEnum<Expression_WindowFunction_BoundsType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 28, 4, 0);

/**
 * @generated from message substrait.Expression.IfThen
 */
export type Expression_IfThen = Message<"substrait.Expression.IfThen"> & {
  /**
   * A list of one or more IfClauses
   *
   * @generated from field: repeated substrait.Expression.IfThen.IfClause ifs = 1;
   */
  ifs: Expression_IfThen_IfClause[];

  /**
   * The returned Expression if no IfClauses are satisified
   *
   * @generated from field: substrait.Expression else = 2;
   */
  else?: Expression;
};

/**
 * Describes the message substrait.Expression.IfThen.
 * Use `create(Expression_IfThenSchema)` to create a new message.
 */
export const Expression_IfThenSchema: GenMessage<Expression_IfThen> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 5);

/**
 * @generated from message substrait.Expression.IfThen.IfClause
 */
export type Expression_IfThen_IfClause = Message<"substrait.Expression.IfThen.IfClause"> & {
  /**
   * @generated from field: substrait.Expression if = 1;
   */
  if?: Expression;

  /**
   * @generated from field: substrait.Expression then = 2;
   */
  then?: Expression;
};

/**
 * Describes the message substrait.Expression.IfThen.IfClause.
 * Use `create(Expression_IfThen_IfClauseSchema)` to create a new message.
 */
export const Expression_IfThen_IfClauseSchema: GenMessage<Expression_IfThen_IfClause> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 5, 0);

/**
 * @generated from message substrait.Expression.Cast
 */
export type Expression_Cast = Message<"substrait.Expression.Cast"> & {
  /**
   * @generated from field: substrait.Type type = 1;
   */
  type?: Type;

  /**
   * @generated from field: substrait.Expression input = 2;
   */
  input?: Expression;

  /**
   * @generated from field: substrait.Expression.Cast.FailureBehavior failure_behavior = 3;
   */
  failureBehavior: Expression_Cast_FailureBehavior;
};

/**
 * Describes the message substrait.Expression.Cast.
 * Use `create(Expression_CastSchema)` to create a new message.
 */
export const Expression_CastSchema: GenMessage<Expression_Cast> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 6);

/**
 * @generated from enum substrait.Expression.Cast.FailureBehavior
 */
export enum Expression_Cast_FailureBehavior {
  /**
   * @generated from enum value: FAILURE_BEHAVIOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FAILURE_BEHAVIOR_RETURN_NULL = 1;
   */
  RETURN_NULL = 1,

  /**
   * @generated from enum value: FAILURE_BEHAVIOR_THROW_EXCEPTION = 2;
   */
  THROW_EXCEPTION = 2,
}

/**
 * Describes the enum substrait.Expression.Cast.FailureBehavior.
 */
export const Expression_Cast_FailureBehaviorSchema: GenEnum<Expression_Cast_FailureBehavior> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 28, 6, 0);

/**
 * @generated from message substrait.Expression.SwitchExpression
 */
export type Expression_SwitchExpression = Message<"substrait.Expression.SwitchExpression"> & {
  /**
   * @generated from field: substrait.Expression match = 3;
   */
  match?: Expression;

  /**
   * @generated from field: repeated substrait.Expression.SwitchExpression.IfValue ifs = 1;
   */
  ifs: Expression_SwitchExpression_IfValue[];

  /**
   * @generated from field: substrait.Expression else = 2;
   */
  else?: Expression;
};

/**
 * Describes the message substrait.Expression.SwitchExpression.
 * Use `create(Expression_SwitchExpressionSchema)` to create a new message.
 */
export const Expression_SwitchExpressionSchema: GenMessage<Expression_SwitchExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 7);

/**
 * @generated from message substrait.Expression.SwitchExpression.IfValue
 */
export type Expression_SwitchExpression_IfValue = Message<"substrait.Expression.SwitchExpression.IfValue"> & {
  /**
   * @generated from field: substrait.Expression.Literal if = 1;
   */
  if?: Expression_Literal;

  /**
   * @generated from field: substrait.Expression then = 2;
   */
  then?: Expression;
};

/**
 * Describes the message substrait.Expression.SwitchExpression.IfValue.
 * Use `create(Expression_SwitchExpression_IfValueSchema)` to create a new message.
 */
export const Expression_SwitchExpression_IfValueSchema: GenMessage<Expression_SwitchExpression_IfValue> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 7, 0);

/**
 * @generated from message substrait.Expression.SingularOrList
 */
export type Expression_SingularOrList = Message<"substrait.Expression.SingularOrList"> & {
  /**
   * @generated from field: substrait.Expression value = 1;
   */
  value?: Expression;

  /**
   * @generated from field: repeated substrait.Expression options = 2;
   */
  options: Expression[];
};

/**
 * Describes the message substrait.Expression.SingularOrList.
 * Use `create(Expression_SingularOrListSchema)` to create a new message.
 */
export const Expression_SingularOrListSchema: GenMessage<Expression_SingularOrList> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 8);

/**
 * @generated from message substrait.Expression.MultiOrList
 */
export type Expression_MultiOrList = Message<"substrait.Expression.MultiOrList"> & {
  /**
   * @generated from field: repeated substrait.Expression value = 1;
   */
  value: Expression[];

  /**
   * @generated from field: repeated substrait.Expression.MultiOrList.Record options = 2;
   */
  options: Expression_MultiOrList_Record[];
};

/**
 * Describes the message substrait.Expression.MultiOrList.
 * Use `create(Expression_MultiOrListSchema)` to create a new message.
 */
export const Expression_MultiOrListSchema: GenMessage<Expression_MultiOrList> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 9);

/**
 * @generated from message substrait.Expression.MultiOrList.Record
 */
export type Expression_MultiOrList_Record = Message<"substrait.Expression.MultiOrList.Record"> & {
  /**
   * @generated from field: repeated substrait.Expression fields = 1;
   */
  fields: Expression[];
};

/**
 * Describes the message substrait.Expression.MultiOrList.Record.
 * Use `create(Expression_MultiOrList_RecordSchema)` to create a new message.
 */
export const Expression_MultiOrList_RecordSchema: GenMessage<Expression_MultiOrList_Record> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 9, 0);

/**
 * @generated from message substrait.Expression.EmbeddedFunction
 */
export type Expression_EmbeddedFunction = Message<"substrait.Expression.EmbeddedFunction"> & {
  /**
   * @generated from field: repeated substrait.Expression arguments = 1;
   */
  arguments: Expression[];

  /**
   * @generated from field: substrait.Type output_type = 2;
   */
  outputType?: Type;

  /**
   * @generated from oneof substrait.Expression.EmbeddedFunction.kind
   */
  kind: {
    /**
     * @generated from field: substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function = 3;
     */
    value: Expression_EmbeddedFunction_PythonPickleFunction;
    case: "pythonPickleFunction";
  } | {
    /**
     * @generated from field: substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function = 4;
     */
    value: Expression_EmbeddedFunction_WebAssemblyFunction;
    case: "webAssemblyFunction";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.EmbeddedFunction.
 * Use `create(Expression_EmbeddedFunctionSchema)` to create a new message.
 */
export const Expression_EmbeddedFunctionSchema: GenMessage<Expression_EmbeddedFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 10);

/**
 * @generated from message substrait.Expression.EmbeddedFunction.PythonPickleFunction
 */
export type Expression_EmbeddedFunction_PythonPickleFunction = Message<"substrait.Expression.EmbeddedFunction.PythonPickleFunction"> & {
  /**
   * @generated from field: bytes function = 1;
   */
  function: Uint8Array;

  /**
   * @generated from field: repeated string prerequisite = 2;
   */
  prerequisite: string[];
};

/**
 * Describes the message substrait.Expression.EmbeddedFunction.PythonPickleFunction.
 * Use `create(Expression_EmbeddedFunction_PythonPickleFunctionSchema)` to create a new message.
 */
export const Expression_EmbeddedFunction_PythonPickleFunctionSchema: GenMessage<Expression_EmbeddedFunction_PythonPickleFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 10, 0);

/**
 * @generated from message substrait.Expression.EmbeddedFunction.WebAssemblyFunction
 */
export type Expression_EmbeddedFunction_WebAssemblyFunction = Message<"substrait.Expression.EmbeddedFunction.WebAssemblyFunction"> & {
  /**
   * @generated from field: bytes script = 1;
   */
  script: Uint8Array;

  /**
   * @generated from field: repeated string prerequisite = 2;
   */
  prerequisite: string[];
};

/**
 * Describes the message substrait.Expression.EmbeddedFunction.WebAssemblyFunction.
 * Use `create(Expression_EmbeddedFunction_WebAssemblyFunctionSchema)` to create a new message.
 */
export const Expression_EmbeddedFunction_WebAssemblyFunctionSchema: GenMessage<Expression_EmbeddedFunction_WebAssemblyFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 10, 1);

/**
 * A way to reference the inner property of a complex record. Can reference
 * either a map key by literal, a struct field by the ordinal position of
 * the desired field or a particular element in an array. Supports
 * expressions that would roughly translate to something similar to:
 * a.b[2].c['my_map_key'].x where a,b,c and x are struct field references
 * (ordinalized in the internal representation here), [2] is a list offset
 * and ['my_map_key'] is a reference into a map field.
 *
 * @generated from message substrait.Expression.ReferenceSegment
 */
export type Expression_ReferenceSegment = Message<"substrait.Expression.ReferenceSegment"> & {
  /**
   * @generated from oneof substrait.Expression.ReferenceSegment.reference_type
   */
  referenceType: {
    /**
     * @generated from field: substrait.Expression.ReferenceSegment.MapKey map_key = 1;
     */
    value: Expression_ReferenceSegment_MapKey;
    case: "mapKey";
  } | {
    /**
     * @generated from field: substrait.Expression.ReferenceSegment.StructField struct_field = 2;
     */
    value: Expression_ReferenceSegment_StructField;
    case: "structField";
  } | {
    /**
     * @generated from field: substrait.Expression.ReferenceSegment.ListElement list_element = 3;
     */
    value: Expression_ReferenceSegment_ListElement;
    case: "listElement";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.ReferenceSegment.
 * Use `create(Expression_ReferenceSegmentSchema)` to create a new message.
 */
export const Expression_ReferenceSegmentSchema: GenMessage<Expression_ReferenceSegment> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 11);

/**
 * @generated from message substrait.Expression.ReferenceSegment.MapKey
 */
export type Expression_ReferenceSegment_MapKey = Message<"substrait.Expression.ReferenceSegment.MapKey"> & {
  /**
   * literal based reference to specific possible value in map.
   *
   * @generated from field: substrait.Expression.Literal map_key = 1;
   */
  mapKey?: Expression_Literal;

  /**
   * Optional child segment
   *
   * @generated from field: substrait.Expression.ReferenceSegment child = 2;
   */
  child?: Expression_ReferenceSegment;
};

/**
 * Describes the message substrait.Expression.ReferenceSegment.MapKey.
 * Use `create(Expression_ReferenceSegment_MapKeySchema)` to create a new message.
 */
export const Expression_ReferenceSegment_MapKeySchema: GenMessage<Expression_ReferenceSegment_MapKey> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 11, 0);

/**
 * @generated from message substrait.Expression.ReferenceSegment.StructField
 */
export type Expression_ReferenceSegment_StructField = Message<"substrait.Expression.ReferenceSegment.StructField"> & {
  /**
   * zero-indexed ordinal position of field in struct
   *
   * @generated from field: int32 field = 1;
   */
  field: number;

  /**
   * Optional child segment
   *
   * @generated from field: substrait.Expression.ReferenceSegment child = 2;
   */
  child?: Expression_ReferenceSegment;
};

/**
 * Describes the message substrait.Expression.ReferenceSegment.StructField.
 * Use `create(Expression_ReferenceSegment_StructFieldSchema)` to create a new message.
 */
export const Expression_ReferenceSegment_StructFieldSchema: GenMessage<Expression_ReferenceSegment_StructField> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 11, 1);

/**
 * @generated from message substrait.Expression.ReferenceSegment.ListElement
 */
export type Expression_ReferenceSegment_ListElement = Message<"substrait.Expression.ReferenceSegment.ListElement"> & {
  /**
   * zero-indexed ordinal position of element in list
   *
   * @generated from field: int32 offset = 1;
   */
  offset: number;

  /**
   * Optional child segment
   *
   * @generated from field: substrait.Expression.ReferenceSegment child = 2;
   */
  child?: Expression_ReferenceSegment;
};

/**
 * Describes the message substrait.Expression.ReferenceSegment.ListElement.
 * Use `create(Expression_ReferenceSegment_ListElementSchema)` to create a new message.
 */
export const Expression_ReferenceSegment_ListElementSchema: GenMessage<Expression_ReferenceSegment_ListElement> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 11, 2);

/**
 * A reference that takes an existing subtype and selectively removes fields
 * from it. For example, one might initially have an inner struct with 100
 * fields but a a particular operation only needs to interact with only 2 of
 * those 100 fields. In this situation, one would use a mask expression to
 * eliminate the 98 fields that are not relevant to the rest of the operation
 * pipeline.
 *
 * Note that this does not fundamentally alter the structure of data beyond
 * the elimination of unnecessary elements.
 *
 * @generated from message substrait.Expression.MaskExpression
 */
export type Expression_MaskExpression = Message<"substrait.Expression.MaskExpression"> & {
  /**
   * @generated from field: substrait.Expression.MaskExpression.StructSelect select = 1;
   */
  select?: Expression_MaskExpression_StructSelect;

  /**
   * @generated from field: bool maintain_singular_struct = 2;
   */
  maintainSingularStruct: boolean;
};

/**
 * Describes the message substrait.Expression.MaskExpression.
 * Use `create(Expression_MaskExpressionSchema)` to create a new message.
 */
export const Expression_MaskExpressionSchema: GenMessage<Expression_MaskExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12);

/**
 * @generated from message substrait.Expression.MaskExpression.Select
 */
export type Expression_MaskExpression_Select = Message<"substrait.Expression.MaskExpression.Select"> & {
  /**
   * @generated from oneof substrait.Expression.MaskExpression.Select.type
   */
  type: {
    /**
     * @generated from field: substrait.Expression.MaskExpression.StructSelect struct = 1;
     */
    value: Expression_MaskExpression_StructSelect;
    case: "struct";
  } | {
    /**
     * @generated from field: substrait.Expression.MaskExpression.ListSelect list = 2;
     */
    value: Expression_MaskExpression_ListSelect;
    case: "list";
  } | {
    /**
     * @generated from field: substrait.Expression.MaskExpression.MapSelect map = 3;
     */
    value: Expression_MaskExpression_MapSelect;
    case: "map";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.MaskExpression.Select.
 * Use `create(Expression_MaskExpression_SelectSchema)` to create a new message.
 */
export const Expression_MaskExpression_SelectSchema: GenMessage<Expression_MaskExpression_Select> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12, 0);

/**
 * @generated from message substrait.Expression.MaskExpression.StructSelect
 */
export type Expression_MaskExpression_StructSelect = Message<"substrait.Expression.MaskExpression.StructSelect"> & {
  /**
   * @generated from field: repeated substrait.Expression.MaskExpression.StructItem struct_items = 1;
   */
  structItems: Expression_MaskExpression_StructItem[];
};

/**
 * Describes the message substrait.Expression.MaskExpression.StructSelect.
 * Use `create(Expression_MaskExpression_StructSelectSchema)` to create a new message.
 */
export const Expression_MaskExpression_StructSelectSchema: GenMessage<Expression_MaskExpression_StructSelect> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12, 1);

/**
 * @generated from message substrait.Expression.MaskExpression.StructItem
 */
export type Expression_MaskExpression_StructItem = Message<"substrait.Expression.MaskExpression.StructItem"> & {
  /**
   * @generated from field: int32 field = 1;
   */
  field: number;

  /**
   * @generated from field: substrait.Expression.MaskExpression.Select child = 2;
   */
  child?: Expression_MaskExpression_Select;
};

/**
 * Describes the message substrait.Expression.MaskExpression.StructItem.
 * Use `create(Expression_MaskExpression_StructItemSchema)` to create a new message.
 */
export const Expression_MaskExpression_StructItemSchema: GenMessage<Expression_MaskExpression_StructItem> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12, 2);

/**
 * @generated from message substrait.Expression.MaskExpression.ListSelect
 */
export type Expression_MaskExpression_ListSelect = Message<"substrait.Expression.MaskExpression.ListSelect"> & {
  /**
   * @generated from field: repeated substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection = 1;
   */
  selection: Expression_MaskExpression_ListSelect_ListSelectItem[];

  /**
   * @generated from field: substrait.Expression.MaskExpression.Select child = 2;
   */
  child?: Expression_MaskExpression_Select;
};

/**
 * Describes the message substrait.Expression.MaskExpression.ListSelect.
 * Use `create(Expression_MaskExpression_ListSelectSchema)` to create a new message.
 */
export const Expression_MaskExpression_ListSelectSchema: GenMessage<Expression_MaskExpression_ListSelect> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12, 3);

/**
 * @generated from message substrait.Expression.MaskExpression.ListSelect.ListSelectItem
 */
export type Expression_MaskExpression_ListSelect_ListSelectItem = Message<"substrait.Expression.MaskExpression.ListSelect.ListSelectItem"> & {
  /**
   * @generated from oneof substrait.Expression.MaskExpression.ListSelect.ListSelectItem.type
   */
  type: {
    /**
     * @generated from field: substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1;
     */
    value: Expression_MaskExpression_ListSelect_ListSelectItem_ListElement;
    case: "item";
  } | {
    /**
     * @generated from field: substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2;
     */
    value: Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice;
    case: "slice";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.
 * Use `create(Expression_MaskExpression_ListSelect_ListSelectItemSchema)` to create a new message.
 */
export const Expression_MaskExpression_ListSelect_ListSelectItemSchema: GenMessage<Expression_MaskExpression_ListSelect_ListSelectItem> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12, 3, 0);

/**
 * @generated from message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement
 */
export type Expression_MaskExpression_ListSelect_ListSelectItem_ListElement = Message<"substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement"> & {
  /**
   * @generated from field: int32 field = 1;
   */
  field: number;
};

/**
 * Describes the message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement.
 * Use `create(Expression_MaskExpression_ListSelect_ListSelectItem_ListElementSchema)` to create a new message.
 */
export const Expression_MaskExpression_ListSelect_ListSelectItem_ListElementSchema: GenMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListElement> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12, 3, 0, 0);

/**
 * @generated from message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice
 */
export type Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice = Message<"substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice"> & {
  /**
   * @generated from field: int32 start = 1;
   */
  start: number;

  /**
   * @generated from field: int32 end = 2;
   */
  end: number;
};

/**
 * Describes the message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.
 * Use `create(Expression_MaskExpression_ListSelect_ListSelectItem_ListSliceSchema)` to create a new message.
 */
export const Expression_MaskExpression_ListSelect_ListSelectItem_ListSliceSchema: GenMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12, 3, 0, 1);

/**
 * @generated from message substrait.Expression.MaskExpression.MapSelect
 */
export type Expression_MaskExpression_MapSelect = Message<"substrait.Expression.MaskExpression.MapSelect"> & {
  /**
   * @generated from oneof substrait.Expression.MaskExpression.MapSelect.select
   */
  select: {
    /**
     * @generated from field: substrait.Expression.MaskExpression.MapSelect.MapKey key = 1;
     */
    value: Expression_MaskExpression_MapSelect_MapKey;
    case: "key";
  } | {
    /**
     * @generated from field: substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression = 2;
     */
    value: Expression_MaskExpression_MapSelect_MapKeyExpression;
    case: "expression";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: substrait.Expression.MaskExpression.Select child = 3;
   */
  child?: Expression_MaskExpression_Select;
};

/**
 * Describes the message substrait.Expression.MaskExpression.MapSelect.
 * Use `create(Expression_MaskExpression_MapSelectSchema)` to create a new message.
 */
export const Expression_MaskExpression_MapSelectSchema: GenMessage<Expression_MaskExpression_MapSelect> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12, 4);

/**
 * @generated from message substrait.Expression.MaskExpression.MapSelect.MapKey
 */
export type Expression_MaskExpression_MapSelect_MapKey = Message<"substrait.Expression.MaskExpression.MapSelect.MapKey"> & {
  /**
   * @generated from field: string map_key = 1;
   */
  mapKey: string;
};

/**
 * Describes the message substrait.Expression.MaskExpression.MapSelect.MapKey.
 * Use `create(Expression_MaskExpression_MapSelect_MapKeySchema)` to create a new message.
 */
export const Expression_MaskExpression_MapSelect_MapKeySchema: GenMessage<Expression_MaskExpression_MapSelect_MapKey> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12, 4, 0);

/**
 * @generated from message substrait.Expression.MaskExpression.MapSelect.MapKeyExpression
 */
export type Expression_MaskExpression_MapSelect_MapKeyExpression = Message<"substrait.Expression.MaskExpression.MapSelect.MapKeyExpression"> & {
  /**
   * @generated from field: string map_key_expression = 1;
   */
  mapKeyExpression: string;
};

/**
 * Describes the message substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.
 * Use `create(Expression_MaskExpression_MapSelect_MapKeyExpressionSchema)` to create a new message.
 */
export const Expression_MaskExpression_MapSelect_MapKeyExpressionSchema: GenMessage<Expression_MaskExpression_MapSelect_MapKeyExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 12, 4, 1);

/**
 * A reference to an inner part of a complex object. Can reference reference a
 * single element or a masked version of elements
 *
 * @generated from message substrait.Expression.FieldReference
 */
export type Expression_FieldReference = Message<"substrait.Expression.FieldReference"> & {
  /**
   * Whether this is composed of a single element reference or a masked
   * element subtree
   *
   * @generated from oneof substrait.Expression.FieldReference.reference_type
   */
  referenceType: {
    /**
     * @generated from field: substrait.Expression.ReferenceSegment direct_reference = 1;
     */
    value: Expression_ReferenceSegment;
    case: "directReference";
  } | {
    /**
     * @generated from field: substrait.Expression.MaskExpression masked_reference = 2;
     */
    value: Expression_MaskExpression;
    case: "maskedReference";
  } | { case: undefined; value?: undefined };

  /**
   * Whether this reference has an origin of a root struct or is based on the
   * ouput of an expression. When this is a RootReference and direct_reference
   * above is used, the direct_reference must be of a type StructField.
   *
   * @generated from oneof substrait.Expression.FieldReference.root_type
   */
  rootType: {
    /**
     * @generated from field: substrait.Expression expression = 3;
     */
    value: Expression;
    case: "expression";
  } | {
    /**
     * @generated from field: substrait.Expression.FieldReference.RootReference root_reference = 4;
     */
    value: Expression_FieldReference_RootReference;
    case: "rootReference";
  } | {
    /**
     * @generated from field: substrait.Expression.FieldReference.OuterReference outer_reference = 5;
     */
    value: Expression_FieldReference_OuterReference;
    case: "outerReference";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.FieldReference.
 * Use `create(Expression_FieldReferenceSchema)` to create a new message.
 */
export const Expression_FieldReferenceSchema: GenMessage<Expression_FieldReference> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 13);

/**
 * Singleton that expresses this FieldReference is rooted off the root
 * incoming record type
 *
 * @generated from message substrait.Expression.FieldReference.RootReference
 */
export type Expression_FieldReference_RootReference = Message<"substrait.Expression.FieldReference.RootReference"> & {
};

/**
 * Describes the message substrait.Expression.FieldReference.RootReference.
 * Use `create(Expression_FieldReference_RootReferenceSchema)` to create a new message.
 */
export const Expression_FieldReference_RootReferenceSchema: GenMessage<Expression_FieldReference_RootReference> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 13, 0);

/**
 * A root reference for the outer relation's subquery
 *
 * @generated from message substrait.Expression.FieldReference.OuterReference
 */
export type Expression_FieldReference_OuterReference = Message<"substrait.Expression.FieldReference.OuterReference"> & {
  /**
   * number of subquery boundaries to traverse up for this field's reference
   *
   * This value must be >= 1
   *
   * @generated from field: uint32 steps_out = 1;
   */
  stepsOut: number;
};

/**
 * Describes the message substrait.Expression.FieldReference.OuterReference.
 * Use `create(Expression_FieldReference_OuterReferenceSchema)` to create a new message.
 */
export const Expression_FieldReference_OuterReferenceSchema: GenMessage<Expression_FieldReference_OuterReference> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 13, 1);

/**
 * Subquery relation expression
 *
 * @generated from message substrait.Expression.Subquery
 */
export type Expression_Subquery = Message<"substrait.Expression.Subquery"> & {
  /**
   * @generated from oneof substrait.Expression.Subquery.subquery_type
   */
  subqueryType: {
    /**
     * Scalar subquery
     *
     * @generated from field: substrait.Expression.Subquery.Scalar scalar = 1;
     */
    value: Expression_Subquery_Scalar;
    case: "scalar";
  } | {
    /**
     * x IN y predicate
     *
     * @generated from field: substrait.Expression.Subquery.InPredicate in_predicate = 2;
     */
    value: Expression_Subquery_InPredicate;
    case: "inPredicate";
  } | {
    /**
     * EXISTS/UNIQUE predicate
     *
     * @generated from field: substrait.Expression.Subquery.SetPredicate set_predicate = 3;
     */
    value: Expression_Subquery_SetPredicate;
    case: "setPredicate";
  } | {
    /**
     * ANY/ALL predicate
     *
     * @generated from field: substrait.Expression.Subquery.SetComparison set_comparison = 4;
     */
    value: Expression_Subquery_SetComparison;
    case: "setComparison";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.Subquery.
 * Use `create(Expression_SubquerySchema)` to create a new message.
 */
export const Expression_SubquerySchema: GenMessage<Expression_Subquery> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 14);

/**
 * A subquery with one row and one column. This is often an aggregate
 * though not required to be.
 *
 * @generated from message substrait.Expression.Subquery.Scalar
 */
export type Expression_Subquery_Scalar = Message<"substrait.Expression.Subquery.Scalar"> & {
  /**
   * @generated from field: substrait.Rel input = 1;
   */
  input?: Rel;
};

/**
 * Describes the message substrait.Expression.Subquery.Scalar.
 * Use `create(Expression_Subquery_ScalarSchema)` to create a new message.
 */
export const Expression_Subquery_ScalarSchema: GenMessage<Expression_Subquery_Scalar> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 14, 0);

/**
 * Predicate checking that the left expression is contained in the right
 * subquery
 *
 * Examples:
 *
 * x IN (SELECT * FROM t)
 * (x, y) IN (SELECT a, b FROM t)
 *
 * @generated from message substrait.Expression.Subquery.InPredicate
 */
export type Expression_Subquery_InPredicate = Message<"substrait.Expression.Subquery.InPredicate"> & {
  /**
   * @generated from field: repeated substrait.Expression needles = 1;
   */
  needles: Expression[];

  /**
   * @generated from field: substrait.Rel haystack = 2;
   */
  haystack?: Rel;
};

/**
 * Describes the message substrait.Expression.Subquery.InPredicate.
 * Use `create(Expression_Subquery_InPredicateSchema)` to create a new message.
 */
export const Expression_Subquery_InPredicateSchema: GenMessage<Expression_Subquery_InPredicate> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 14, 1);

/**
 * A predicate over a set of rows in the form of a subquery
 * EXISTS and UNIQUE are common SQL forms of this operation.
 *
 * @generated from message substrait.Expression.Subquery.SetPredicate
 */
export type Expression_Subquery_SetPredicate = Message<"substrait.Expression.Subquery.SetPredicate"> & {
  /**
   * TODO: should allow expressions
   *
   * @generated from field: substrait.Expression.Subquery.SetPredicate.PredicateOp predicate_op = 1;
   */
  predicateOp: Expression_Subquery_SetPredicate_PredicateOp;

  /**
   * @generated from field: substrait.Rel tuples = 2;
   */
  tuples?: Rel;
};

/**
 * Describes the message substrait.Expression.Subquery.SetPredicate.
 * Use `create(Expression_Subquery_SetPredicateSchema)` to create a new message.
 */
export const Expression_Subquery_SetPredicateSchema: GenMessage<Expression_Subquery_SetPredicate> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 14, 2);

/**
 * @generated from enum substrait.Expression.Subquery.SetPredicate.PredicateOp
 */
export enum Expression_Subquery_SetPredicate_PredicateOp {
  /**
   * @generated from enum value: PREDICATE_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PREDICATE_OP_EXISTS = 1;
   */
  EXISTS = 1,

  /**
   * @generated from enum value: PREDICATE_OP_UNIQUE = 2;
   */
  UNIQUE = 2,
}

/**
 * Describes the enum substrait.Expression.Subquery.SetPredicate.PredicateOp.
 */
export const Expression_Subquery_SetPredicate_PredicateOpSchema: GenEnum<Expression_Subquery_SetPredicate_PredicateOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 28, 14, 2, 0);

/**
 * A subquery comparison using ANY or ALL.
 * Examples:
 *
 * SELECT *
 * FROM t1
 * WHERE x < ANY(SELECT y from t2)
 *
 * @generated from message substrait.Expression.Subquery.SetComparison
 */
export type Expression_Subquery_SetComparison = Message<"substrait.Expression.Subquery.SetComparison"> & {
  /**
   * ANY or ALL
   *
   * @generated from field: substrait.Expression.Subquery.SetComparison.ReductionOp reduction_op = 1;
   */
  reductionOp: Expression_Subquery_SetComparison_ReductionOp;

  /**
   * A comparison operator
   *
   * @generated from field: substrait.Expression.Subquery.SetComparison.ComparisonOp comparison_op = 2;
   */
  comparisonOp: Expression_Subquery_SetComparison_ComparisonOp;

  /**
   * left side of the expression
   *
   * @generated from field: substrait.Expression left = 3;
   */
  left?: Expression;

  /**
   * right side of the expression
   *
   * @generated from field: substrait.Rel right = 4;
   */
  right?: Rel;
};

/**
 * Describes the message substrait.Expression.Subquery.SetComparison.
 * Use `create(Expression_Subquery_SetComparisonSchema)` to create a new message.
 */
export const Expression_Subquery_SetComparisonSchema: GenMessage<Expression_Subquery_SetComparison> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28, 14, 3);

/**
 * @generated from enum substrait.Expression.Subquery.SetComparison.ComparisonOp
 */
export enum Expression_Subquery_SetComparison_ComparisonOp {
  /**
   * @generated from enum value: COMPARISON_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: COMPARISON_OP_EQ = 1;
   */
  EQ = 1,

  /**
   * @generated from enum value: COMPARISON_OP_NE = 2;
   */
  NE = 2,

  /**
   * @generated from enum value: COMPARISON_OP_LT = 3;
   */
  LT = 3,

  /**
   * @generated from enum value: COMPARISON_OP_GT = 4;
   */
  GT = 4,

  /**
   * @generated from enum value: COMPARISON_OP_LE = 5;
   */
  LE = 5,

  /**
   * @generated from enum value: COMPARISON_OP_GE = 6;
   */
  GE = 6,
}

/**
 * Describes the enum substrait.Expression.Subquery.SetComparison.ComparisonOp.
 */
export const Expression_Subquery_SetComparison_ComparisonOpSchema: GenEnum<Expression_Subquery_SetComparison_ComparisonOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 28, 14, 3, 0);

/**
 * @generated from enum substrait.Expression.Subquery.SetComparison.ReductionOp
 */
export enum Expression_Subquery_SetComparison_ReductionOp {
  /**
   * @generated from enum value: REDUCTION_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REDUCTION_OP_ANY = 1;
   */
  ANY = 1,

  /**
   * @generated from enum value: REDUCTION_OP_ALL = 2;
   */
  ALL = 2,
}

/**
 * Describes the enum substrait.Expression.Subquery.SetComparison.ReductionOp.
 */
export const Expression_Subquery_SetComparison_ReductionOpSchema: GenEnum<Expression_Subquery_SetComparison_ReductionOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 28, 14, 3, 1);

/**
 * The description of a field to sort on (including the direction of sorting and null semantics)
 *
 * @generated from message substrait.SortField
 */
export type SortField = Message<"substrait.SortField"> & {
  /**
   * @generated from field: substrait.Expression expr = 1;
   */
  expr?: Expression;

  /**
   * @generated from oneof substrait.SortField.sort_kind
   */
  sortKind: {
    /**
     * @generated from field: substrait.SortField.SortDirection direction = 2;
     */
    value: SortField_SortDirection;
    case: "direction";
  } | {
    /**
     * @generated from field: uint32 comparison_function_reference = 3;
     */
    value: number;
    case: "comparisonFunctionReference";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.SortField.
 * Use `create(SortFieldSchema)` to create a new message.
 */
export const SortFieldSchema: GenMessage<SortField> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 29);

/**
 * @generated from enum substrait.SortField.SortDirection
 */
export enum SortField_SortDirection {
  /**
   * @generated from enum value: SORT_DIRECTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SORT_DIRECTION_ASC_NULLS_FIRST = 1;
   */
  ASC_NULLS_FIRST = 1,

  /**
   * @generated from enum value: SORT_DIRECTION_ASC_NULLS_LAST = 2;
   */
  ASC_NULLS_LAST = 2,

  /**
   * @generated from enum value: SORT_DIRECTION_DESC_NULLS_FIRST = 3;
   */
  DESC_NULLS_FIRST = 3,

  /**
   * @generated from enum value: SORT_DIRECTION_DESC_NULLS_LAST = 4;
   */
  DESC_NULLS_LAST = 4,

  /**
   * @generated from enum value: SORT_DIRECTION_CLUSTERED = 5;
   */
  CLUSTERED = 5,
}

/**
 * Describes the enum substrait.SortField.SortDirection.
 */
export const SortField_SortDirectionSchema: GenEnum<SortField_SortDirection> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 29, 0);

/**
 * An aggregate function.
 *
 * @generated from message substrait.AggregateFunction
 */
export type AggregateFunction = Message<"substrait.AggregateFunction"> & {
  /**
   * Points to a function_anchor defined in this plan, which must refer
   * to an aggregate function in the associated YAML file. Required; 0 is
   * considered to be a valid anchor/reference.
   *
   * @generated from field: uint32 function_reference = 1;
   */
  functionReference: number;

  /**
   * The arguments to be bound to the function. This must have exactly the
   * number of arguments specified in the function definition, and the
   * argument types must also match exactly:
   *
   *  - Value arguments must be bound using FunctionArgument.value, and
   *    the expression in that must yield a value of a type that a function
   *    overload is defined for.
   *  - Type arguments must be bound using FunctionArgument.type, and a
   *    function overload must be defined for that type.
   *  - Enum arguments must be bound using FunctionArgument.enum
   *    followed by Enum.specified, with a string that case-insensitively
   *    matches one of the allowed options.
   *  - Optional enum arguments must be bound using FunctionArgument.enum
   *    followed by either Enum.specified or Enum.unspecified. If specified,
   *    the string must case-insensitively match one of the allowed options.
   *
   * @generated from field: repeated substrait.FunctionArgument arguments = 7;
   */
  arguments: FunctionArgument[];

  /**
   * Options to specify behavior for corner cases, or leave behavior
   * unspecified if the consumer does not need specific behavior in these
   * cases.
   *
   * @generated from field: repeated substrait.FunctionOption options = 8;
   */
  options: FunctionOption[];

  /**
   * Must be set to the return type of the function, exactly as derived
   * using the declaration in the extension.
   *
   * @generated from field: substrait.Type output_type = 5;
   */
  outputType?: Type;

  /**
   * Describes which part of the aggregation to perform within the context of
   * distributed algorithms. Required. Must be set to INITIAL_TO_RESULT for
   * aggregate functions that are not decomposable.
   *
   * @generated from field: substrait.AggregationPhase phase = 4;
   */
  phase: AggregationPhase;

  /**
   * If specified, the aggregated records are ordered according to this list
   * before they are aggregated. The first sort field has the highest
   * priority; only if a sort field determines two records to be equivalent is
   * the next field queried. This field is optional.
   *
   * @generated from field: repeated substrait.SortField sorts = 3;
   */
  sorts: SortField[];

  /**
   * Specifies whether equivalent records are merged before being aggregated.
   * Optional, defaults to AGGREGATION_INVOCATION_ALL.
   *
   * @generated from field: substrait.AggregateFunction.AggregationInvocation invocation = 6;
   */
  invocation: AggregateFunction_AggregationInvocation;

  /**
   * deprecated; use arguments instead
   *
   * @generated from field: repeated substrait.Expression args = 2 [deprecated = true];
   * @deprecated
   */
  args: Expression[];
};

/**
 * Describes the message substrait.AggregateFunction.
 * Use `create(AggregateFunctionSchema)` to create a new message.
 */
export const AggregateFunctionSchema: GenMessage<AggregateFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30);

/**
 * Method in which equivalent records are merged before being aggregated.
 *
 * @generated from enum substrait.AggregateFunction.AggregationInvocation
 */
export enum AggregateFunction_AggregationInvocation {
  /**
   * This default value implies AGGREGATION_INVOCATION_ALL.
   *
   * @generated from enum value: AGGREGATION_INVOCATION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Use all values in the aggregation calculation.
   *
   * @generated from enum value: AGGREGATION_INVOCATION_ALL = 1;
   */
  ALL = 1,

  /**
   * Use only distinct values in the aggregation calculation.
   *
   * @generated from enum value: AGGREGATION_INVOCATION_DISTINCT = 2;
   */
  DISTINCT = 2,
}

/**
 * Describes the enum substrait.AggregateFunction.AggregationInvocation.
 */
export const AggregateFunction_AggregationInvocationSchema: GenEnum<AggregateFunction_AggregationInvocation> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 30, 0);

/**
 * This rel is used  to create references,
 * in case we refer to a RelRoot field names will be ignored
 *
 * @generated from message substrait.ReferenceRel
 */
export type ReferenceRel = Message<"substrait.ReferenceRel"> & {
  /**
   * @generated from field: int32 subtree_ordinal = 1;
   */
  subtreeOrdinal: number;
};

/**
 * Describes the message substrait.ReferenceRel.
 * Use `create(ReferenceRelSchema)` to create a new message.
 */
export const ReferenceRelSchema: GenMessage<ReferenceRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 31);

/**
 * Describes which part of an aggregation or window function to perform within
 * the context of distributed algorithms.
 *
 * @generated from enum substrait.AggregationPhase
 */
export enum AggregationPhase {
  /**
   * Implies `INTERMEDIATE_TO_RESULT`.
   *
   * @generated from enum value: AGGREGATION_PHASE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Specifies that the function should be run only up to the point of
   * generating an intermediate value, to be further aggregated later using
   * INTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.
   *
   * @generated from enum value: AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE = 1;
   */
  INITIAL_TO_INTERMEDIATE = 1,

  /**
   * Specifies that the inputs of the aggregate or window function are the
   * intermediate values of the function, and that the output should also be
   * an intermediate value, to be further aggregated later using
   * INTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.
   *
   * @generated from enum value: AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE = 2;
   */
  INTERMEDIATE_TO_INTERMEDIATE = 2,

  /**
   * A complete invocation: the function should aggregate the given set of
   * inputs to yield a single return value. This style must be used for
   * aggregate or window functions that are not decomposable.
   *
   * @generated from enum value: AGGREGATION_PHASE_INITIAL_TO_RESULT = 3;
   */
  INITIAL_TO_RESULT = 3,

  /**
   * Specifies that the inputs of the aggregate or window function are the
   * intermediate values of the function, generated previously using
   * INITIAL_TO_INTERMEDIATE and possibly INTERMEDIATE_TO_INTERMEDIATE calls.
   * This call should combine the intermediate values to yield the final
   * return value.
   *
   * @generated from enum value: AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT = 4;
   */
  INTERMEDIATE_TO_RESULT = 4,
}

/**
 * Describes the enum substrait.AggregationPhase.
 */
export const AggregationPhaseSchema: GenEnum<AggregationPhase> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 0);

