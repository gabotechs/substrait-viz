// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file substrait/algebra.proto (package substrait, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Any } from "../google/protobuf/any_pb";
import { file_google_protobuf_any } from "../google/protobuf/any_pb";
import type { AdvancedExtension } from "./extensions/extensions_pb";
import { file_substrait_extensions_extensions } from "./extensions/extensions_pb";
import type { NamedStruct, Type, Type_List, Type_Map, Type_Parameter } from "./type_pb";
import { file_substrait_type } from "./type_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file substrait/algebra.proto.
 */
export const file_substrait_algebra: GenFile = /*@__PURE__*/
  fileDesc("ChdzdWJzdHJhaXQvYWxnZWJyYS5wcm90bxIJc3Vic3RyYWl0Ir0JCglSZWxDb21tb24SLQoGZGlyZWN0GAEgASgLMhsuc3Vic3RyYWl0LlJlbENvbW1vbi5EaXJlY3RIABIpCgRlbWl0GAIgASgLMhkuc3Vic3RyYWl0LlJlbENvbW1vbi5FbWl0SAASJwoEaGludBgDIAEoCzIZLnN1YnN0cmFpdC5SZWxDb21tb24uSGludBJDChJhZHZhbmNlZF9leHRlbnNpb24YBCABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhoICgZEaXJlY3QaHgoERW1pdBIWCg5vdXRwdXRfbWFwcGluZxgBIAMoBRqwBwoESGludBIuCgVzdGF0cxgBIAEoCzIfLnN1YnN0cmFpdC5SZWxDb21tb24uSGludC5TdGF0cxI/Cgpjb25zdHJhaW50GAIgASgLMisuc3Vic3RyYWl0LlJlbENvbW1vbi5IaW50LlJ1bnRpbWVDb25zdHJhaW50Eg0KBWFsaWFzGAMgASgJEhQKDG91dHB1dF9uYW1lcxgEIAMoCRJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhJGChJzYXZlZF9jb21wdXRhdGlvbnMYCyADKAsyKi5zdWJzdHJhaXQuUmVsQ29tbW9uLkhpbnQuU2F2ZWRDb21wdXRhdGlvbhJIChNsb2FkZWRfY29tcHV0YXRpb25zGAwgAygLMisuc3Vic3RyYWl0LlJlbENvbW1vbi5IaW50LkxvYWRlZENvbXB1dGF0aW9uGnQKBVN0YXRzEhEKCXJvd19jb3VudBgBIAEoARITCgtyZWNvcmRfc2l6ZRgCIAEoARJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhpYChFSdW50aW1lQ29uc3RyYWludBJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhpjChBTYXZlZENvbXB1dGF0aW9uEhYKDmNvbXB1dGF0aW9uX2lkGAEgASgFEjcKBHR5cGUYAiABKA4yKS5zdWJzdHJhaXQuUmVsQ29tbW9uLkhpbnQuQ29tcHV0YXRpb25UeXBlGm4KEUxvYWRlZENvbXB1dGF0aW9uEiAKGGNvbXB1dGF0aW9uX2lkX3JlZmVyZW5jZRgBIAEoBRI3CgR0eXBlGAIgASgOMikuc3Vic3RyYWl0LlJlbENvbW1vbi5IaW50LkNvbXB1dGF0aW9uVHlwZSKVAQoPQ29tcHV0YXRpb25UeXBlEiAKHENPTVBVVEFUSU9OX1RZUEVfVU5TUEVDSUZJRUQQABIeChpDT01QVVRBVElPTl9UWVBFX0hBU0hUQUJMRRABEiEKHUNPTVBVVEFUSU9OX1RZUEVfQkxPT01fRklMVEVSEAISHQoYQ09NUFVUQVRJT05fVFlQRV9VTktOT1dOEI9OQgsKCWVtaXRfa2luZCL+EAoHUmVhZFJlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEisKC2Jhc2Vfc2NoZW1hGAIgASgLMhYuc3Vic3RyYWl0Lk5hbWVkU3RydWN0EiUKBmZpbHRlchgDIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEjEKEmJlc3RfZWZmb3J0X2ZpbHRlchgLIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEjgKCnByb2plY3Rpb24YBCABKAsyJC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NYXNrRXhwcmVzc2lvbhJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhI4Cg12aXJ0dWFsX3RhYmxlGAUgASgLMh8uc3Vic3RyYWl0LlJlYWRSZWwuVmlydHVhbFRhYmxlSAASNAoLbG9jYWxfZmlsZXMYBiABKAsyHS5zdWJzdHJhaXQuUmVhZFJlbC5Mb2NhbEZpbGVzSAASNAoLbmFtZWRfdGFibGUYByABKAsyHS5zdWJzdHJhaXQuUmVhZFJlbC5OYW1lZFRhYmxlSAASPAoPZXh0ZW5zaW9uX3RhYmxlGAggASgLMiEuc3Vic3RyYWl0LlJlYWRSZWwuRXh0ZW5zaW9uVGFibGVIABI4Cg1pY2ViZXJnX3RhYmxlGAkgASgLMh8uc3Vic3RyYWl0LlJlYWRSZWwuSWNlYmVyZ1RhYmxlSAAaYAoKTmFtZWRUYWJsZRINCgVuYW1lcxgBIAMoCRJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhrLAQoMSWNlYmVyZ1RhYmxlEkIKBmRpcmVjdBgBIAEoCzIwLnN1YnN0cmFpdC5SZWFkUmVsLkljZWJlcmdUYWJsZS5NZXRhZGF0YUZpbGVSZWFkSAAaaQoQTWV0YWRhdGFGaWxlUmVhZBIUCgxtZXRhZGF0YV91cmkYASABKAkSFQoLc25hcHNob3RfaWQYAiABKAlIABIcChJzbmFwc2hvdF90aW1lc3RhbXAYAyABKANIAEIKCghzbmFwc2hvdEIMCgp0YWJsZV90eXBlGoIBCgxWaXJ0dWFsVGFibGUSOAoGdmFsdWVzGAEgAygLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5TdHJ1Y3RCAhgBEjgKC2V4cHJlc3Npb25zGAIgAygLMiMuc3Vic3RyYWl0LkV4cHJlc3Npb24uTmVzdGVkLlN0cnVjdBo2Cg5FeHRlbnNpb25UYWJsZRIkCgZkZXRhaWwYASABKAsyFC5nb29nbGUucHJvdG9idWYuQW55Gq4ICgpMb2NhbEZpbGVzEjgKBWl0ZW1zGAEgAygLMikuc3Vic3RyYWl0LlJlYWRSZWwuTG9jYWxGaWxlcy5GaWxlT3JGaWxlcxJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhqgBwoLRmlsZU9yRmlsZXMSEgoIdXJpX3BhdGgYASABKAlIABIXCg11cmlfcGF0aF9nbG9iGAIgASgJSAASEgoIdXJpX2ZpbGUYAyABKAlIABIUCgp1cmlfZm9sZGVyGAQgASgJSAASFwoPcGFydGl0aW9uX2luZGV4GAYgASgEEg0KBXN0YXJ0GAcgASgEEg4KBmxlbmd0aBgIIAEoBBJPCgdwYXJxdWV0GAkgASgLMjwuc3Vic3RyYWl0LlJlYWRSZWwuTG9jYWxGaWxlcy5GaWxlT3JGaWxlcy5QYXJxdWV0UmVhZE9wdGlvbnNIARJLCgVhcnJvdxgKIAEoCzI6LnN1YnN0cmFpdC5SZWFkUmVsLkxvY2FsRmlsZXMuRmlsZU9yRmlsZXMuQXJyb3dSZWFkT3B0aW9uc0gBEkcKA29yYxgLIAEoCzI4LnN1YnN0cmFpdC5SZWFkUmVsLkxvY2FsRmlsZXMuRmlsZU9yRmlsZXMuT3JjUmVhZE9wdGlvbnNIARIpCglleHRlbnNpb24YDCABKAsyFC5nb29nbGUucHJvdG9idWYuQW55SAESSQoEZHdyZhgNIAEoCzI5LnN1YnN0cmFpdC5SZWFkUmVsLkxvY2FsRmlsZXMuRmlsZU9yRmlsZXMuRHdyZlJlYWRPcHRpb25zSAESWwoEdGV4dBgOIAEoCzJLLnN1YnN0cmFpdC5SZWFkUmVsLkxvY2FsRmlsZXMuRmlsZU9yRmlsZXMuRGVsaW1pdGVyU2VwYXJhdGVkVGV4dFJlYWRPcHRpb25zSAEaFAoSUGFycXVldFJlYWRPcHRpb25zGhIKEEFycm93UmVhZE9wdGlvbnMaEAoOT3JjUmVhZE9wdGlvbnMaEQoPRHdyZlJlYWRPcHRpb25zGs4BCiFEZWxpbWl0ZXJTZXBhcmF0ZWRUZXh0UmVhZE9wdGlvbnMSFwoPZmllbGRfZGVsaW1pdGVyGAEgASgJEhUKDW1heF9saW5lX3NpemUYAiABKAQSDQoFcXVvdGUYAyABKAkSHAoUaGVhZGVyX2xpbmVzX3RvX3NraXAYBCABKAQSDgoGZXNjYXBlGAUgASgJEiIKFXZhbHVlX3RyZWF0ZWRfYXNfbnVsbBgGIAEoCUgAiAEBQhgKFl92YWx1ZV90cmVhdGVkX2FzX251bGxCCwoJcGF0aF90eXBlQg0KC2ZpbGVfZm9ybWF0SgQIBRAGUgZmb3JtYXRCCwoJcmVhZF90eXBlIsIBCgpQcm9qZWN0UmVsEiQKBmNvbW1vbhgBIAEoCzIULnN1YnN0cmFpdC5SZWxDb21tb24SHQoFaW5wdXQYAiABKAsyDi5zdWJzdHJhaXQuUmVsEioKC2V4cHJlc3Npb25zGAMgAygLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SQwoSYWR2YW5jZWRfZXh0ZW5zaW9uGAogASgLMicuc3Vic3RyYWl0LmV4dGVuc2lvbnMuQWR2YW5jZWRFeHRlbnNpb24igwUKB0pvaW5SZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIcCgRsZWZ0GAIgASgLMg4uc3Vic3RyYWl0LlJlbBIdCgVyaWdodBgDIAEoCzIOLnN1YnN0cmFpdC5SZWwSKQoKZXhwcmVzc2lvbhgEIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEi8KEHBvc3Rfam9pbl9maWx0ZXIYBSABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhIpCgR0eXBlGAYgASgOMhsuc3Vic3RyYWl0LkpvaW5SZWwuSm9pblR5cGUSQwoSYWR2YW5jZWRfZXh0ZW5zaW9uGAogASgLMicuc3Vic3RyYWl0LmV4dGVuc2lvbnMuQWR2YW5jZWRFeHRlbnNpb24iyAIKCEpvaW5UeXBlEhkKFUpPSU5fVFlQRV9VTlNQRUNJRklFRBAAEhMKD0pPSU5fVFlQRV9JTk5FUhABEhMKD0pPSU5fVFlQRV9PVVRFUhACEhIKDkpPSU5fVFlQRV9MRUZUEAMSEwoPSk9JTl9UWVBFX1JJR0hUEAQSFwoTSk9JTl9UWVBFX0xFRlRfU0VNSRAFEhcKE0pPSU5fVFlQRV9MRUZUX0FOVEkQBhIZChVKT0lOX1RZUEVfTEVGVF9TSU5HTEUQBxIYChRKT0lOX1RZUEVfUklHSFRfU0VNSRAIEhgKFEpPSU5fVFlQRV9SSUdIVF9BTlRJEAkSGgoWSk9JTl9UWVBFX1JJR0hUX1NJTkdMRRAKEhcKE0pPSU5fVFlQRV9MRUZUX01BUksQCxIYChRKT0lOX1RZUEVfUklHSFRfTUFSSxAMIrIBCghDcm9zc1JlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEhwKBGxlZnQYAiABKAsyDi5zdWJzdHJhaXQuUmVsEh0KBXJpZ2h0GAMgASgLMg4uc3Vic3RyYWl0LlJlbBJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbiK3AgoIRmV0Y2hSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSFAoGb2Zmc2V0GAMgASgDQgIYAUgAEiwKC29mZnNldF9leHByGAUgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb25IABITCgVjb3VudBgEIAEoA0ICGAFIARIrCgpjb3VudF9leHByGAYgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb25IARJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbkINCgtvZmZzZXRfbW9kZUIMCgpjb3VudF9tb2RlIvoDCgxBZ2dyZWdhdGVSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSMwoJZ3JvdXBpbmdzGAMgAygLMiAuc3Vic3RyYWl0LkFnZ3JlZ2F0ZVJlbC5Hcm91cGluZxIxCghtZWFzdXJlcxgEIAMoCzIfLnN1YnN0cmFpdC5BZ2dyZWdhdGVSZWwuTWVhc3VyZRIzChRncm91cGluZ19leHByZXNzaW9ucxgFIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgKIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uGmIKCEdyb3VwaW5nEjcKFGdyb3VwaW5nX2V4cHJlc3Npb25zGAEgAygLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb25CAhgBEh0KFWV4cHJlc3Npb25fcmVmZXJlbmNlcxgCIAMoDRpfCgdNZWFzdXJlEi0KB21lYXN1cmUYASABKAsyHC5zdWJzdHJhaXQuQWdncmVnYXRlRnVuY3Rpb24SJQoGZmlsdGVyGAIgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24iyAYKHENvbnNpc3RlbnRQYXJ0aXRpb25XaW5kb3dSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSUwoQd2luZG93X2Z1bmN0aW9ucxgDIAMoCzI5LnN1YnN0cmFpdC5Db25zaXN0ZW50UGFydGl0aW9uV2luZG93UmVsLldpbmRvd1JlbEZ1bmN0aW9uEjQKFXBhcnRpdGlvbl9leHByZXNzaW9ucxgEIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEiMKBXNvcnRzGAUgAygLMhQuc3Vic3RyYWl0LlNvcnRGaWVsZBJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbhrtAwoRV2luZG93UmVsRnVuY3Rpb24SGgoSZnVuY3Rpb25fcmVmZXJlbmNlGAEgASgNEi4KCWFyZ3VtZW50cxgJIAMoCzIbLnN1YnN0cmFpdC5GdW5jdGlvbkFyZ3VtZW50EioKB29wdGlvbnMYCyADKAsyGS5zdWJzdHJhaXQuRnVuY3Rpb25PcHRpb24SJAoLb3V0cHV0X3R5cGUYByABKAsyDy5zdWJzdHJhaXQuVHlwZRIqCgVwaGFzZRgGIAEoDjIbLnN1YnN0cmFpdC5BZ2dyZWdhdGlvblBoYXNlEkYKCmludm9jYXRpb24YCiABKA4yMi5zdWJzdHJhaXQuQWdncmVnYXRlRnVuY3Rpb24uQWdncmVnYXRpb25JbnZvY2F0aW9uEj8KC2xvd2VyX2JvdW5kGAUgASgLMiouc3Vic3RyYWl0LkV4cHJlc3Npb24uV2luZG93RnVuY3Rpb24uQm91bmQSPwoLdXBwZXJfYm91bmQYBCABKAsyKi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5XaW5kb3dGdW5jdGlvbi5Cb3VuZBJECgtib3VuZHNfdHlwZRgMIAEoDjIvLnN1YnN0cmFpdC5FeHByZXNzaW9uLldpbmRvd0Z1bmN0aW9uLkJvdW5kc1R5cGUiuAEKB1NvcnRSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSIwoFc29ydHMYAyADKAsyFC5zdWJzdHJhaXQuU29ydEZpZWxkEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgKIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uIr8BCglGaWx0ZXJSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSKAoJY29uZGl0aW9uGAMgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SQwoSYWR2YW5jZWRfZXh0ZW5zaW9uGAogASgLMicuc3Vic3RyYWl0LmV4dGVuc2lvbnMuQWR2YW5jZWRFeHRlbnNpb24ixwMKBlNldFJlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEh4KBmlucHV0cxgCIAMoCzIOLnN1YnN0cmFpdC5SZWwSIwoCb3AYAyABKA4yFy5zdWJzdHJhaXQuU2V0UmVsLlNldE9wEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgKIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uIowCCgVTZXRPcBIWChJTRVRfT1BfVU5TUEVDSUZJRUQQABIYChRTRVRfT1BfTUlOVVNfUFJJTUFSWRABEhwKGFNFVF9PUF9NSU5VU19QUklNQVJZX0FMTBAHEhkKFVNFVF9PUF9NSU5VU19NVUxUSVNFVBACEh8KG1NFVF9PUF9JTlRFUlNFQ1RJT05fUFJJTUFSWRADEiAKHFNFVF9PUF9JTlRFUlNFQ1RJT05fTVVMVElTRVQQBBIkCiBTRVRfT1BfSU5URVJTRUNUSU9OX01VTFRJU0VUX0FMTBAIEhkKFVNFVF9PUF9VTklPTl9ESVNUSU5DVBAFEhQKEFNFVF9PUF9VTklPTl9BTEwQBiJ/ChJFeHRlbnNpb25TaW5nbGVSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSJAoGZGV0YWlsGAMgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueSJeChBFeHRlbnNpb25MZWFmUmVsEiQKBmNvbW1vbhgBIAEoCzIULnN1YnN0cmFpdC5SZWxDb21tb24SJAoGZGV0YWlsGAIgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueSJ/ChFFeHRlbnNpb25NdWx0aVJlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEh4KBmlucHV0cxgCIAMoCzIOLnN1YnN0cmFpdC5SZWwSJAoGZGV0YWlsGAMgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueSLDBwoLRXhjaGFuZ2VSZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIdCgVpbnB1dBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSFwoPcGFydGl0aW9uX2NvdW50GAMgASgFEjYKB3RhcmdldHMYBCADKAsyJS5zdWJzdHJhaXQuRXhjaGFuZ2VSZWwuRXhjaGFuZ2VUYXJnZXQSQQoRc2NhdHRlcl9ieV9maWVsZHMYBSABKAsyJC5zdWJzdHJhaXQuRXhjaGFuZ2VSZWwuU2NhdHRlckZpZWxkc0gAEkYKDXNpbmdsZV90YXJnZXQYBiABKAsyLS5zdWJzdHJhaXQuRXhjaGFuZ2VSZWwuU2luZ2xlQnVja2V0RXhwcmVzc2lvbkgAEkQKDG11bHRpX3RhcmdldBgHIAEoCzIsLnN1YnN0cmFpdC5FeGNoYW5nZVJlbC5NdWx0aUJ1Y2tldEV4cHJlc3Npb25IABI4Cgtyb3VuZF9yb2JpbhgIIAEoCzIhLnN1YnN0cmFpdC5FeGNoYW5nZVJlbC5Sb3VuZFJvYmluSAASNQoJYnJvYWRjYXN0GAkgASgLMiAuc3Vic3RyYWl0LkV4Y2hhbmdlUmVsLkJyb2FkY2FzdEgAEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgKIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uGkUKDVNjYXR0ZXJGaWVsZHMSNAoGZmllbGRzGAEgAygLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uRmllbGRSZWZlcmVuY2UaQwoWU2luZ2xlQnVja2V0RXhwcmVzc2lvbhIpCgpleHByZXNzaW9uGAEgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24aYAoVTXVsdGlCdWNrZXRFeHByZXNzaW9uEikKCmV4cHJlc3Npb24YASABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhIcChRjb25zdHJhaW5lZF90b19jb3VudBgCIAEoCBoLCglCcm9hZGNhc3QaGwoKUm91bmRSb2JpbhINCgVleGFjdBgBIAEoCBpuCg5FeGNoYW5nZVRhcmdldBIUCgxwYXJ0aXRpb25faWQYASADKAUSDQoDdXJpGAIgASgJSAASKAoIZXh0ZW5kZWQYAyABKAsyFC5nb29nbGUucHJvdG9idWYuQW55SABCDQoLdGFyZ2V0X3R5cGVCDwoNZXhjaGFuZ2Vfa2luZCLQAgoJRXhwYW5kUmVsEiQKBmNvbW1vbhgBIAEoCzIULnN1YnN0cmFpdC5SZWxDb21tb24SHQoFaW5wdXQYAiABKAsyDi5zdWJzdHJhaXQuUmVsEjAKBmZpZWxkcxgEIAMoCzIgLnN1YnN0cmFpdC5FeHBhbmRSZWwuRXhwYW5kRmllbGQajgEKC0V4cGFuZEZpZWxkEj4KD3N3aXRjaGluZ19maWVsZBgCIAEoCzIjLnN1YnN0cmFpdC5FeHBhbmRSZWwuU3dpdGNoaW5nRmllbGRIABIxChBjb25zaXN0ZW50X2ZpZWxkGAMgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb25IAEIMCgpmaWVsZF90eXBlGjsKDlN3aXRjaGluZ0ZpZWxkEikKCmR1cGxpY2F0ZXMYASADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbiI3CgdSZWxSb290Eh0KBWlucHV0GAEgASgLMg4uc3Vic3RyYWl0LlJlbBINCgVuYW1lcxgCIAMoCSLZBwoDUmVsEiIKBHJlYWQYASABKAsyEi5zdWJzdHJhaXQuUmVhZFJlbEgAEiYKBmZpbHRlchgCIAEoCzIULnN1YnN0cmFpdC5GaWx0ZXJSZWxIABIkCgVmZXRjaBgDIAEoCzITLnN1YnN0cmFpdC5GZXRjaFJlbEgAEiwKCWFnZ3JlZ2F0ZRgEIAEoCzIXLnN1YnN0cmFpdC5BZ2dyZWdhdGVSZWxIABIiCgRzb3J0GAUgASgLMhIuc3Vic3RyYWl0LlNvcnRSZWxIABIiCgRqb2luGAYgASgLMhIuc3Vic3RyYWl0LkpvaW5SZWxIABIoCgdwcm9qZWN0GAcgASgLMhUuc3Vic3RyYWl0LlByb2plY3RSZWxIABIgCgNzZXQYCCABKAsyES5zdWJzdHJhaXQuU2V0UmVsSAASOQoQZXh0ZW5zaW9uX3NpbmdsZRgJIAEoCzIdLnN1YnN0cmFpdC5FeHRlbnNpb25TaW5nbGVSZWxIABI3Cg9leHRlbnNpb25fbXVsdGkYCiABKAsyHC5zdWJzdHJhaXQuRXh0ZW5zaW9uTXVsdGlSZWxIABI1Cg5leHRlbnNpb25fbGVhZhgLIAEoCzIbLnN1YnN0cmFpdC5FeHRlbnNpb25MZWFmUmVsSAASJAoFY3Jvc3MYDCABKAsyEy5zdWJzdHJhaXQuQ3Jvc3NSZWxIABIsCglyZWZlcmVuY2UYFSABKAsyFy5zdWJzdHJhaXQuUmVmZXJlbmNlUmVsSAASJAoFd3JpdGUYEyABKAsyEy5zdWJzdHJhaXQuV3JpdGVSZWxIABIgCgNkZGwYFCABKAsyES5zdWJzdHJhaXQuRGRsUmVsSAASJgoGdXBkYXRlGBYgASgLMhQuc3Vic3RyYWl0LlVwZGF0ZVJlbEgAEisKCWhhc2hfam9pbhgNIAEoCzIWLnN1YnN0cmFpdC5IYXNoSm9pblJlbEgAEi0KCm1lcmdlX2pvaW4YDiABKAsyFy5zdWJzdHJhaXQuTWVyZ2VKb2luUmVsSAASOAoQbmVzdGVkX2xvb3Bfam9pbhgSIAEoCzIcLnN1YnN0cmFpdC5OZXN0ZWRMb29wSm9pblJlbEgAEjkKBndpbmRvdxgRIAEoCzInLnN1YnN0cmFpdC5Db25zaXN0ZW50UGFydGl0aW9uV2luZG93UmVsSAASKgoIZXhjaGFuZ2UYDyABKAsyFi5zdWJzdHJhaXQuRXhjaGFuZ2VSZWxIABImCgZleHBhbmQYECABKAsyFC5zdWJzdHJhaXQuRXhwYW5kUmVsSABCCgoIcmVsX3R5cGUiZgoQTmFtZWRPYmplY3RXcml0ZRINCgVuYW1lcxgBIAMoCRJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbiI3Cg9FeHRlbnNpb25PYmplY3QSJAoGZGV0YWlsGAEgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueSK5BQoGRGRsUmVsEjMKDG5hbWVkX29iamVjdBgBIAEoCzIbLnN1YnN0cmFpdC5OYW1lZE9iamVjdFdyaXRlSAASNgoQZXh0ZW5zaW9uX29iamVjdBgCIAEoCzIaLnN1YnN0cmFpdC5FeHRlbnNpb25PYmplY3RIABIsCgx0YWJsZV9zY2hlbWEYAyABKAsyFi5zdWJzdHJhaXQuTmFtZWRTdHJ1Y3QSPAoOdGFibGVfZGVmYXVsdHMYBCABKAsyJC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsLlN0cnVjdBIrCgZvYmplY3QYBSABKA4yGy5zdWJzdHJhaXQuRGRsUmVsLkRkbE9iamVjdBIjCgJvcBgGIAEoDjIXLnN1YnN0cmFpdC5EZGxSZWwuRGRsT3ASJwoPdmlld19kZWZpbml0aW9uGAcgASgLMg4uc3Vic3RyYWl0LlJlbBIkCgZjb21tb24YCCABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgJIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uIlIKCURkbE9iamVjdBIaChZERExfT0JKRUNUX1VOU1BFQ0lGSUVEEAASFAoQRERMX09CSkVDVF9UQUJMRRABEhMKD0RETF9PQkpFQ1RfVklFVxACIo0BCgVEZGxPcBIWChJERExfT1BfVU5TUEVDSUZJRUQQABIRCg1ERExfT1BfQ1JFQVRFEAESHAoYRERMX09QX0NSRUFURV9PUl9SRVBMQUNFEAISEAoMRERMX09QX0FMVEVSEAMSDwoLRERMX09QX0RST1AQBBIYChRERExfT1BfRFJPUF9JRl9FWElTVBAFQgwKCndyaXRlX3R5cGUi3AYKCFdyaXRlUmVsEjIKC25hbWVkX3RhYmxlGAEgASgLMhsuc3Vic3RyYWl0Lk5hbWVkT2JqZWN0V3JpdGVIABI1Cg9leHRlbnNpb25fdGFibGUYAiABKAsyGi5zdWJzdHJhaXQuRXh0ZW5zaW9uT2JqZWN0SAASLAoMdGFibGVfc2NoZW1hGAMgASgLMhYuc3Vic3RyYWl0Lk5hbWVkU3RydWN0EicKAm9wGAQgASgOMhsuc3Vic3RyYWl0LldyaXRlUmVsLldyaXRlT3ASHQoFaW5wdXQYBSABKAsyDi5zdWJzdHJhaXQuUmVsEjMKC2NyZWF0ZV9tb2RlGAggASgOMh4uc3Vic3RyYWl0LldyaXRlUmVsLkNyZWF0ZU1vZGUSLgoGb3V0cHV0GAYgASgOMh4uc3Vic3RyYWl0LldyaXRlUmVsLk91dHB1dE1vZGUSJAoGY29tbW9uGAcgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhJDChJhZHZhbmNlZF9leHRlbnNpb24YCSABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbiJ1CgdXcml0ZU9wEhgKFFdSSVRFX09QX1VOU1BFQ0lGSUVEEAASEwoPV1JJVEVfT1BfSU5TRVJUEAESEwoPV1JJVEVfT1BfREVMRVRFEAISEwoPV1JJVEVfT1BfVVBEQVRFEAMSEQoNV1JJVEVfT1BfQ1RBUxAEIrEBCgpDcmVhdGVNb2RlEhsKF0NSRUFURV9NT0RFX1VOU1BFQ0lGSUVEEAASIAocQ1JFQVRFX01PREVfQVBQRU5EX0lGX0VYSVNUUxABEiEKHUNSRUFURV9NT0RFX1JFUExBQ0VfSUZfRVhJU1RTEAISIAocQ1JFQVRFX01PREVfSUdOT1JFX0lGX0VYSVNUUxADEh8KG0NSRUFURV9NT0RFX0VSUk9SX0lGX0VYSVNUUxAEImYKCk91dHB1dE1vZGUSGwoXT1VUUFVUX01PREVfVU5TUEVDSUZJRUQQABIZChVPVVRQVVRfTU9ERV9OT19PVVRQVVQQARIgChxPVVRQVVRfTU9ERV9NT0RJRklFRF9SRUNPUkRTEAJCDAoKd3JpdGVfdHlwZSKFAwoJVXBkYXRlUmVsEiwKC25hbWVkX3RhYmxlGAEgASgLMhUuc3Vic3RyYWl0Lk5hbWVkVGFibGVIABIsCgx0YWJsZV9zY2hlbWEYAiABKAsyFi5zdWJzdHJhaXQuTmFtZWRTdHJ1Y3QSKAoJY29uZGl0aW9uGAMgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SQQoPdHJhbnNmb3JtYXRpb25zGAQgAygLMiguc3Vic3RyYWl0LlVwZGF0ZVJlbC5UcmFuc2Zvcm1FeHByZXNzaW9uEkMKEmFkdmFuY2VkX2V4dGVuc2lvbhgFIAEoCzInLnN1YnN0cmFpdC5leHRlbnNpb25zLkFkdmFuY2VkRXh0ZW5zaW9uGlsKE1RyYW5zZm9ybUV4cHJlc3Npb24SLQoOdHJhbnNmb3JtYXRpb24YASABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhIVCg1jb2x1bW5fdGFyZ2V0GAIgASgFQg0KC3VwZGF0ZV90eXBlImAKCk5hbWVkVGFibGUSDQoFbmFtZXMYASADKAkSQwoSYWR2YW5jZWRfZXh0ZW5zaW9uGAogASgLMicuc3Vic3RyYWl0LmV4dGVuc2lvbnMuQWR2YW5jZWRFeHRlbnNpb24igQQKEUNvbXBhcmlzb25Kb2luS2V5EjIKBGxlZnQYASABKAsyJC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5GaWVsZFJlZmVyZW5jZRIzCgVyaWdodBgCIAEoCzIkLnN1YnN0cmFpdC5FeHByZXNzaW9uLkZpZWxkUmVmZXJlbmNlEj8KCmNvbXBhcmlzb24YAyABKAsyKy5zdWJzdHJhaXQuQ29tcGFyaXNvbkpvaW5LZXkuQ29tcGFyaXNvblR5cGUaiAEKDkNvbXBhcmlzb25UeXBlEkMKBnNpbXBsZRgBIAEoDjIxLnN1YnN0cmFpdC5Db21wYXJpc29uSm9pbktleS5TaW1wbGVDb21wYXJpc29uVHlwZUgAEiMKGWN1c3RvbV9mdW5jdGlvbl9yZWZlcmVuY2UYAiABKA1IAEIMCgppbm5lcl90eXBlIrYBChRTaW1wbGVDb21wYXJpc29uVHlwZRImCiJTSU1QTEVfQ09NUEFSSVNPTl9UWVBFX1VOU1BFQ0lGSUVEEAASHQoZU0lNUExFX0NPTVBBUklTT05fVFlQRV9FURABEi8KK1NJTVBMRV9DT01QQVJJU09OX1RZUEVfSVNfTk9UX0RJU1RJTkNUX0ZST00QAhImCiJTSU1QTEVfQ09NUEFSSVNPTl9UWVBFX01JR0hUX0VRVUFMEAMihwYKC0hhc2hKb2luUmVsEiQKBmNvbW1vbhgBIAEoCzIULnN1YnN0cmFpdC5SZWxDb21tb24SHAoEbGVmdBgCIAEoCzIOLnN1YnN0cmFpdC5SZWwSHQoFcmlnaHQYAyABKAsyDi5zdWJzdHJhaXQuUmVsEjsKCWxlZnRfa2V5cxgEIAMoCzIkLnN1YnN0cmFpdC5FeHByZXNzaW9uLkZpZWxkUmVmZXJlbmNlQgIYARI8CgpyaWdodF9rZXlzGAUgAygLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uRmllbGRSZWZlcmVuY2VCAhgBEioKBGtleXMYCCADKAsyHC5zdWJzdHJhaXQuQ29tcGFyaXNvbkpvaW5LZXkSLwoQcG9zdF9qb2luX2ZpbHRlchgGIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEi0KBHR5cGUYByABKA4yHy5zdWJzdHJhaXQuSGFzaEpvaW5SZWwuSm9pblR5cGUSQwoSYWR2YW5jZWRfZXh0ZW5zaW9uGAogASgLMicuc3Vic3RyYWl0LmV4dGVuc2lvbnMuQWR2YW5jZWRFeHRlbnNpb24iyAIKCEpvaW5UeXBlEhkKFUpPSU5fVFlQRV9VTlNQRUNJRklFRBAAEhMKD0pPSU5fVFlQRV9JTk5FUhABEhMKD0pPSU5fVFlQRV9PVVRFUhACEhIKDkpPSU5fVFlQRV9MRUZUEAMSEwoPSk9JTl9UWVBFX1JJR0hUEAQSFwoTSk9JTl9UWVBFX0xFRlRfU0VNSRAFEhgKFEpPSU5fVFlQRV9SSUdIVF9TRU1JEAYSFwoTSk9JTl9UWVBFX0xFRlRfQU5USRAHEhgKFEpPSU5fVFlQRV9SSUdIVF9BTlRJEAgSGQoVSk9JTl9UWVBFX0xFRlRfU0lOR0xFEAkSGgoWSk9JTl9UWVBFX1JJR0hUX1NJTkdMRRAKEhcKE0pPSU5fVFlQRV9MRUZUX01BUksQCxIYChRKT0lOX1RZUEVfUklHSFRfTUFSSxAMIokGCgxNZXJnZUpvaW5SZWwSJAoGY29tbW9uGAEgASgLMhQuc3Vic3RyYWl0LlJlbENvbW1vbhIcCgRsZWZ0GAIgASgLMg4uc3Vic3RyYWl0LlJlbBIdCgVyaWdodBgDIAEoCzIOLnN1YnN0cmFpdC5SZWwSOwoJbGVmdF9rZXlzGAQgAygLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uRmllbGRSZWZlcmVuY2VCAhgBEjwKCnJpZ2h0X2tleXMYBSADKAsyJC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5GaWVsZFJlZmVyZW5jZUICGAESKgoEa2V5cxgIIAMoCzIcLnN1YnN0cmFpdC5Db21wYXJpc29uSm9pbktleRIvChBwb3N0X2pvaW5fZmlsdGVyGAYgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SLgoEdHlwZRgHIAEoDjIgLnN1YnN0cmFpdC5NZXJnZUpvaW5SZWwuSm9pblR5cGUSQwoSYWR2YW5jZWRfZXh0ZW5zaW9uGAogASgLMicuc3Vic3RyYWl0LmV4dGVuc2lvbnMuQWR2YW5jZWRFeHRlbnNpb24iyAIKCEpvaW5UeXBlEhkKFUpPSU5fVFlQRV9VTlNQRUNJRklFRBAAEhMKD0pPSU5fVFlQRV9JTk5FUhABEhMKD0pPSU5fVFlQRV9PVVRFUhACEhIKDkpPSU5fVFlQRV9MRUZUEAMSEwoPSk9JTl9UWVBFX1JJR0hUEAQSFwoTSk9JTl9UWVBFX0xFRlRfU0VNSRAFEhgKFEpPSU5fVFlQRV9SSUdIVF9TRU1JEAYSFwoTSk9JTl9UWVBFX0xFRlRfQU5USRAHEhgKFEpPSU5fVFlQRV9SSUdIVF9BTlRJEAgSGQoVSk9JTl9UWVBFX0xFRlRfU0lOR0xFEAkSGgoWSk9JTl9UWVBFX1JJR0hUX1NJTkdMRRAKEhcKE0pPSU5fVFlQRV9MRUZUX01BUksQCxIYChRKT0lOX1RZUEVfUklHSFRfTUFSSxAMIuYEChFOZXN0ZWRMb29wSm9pblJlbBIkCgZjb21tb24YASABKAsyFC5zdWJzdHJhaXQuUmVsQ29tbW9uEhwKBGxlZnQYAiABKAsyDi5zdWJzdHJhaXQuUmVsEh0KBXJpZ2h0GAMgASgLMg4uc3Vic3RyYWl0LlJlbBIpCgpleHByZXNzaW9uGAQgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SMwoEdHlwZRgFIAEoDjIlLnN1YnN0cmFpdC5OZXN0ZWRMb29wSm9pblJlbC5Kb2luVHlwZRJDChJhZHZhbmNlZF9leHRlbnNpb24YCiABKAsyJy5zdWJzdHJhaXQuZXh0ZW5zaW9ucy5BZHZhbmNlZEV4dGVuc2lvbiLIAgoISm9pblR5cGUSGQoVSk9JTl9UWVBFX1VOU1BFQ0lGSUVEEAASEwoPSk9JTl9UWVBFX0lOTkVSEAESEwoPSk9JTl9UWVBFX09VVEVSEAISEgoOSk9JTl9UWVBFX0xFRlQQAxITCg9KT0lOX1RZUEVfUklHSFQQBBIXChNKT0lOX1RZUEVfTEVGVF9TRU1JEAUSGAoUSk9JTl9UWVBFX1JJR0hUX1NFTUkQBhIXChNKT0lOX1RZUEVfTEVGVF9BTlRJEAcSGAoUSk9JTl9UWVBFX1JJR0hUX0FOVEkQCBIZChVKT0lOX1RZUEVfTEVGVF9TSU5HTEUQCRIaChZKT0lOX1RZUEVfUklHSFRfU0lOR0xFEAoSFwoTSk9JTl9UWVBFX0xFRlRfTUFSSxALEhgKFEpPSU5fVFlQRV9SSUdIVF9NQVJLEAwidwoQRnVuY3Rpb25Bcmd1bWVudBIOCgRlbnVtGAEgASgJSAASHwoEdHlwZRgCIAEoCzIPLnN1YnN0cmFpdC5UeXBlSAASJgoFdmFsdWUYAyABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbkgAQgoKCGFyZ190eXBlIjIKDkZ1bmN0aW9uT3B0aW9uEgwKBG5hbWUYASABKAkSEgoKcHJlZmVyZW5jZRgCIAMoCSKZTAoKRXhwcmVzc2lvbhIwCgdsaXRlcmFsGAEgASgLMh0uc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbEgAEjkKCXNlbGVjdGlvbhgCIAEoCzIkLnN1YnN0cmFpdC5FeHByZXNzaW9uLkZpZWxkUmVmZXJlbmNlSAASPwoPc2NhbGFyX2Z1bmN0aW9uGAMgASgLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uU2NhbGFyRnVuY3Rpb25IABI/Cg93aW5kb3dfZnVuY3Rpb24YBSABKAsyJC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5XaW5kb3dGdW5jdGlvbkgAEi8KB2lmX3RoZW4YBiABKAsyHC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5JZlRoZW5IABJDChFzd2l0Y2hfZXhwcmVzc2lvbhgHIAEoCzImLnN1YnN0cmFpdC5FeHByZXNzaW9uLlN3aXRjaEV4cHJlc3Npb25IABJAChBzaW5ndWxhcl9vcl9saXN0GAggASgLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uU2luZ3VsYXJPckxpc3RIABI6Cg1tdWx0aV9vcl9saXN0GAkgASgLMiEuc3Vic3RyYWl0LkV4cHJlc3Npb24uTXVsdGlPckxpc3RIABIqCgRjYXN0GAsgASgLMhouc3Vic3RyYWl0LkV4cHJlc3Npb24uQ2FzdEgAEjIKCHN1YnF1ZXJ5GAwgASgLMh4uc3Vic3RyYWl0LkV4cHJlc3Npb24uU3VicXVlcnlIABIuCgZuZXN0ZWQYDSABKAsyHC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5OZXN0ZWRIABI4ChFkeW5hbWljX3BhcmFtZXRlchgOIAEoCzIbLnN1YnN0cmFpdC5EeW5hbWljUGFyYW1ldGVySAASLgoEZW51bRgKIAEoCzIaLnN1YnN0cmFpdC5FeHByZXNzaW9uLkVudW1CAhgBSAAacgoERW51bRITCglzcGVjaWZpZWQYASABKAlIABI3Cgt1bnNwZWNpZmllZBgCIAEoCzIgLnN1YnN0cmFpdC5FeHByZXNzaW9uLkVudW0uRW1wdHlIABoLCgVFbXB0eToCGAE6AhgBQgsKCWVudW1fa2luZBrYEQoHTGl0ZXJhbBIRCgdib29sZWFuGAEgASgISAASDAoCaTgYAiABKAVIABINCgNpMTYYAyABKAVIABINCgNpMzIYBSABKAVIABINCgNpNjQYByABKANIABIOCgRmcDMyGAogASgCSAASDgoEZnA2NBgLIAEoAUgAEhAKBnN0cmluZxgMIAEoCUgAEhAKBmJpbmFyeRgNIAEoDEgAEhcKCXRpbWVzdGFtcBgOIAEoA0ICGAFIABIOCgRkYXRlGBAgASgFSAASDgoEdGltZRgRIAEoA0gAElMKFmludGVydmFsX3llYXJfdG9fbW9udGgYEyABKAsyMS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsLkludGVydmFsWWVhclRvTW9udGhIABJTChZpbnRlcnZhbF9kYXlfdG9fc2Vjb25kGBQgASgLMjEuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5JbnRlcnZhbERheVRvU2Vjb25kSAASSwoRaW50ZXJ2YWxfY29tcG91bmQYJCABKAsyLi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsLkludGVydmFsQ29tcG91bmRIABIUCgpmaXhlZF9jaGFyGBUgASgJSAASOQoIdmFyX2NoYXIYFiABKAsyJS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsLlZhckNoYXJIABIWCgxmaXhlZF9iaW5hcnkYFyABKAxIABI4CgdkZWNpbWFsGBggASgLMiUuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5EZWNpbWFsSAASTwoTcHJlY2lzaW9uX3RpbWVzdGFtcBgiIAEoCzIwLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwuUHJlY2lzaW9uVGltZXN0YW1wSAASUgoWcHJlY2lzaW9uX3RpbWVzdGFtcF90ehgjIAEoCzIwLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwuUHJlY2lzaW9uVGltZXN0YW1wSAASNgoGc3RydWN0GBkgASgLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5TdHJ1Y3RIABIwCgNtYXAYGiABKAsyIS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsLk1hcEgAEhoKDHRpbWVzdGFtcF90ehgbIAEoA0ICGAFIABIOCgR1dWlkGBwgASgMSAASHwoEbnVsbBgdIAEoCzIPLnN1YnN0cmFpdC5UeXBlSAASMgoEbGlzdBgeIAEoCzIiLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwuTGlzdEgAEioKCmVtcHR5X2xpc3QYHyABKAsyFC5zdWJzdHJhaXQuVHlwZS5MaXN0SAASKAoJZW1wdHlfbWFwGCAgASgLMhMuc3Vic3RyYWl0LlR5cGUuTWFwSAASQQoMdXNlcl9kZWZpbmVkGCEgASgLMikuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5Vc2VyRGVmaW5lZEgAEhAKCG51bGxhYmxlGDIgASgIEiAKGHR5cGVfdmFyaWF0aW9uX3JlZmVyZW5jZRgzIAEoDRooCgdWYXJDaGFyEg0KBXZhbHVlGAEgASgJEg4KBmxlbmd0aBgCIAEoDRo6CgdEZWNpbWFsEg0KBXZhbHVlGAEgASgMEhEKCXByZWNpc2lvbhgCIAEoBRINCgVzY2FsZRgDIAEoBRo2ChJQcmVjaXNpb25UaW1lc3RhbXASEQoJcHJlY2lzaW9uGAEgASgFEg0KBXZhbHVlGAIgASgDGqsBCgNNYXASPgoKa2V5X3ZhbHVlcxgBIAMoCzIqLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwuTWFwLktleVZhbHVlGmQKCEtleVZhbHVlEioKA2tleRgBIAEoCzIdLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwSLAoFdmFsdWUYAiABKAsyHS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsGjQKE0ludGVydmFsWWVhclRvTW9udGgSDQoFeWVhcnMYASABKAUSDgoGbW9udGhzGAIgASgFGosBChNJbnRlcnZhbERheVRvU2Vjb25kEgwKBGRheXMYASABKAUSDwoHc2Vjb25kcxgCIAEoBRIaCgxtaWNyb3NlY29uZHMYAyABKAVCAhgBSAASEwoJcHJlY2lzaW9uGAQgASgFSAASEgoKc3Vic2Vjb25kcxgFIAEoA0IQCg5wcmVjaXNpb25fbW9kZRq4AQoQSW50ZXJ2YWxDb21wb3VuZBJRChZpbnRlcnZhbF95ZWFyX3RvX21vbnRoGAEgASgLMjEuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5JbnRlcnZhbFllYXJUb01vbnRoElEKFmludGVydmFsX2RheV90b19zZWNvbmQYAiABKAsyMS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsLkludGVydmFsRGF5VG9TZWNvbmQaNwoGU3RydWN0Ei0KBmZpZWxkcxgBIAMoCzIdLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwaNQoETGlzdBItCgZ2YWx1ZXMYASADKAsyHS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5MaXRlcmFsGr8BCgtVc2VyRGVmaW5lZBIWCg50eXBlX3JlZmVyZW5jZRgBIAEoDRIyCg90eXBlX3BhcmFtZXRlcnMYAyADKAsyGS5zdWJzdHJhaXQuVHlwZS5QYXJhbWV0ZXISJQoFdmFsdWUYAiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55SAASNgoGc3RydWN0GAQgASgLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uTGl0ZXJhbC5TdHJ1Y3RIAEIFCgN2YWxCDgoMbGl0ZXJhbF90eXBlGuMDCgZOZXN0ZWQSEAoIbnVsbGFibGUYASABKAgSIAoYdHlwZV92YXJpYXRpb25fcmVmZXJlbmNlGAIgASgNEjUKBnN0cnVjdBgDIAEoCzIjLnN1YnN0cmFpdC5FeHByZXNzaW9uLk5lc3RlZC5TdHJ1Y3RIABIxCgRsaXN0GAQgASgLMiEuc3Vic3RyYWl0LkV4cHJlc3Npb24uTmVzdGVkLkxpc3RIABIvCgNtYXAYBSABKAsyIC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5OZXN0ZWQuTWFwSAAamgEKA01hcBI9CgprZXlfdmFsdWVzGAEgAygLMikuc3Vic3RyYWl0LkV4cHJlc3Npb24uTmVzdGVkLk1hcC5LZXlWYWx1ZRpUCghLZXlWYWx1ZRIiCgNrZXkYASABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhIkCgV2YWx1ZRgCIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uGi8KBlN0cnVjdBIlCgZmaWVsZHMYASADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhotCgRMaXN0EiUKBnZhbHVlcxgBIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uQg0KC25lc3RlZF90eXBlGtcBCg5TY2FsYXJGdW5jdGlvbhIaChJmdW5jdGlvbl9yZWZlcmVuY2UYASABKA0SLgoJYXJndW1lbnRzGAQgAygLMhsuc3Vic3RyYWl0LkZ1bmN0aW9uQXJndW1lbnQSKgoHb3B0aW9ucxgFIAMoCzIZLnN1YnN0cmFpdC5GdW5jdGlvbk9wdGlvbhIkCgtvdXRwdXRfdHlwZRgDIAEoCzIPLnN1YnN0cmFpdC5UeXBlEicKBGFyZ3MYAiADKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbkICGAEa0QgKDldpbmRvd0Z1bmN0aW9uEhoKEmZ1bmN0aW9uX3JlZmVyZW5jZRgBIAEoDRIuCglhcmd1bWVudHMYCSADKAsyGy5zdWJzdHJhaXQuRnVuY3Rpb25Bcmd1bWVudBIqCgdvcHRpb25zGAsgAygLMhkuc3Vic3RyYWl0LkZ1bmN0aW9uT3B0aW9uEiQKC291dHB1dF90eXBlGAcgASgLMg8uc3Vic3RyYWl0LlR5cGUSKgoFcGhhc2UYBiABKA4yGy5zdWJzdHJhaXQuQWdncmVnYXRpb25QaGFzZRIjCgVzb3J0cxgDIAMoCzIULnN1YnN0cmFpdC5Tb3J0RmllbGQSRgoKaW52b2NhdGlvbhgKIAEoDjIyLnN1YnN0cmFpdC5BZ2dyZWdhdGVGdW5jdGlvbi5BZ2dyZWdhdGlvbkludm9jYXRpb24SKQoKcGFydGl0aW9ucxgCIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEkQKC2JvdW5kc190eXBlGAwgASgOMi8uc3Vic3RyYWl0LkV4cHJlc3Npb24uV2luZG93RnVuY3Rpb24uQm91bmRzVHlwZRI/Cgtsb3dlcl9ib3VuZBgFIAEoCzIqLnN1YnN0cmFpdC5FeHByZXNzaW9uLldpbmRvd0Z1bmN0aW9uLkJvdW5kEj8KC3VwcGVyX2JvdW5kGAQgASgLMiouc3Vic3RyYWl0LkV4cHJlc3Npb24uV2luZG93RnVuY3Rpb24uQm91bmQSJwoEYXJncxgIIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uQgIYARqTAwoFQm91bmQSSQoJcHJlY2VkaW5nGAEgASgLMjQuc3Vic3RyYWl0LkV4cHJlc3Npb24uV2luZG93RnVuY3Rpb24uQm91bmQuUHJlY2VkaW5nSAASSQoJZm9sbG93aW5nGAIgASgLMjQuc3Vic3RyYWl0LkV4cHJlc3Npb24uV2luZG93RnVuY3Rpb24uQm91bmQuRm9sbG93aW5nSAASTAoLY3VycmVudF9yb3cYAyABKAsyNS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5XaW5kb3dGdW5jdGlvbi5Cb3VuZC5DdXJyZW50Um93SAASSQoJdW5ib3VuZGVkGAQgASgLMjQuc3Vic3RyYWl0LkV4cHJlc3Npb24uV2luZG93RnVuY3Rpb24uQm91bmQuVW5ib3VuZGVkSAAaGwoJUHJlY2VkaW5nEg4KBm9mZnNldBgBIAEoAxobCglGb2xsb3dpbmcSDgoGb2Zmc2V0GAEgASgDGgwKCkN1cnJlbnRSb3caCwoJVW5ib3VuZGVkQgYKBGtpbmQiVgoKQm91bmRzVHlwZRIbChdCT1VORFNfVFlQRV9VTlNQRUNJRklFRBAAEhQKEEJPVU5EU19UWVBFX1JPV1MQARIVChFCT1VORFNfVFlQRV9SQU5HRRACGrUBCgZJZlRoZW4SMgoDaWZzGAEgAygLMiUuc3Vic3RyYWl0LkV4cHJlc3Npb24uSWZUaGVuLklmQ2xhdXNlEiMKBGVsc2UYAiABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhpSCghJZkNsYXVzZRIhCgJpZhgBIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEiMKBHRoZW4YAiABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhqOAgoEQ2FzdBIdCgR0eXBlGAEgASgLMg8uc3Vic3RyYWl0LlR5cGUSJAoFaW5wdXQYAiABKAsyFS5zdWJzdHJhaXQuRXhwcmVzc2lvbhJEChBmYWlsdXJlX2JlaGF2aW9yGAMgASgOMiouc3Vic3RyYWl0LkV4cHJlc3Npb24uQ2FzdC5GYWlsdXJlQmVoYXZpb3IiewoPRmFpbHVyZUJlaGF2aW9yEiAKHEZBSUxVUkVfQkVIQVZJT1JfVU5TUEVDSUZJRUQQABIgChxGQUlMVVJFX0JFSEFWSU9SX1JFVFVSTl9OVUxMEAESJAogRkFJTFVSRV9CRUhBVklPUl9USFJPV19FWENFUFRJT04QAhr1AQoQU3dpdGNoRXhwcmVzc2lvbhIkCgVtYXRjaBgDIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEjsKA2lmcxgBIAMoCzIuLnN1YnN0cmFpdC5FeHByZXNzaW9uLlN3aXRjaEV4cHJlc3Npb24uSWZWYWx1ZRIjCgRlbHNlGAIgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24aWQoHSWZWYWx1ZRIpCgJpZhgBIAEoCzIdLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwSIwoEdGhlbhgCIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uGl4KDlNpbmd1bGFyT3JMaXN0EiQKBXZhbHVlGAEgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SJgoHb3B0aW9ucxgCIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uGp8BCgtNdWx0aU9yTGlzdBIkCgV2YWx1ZRgBIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEjkKB29wdGlvbnMYAiADKAsyKC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NdWx0aU9yTGlzdC5SZWNvcmQaLwoGUmVjb3JkEiUKBmZpZWxkcxgBIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uGqMDChBFbWJlZGRlZEZ1bmN0aW9uEigKCWFyZ3VtZW50cxgBIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEiQKC291dHB1dF90eXBlGAIgASgLMg8uc3Vic3RyYWl0LlR5cGUSXQoWcHl0aG9uX3BpY2tsZV9mdW5jdGlvbhgDIAEoCzI7LnN1YnN0cmFpdC5FeHByZXNzaW9uLkVtYmVkZGVkRnVuY3Rpb24uUHl0aG9uUGlja2xlRnVuY3Rpb25IABJbChV3ZWJfYXNzZW1ibHlfZnVuY3Rpb24YBCABKAsyOi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5FbWJlZGRlZEZ1bmN0aW9uLldlYkFzc2VtYmx5RnVuY3Rpb25IABo+ChRQeXRob25QaWNrbGVGdW5jdGlvbhIQCghmdW5jdGlvbhgBIAEoDBIUCgxwcmVyZXF1aXNpdGUYAiADKAkaOwoTV2ViQXNzZW1ibHlGdW5jdGlvbhIOCgZzY3JpcHQYASABKAwSFAoMcHJlcmVxdWlzaXRlGAIgAygJQgYKBGtpbmQamgQKEFJlZmVyZW5jZVNlZ21lbnQSQAoHbWFwX2tleRgBIAEoCzItLnN1YnN0cmFpdC5FeHByZXNzaW9uLlJlZmVyZW5jZVNlZ21lbnQuTWFwS2V5SAASSgoMc3RydWN0X2ZpZWxkGAIgASgLMjIuc3Vic3RyYWl0LkV4cHJlc3Npb24uUmVmZXJlbmNlU2VnbWVudC5TdHJ1Y3RGaWVsZEgAEkoKDGxpc3RfZWxlbWVudBgDIAEoCzIyLnN1YnN0cmFpdC5FeHByZXNzaW9uLlJlZmVyZW5jZVNlZ21lbnQuTGlzdEVsZW1lbnRIABpvCgZNYXBLZXkSLgoHbWFwX2tleRgBIAEoCzIdLnN1YnN0cmFpdC5FeHByZXNzaW9uLkxpdGVyYWwSNQoFY2hpbGQYAiABKAsyJi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5SZWZlcmVuY2VTZWdtZW50GlMKC1N0cnVjdEZpZWxkEg0KBWZpZWxkGAEgASgFEjUKBWNoaWxkGAIgASgLMiYuc3Vic3RyYWl0LkV4cHJlc3Npb24uUmVmZXJlbmNlU2VnbWVudBpUCgtMaXN0RWxlbWVudBIOCgZvZmZzZXQYASABKAUSNQoFY2hpbGQYAiABKAsyJi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5SZWZlcmVuY2VTZWdtZW50QhAKDnJlZmVyZW5jZV90eXBlGvAJCg5NYXNrRXhwcmVzc2lvbhJBCgZzZWxlY3QYASABKAsyMS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NYXNrRXhwcmVzc2lvbi5TdHJ1Y3RTZWxlY3QSIAoYbWFpbnRhaW5fc2luZ3VsYXJfc3RydWN0GAIgASgIGtUBCgZTZWxlY3QSQwoGc3RydWN0GAEgASgLMjEuc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb24uU3RydWN0U2VsZWN0SAASPwoEbGlzdBgCIAEoCzIvLnN1YnN0cmFpdC5FeHByZXNzaW9uLk1hc2tFeHByZXNzaW9uLkxpc3RTZWxlY3RIABI9CgNtYXAYAyABKAsyLi5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NYXNrRXhwcmVzc2lvbi5NYXBTZWxlY3RIAEIGCgR0eXBlGlUKDFN0cnVjdFNlbGVjdBJFCgxzdHJ1Y3RfaXRlbXMYASADKAsyLy5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NYXNrRXhwcmVzc2lvbi5TdHJ1Y3RJdGVtGlcKClN0cnVjdEl0ZW0SDQoFZmllbGQYASABKAUSOgoFY2hpbGQYAiABKAsyKy5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NYXNrRXhwcmVzc2lvbi5TZWxlY3QatAMKCkxpc3RTZWxlY3QSUQoJc2VsZWN0aW9uGAEgAygLMj4uc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb24uTGlzdFNlbGVjdC5MaXN0U2VsZWN0SXRlbRI6CgVjaGlsZBgCIAEoCzIrLnN1YnN0cmFpdC5FeHByZXNzaW9uLk1hc2tFeHByZXNzaW9uLlNlbGVjdBqWAgoOTGlzdFNlbGVjdEl0ZW0SWgoEaXRlbRgBIAEoCzJKLnN1YnN0cmFpdC5FeHByZXNzaW9uLk1hc2tFeHByZXNzaW9uLkxpc3RTZWxlY3QuTGlzdFNlbGVjdEl0ZW0uTGlzdEVsZW1lbnRIABJZCgVzbGljZRgCIAEoCzJILnN1YnN0cmFpdC5FeHByZXNzaW9uLk1hc2tFeHByZXNzaW9uLkxpc3RTZWxlY3QuTGlzdFNlbGVjdEl0ZW0uTGlzdFNsaWNlSAAaHAoLTGlzdEVsZW1lbnQSDQoFZmllbGQYASABKAUaJwoJTGlzdFNsaWNlEg0KBXN0YXJ0GAEgASgFEgsKA2VuZBgCIAEoBUIGCgR0eXBlGrkCCglNYXBTZWxlY3QSRAoDa2V5GAEgASgLMjUuc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb24uTWFwU2VsZWN0Lk1hcEtleUgAElUKCmV4cHJlc3Npb24YAiABKAsyPy5zdWJzdHJhaXQuRXhwcmVzc2lvbi5NYXNrRXhwcmVzc2lvbi5NYXBTZWxlY3QuTWFwS2V5RXhwcmVzc2lvbkgAEjoKBWNoaWxkGAMgASgLMisuc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb24uU2VsZWN0GhkKBk1hcEtleRIPCgdtYXBfa2V5GAEgASgJGi4KEE1hcEtleUV4cHJlc3Npb24SGgoSbWFwX2tleV9leHByZXNzaW9uGAEgASgJQggKBnNlbGVjdBq2AwoORmllbGRSZWZlcmVuY2USQgoQZGlyZWN0X3JlZmVyZW5jZRgBIAEoCzImLnN1YnN0cmFpdC5FeHByZXNzaW9uLlJlZmVyZW5jZVNlZ21lbnRIABJAChBtYXNrZWRfcmVmZXJlbmNlGAIgASgLMiQuc3Vic3RyYWl0LkV4cHJlc3Npb24uTWFza0V4cHJlc3Npb25IABIrCgpleHByZXNzaW9uGAMgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb25IARJMCg5yb290X3JlZmVyZW5jZRgEIAEoCzIyLnN1YnN0cmFpdC5FeHByZXNzaW9uLkZpZWxkUmVmZXJlbmNlLlJvb3RSZWZlcmVuY2VIARJOCg9vdXRlcl9yZWZlcmVuY2UYBSABKAsyMy5zdWJzdHJhaXQuRXhwcmVzc2lvbi5GaWVsZFJlZmVyZW5jZS5PdXRlclJlZmVyZW5jZUgBGg8KDVJvb3RSZWZlcmVuY2UaIwoOT3V0ZXJSZWZlcmVuY2USEQoJc3RlcHNfb3V0GAEgASgNQhAKDnJlZmVyZW5jZV90eXBlQgsKCXJvb3RfdHlwZRqMCQoIU3VicXVlcnkSNwoGc2NhbGFyGAEgASgLMiUuc3Vic3RyYWl0LkV4cHJlc3Npb24uU3VicXVlcnkuU2NhbGFySAASQgoMaW5fcHJlZGljYXRlGAIgASgLMiouc3Vic3RyYWl0LkV4cHJlc3Npb24uU3VicXVlcnkuSW5QcmVkaWNhdGVIABJECg1zZXRfcHJlZGljYXRlGAMgASgLMisuc3Vic3RyYWl0LkV4cHJlc3Npb24uU3VicXVlcnkuU2V0UHJlZGljYXRlSAASRgoOc2V0X2NvbXBhcmlzb24YBCABKAsyLC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5TdWJxdWVyeS5TZXRDb21wYXJpc29uSAAaJwoGU2NhbGFyEh0KBWlucHV0GAEgASgLMg4uc3Vic3RyYWl0LlJlbBpXCgtJblByZWRpY2F0ZRImCgduZWVkbGVzGAEgAygLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SIAoIaGF5c3RhY2sYAiABKAsyDi5zdWJzdHJhaXQuUmVsGtwBCgxTZXRQcmVkaWNhdGUSTQoMcHJlZGljYXRlX29wGAEgASgOMjcuc3Vic3RyYWl0LkV4cHJlc3Npb24uU3VicXVlcnkuU2V0UHJlZGljYXRlLlByZWRpY2F0ZU9wEh4KBnR1cGxlcxgCIAEoCzIOLnN1YnN0cmFpdC5SZWwiXQoLUHJlZGljYXRlT3ASHAoYUFJFRElDQVRFX09QX1VOU1BFQ0lGSUVEEAASFwoTUFJFRElDQVRFX09QX0VYSVNUUxABEhcKE1BSRURJQ0FURV9PUF9VTklRVUUQAhqCBAoNU2V0Q29tcGFyaXNvbhJOCgxyZWR1Y3Rpb25fb3AYASABKA4yOC5zdWJzdHJhaXQuRXhwcmVzc2lvbi5TdWJxdWVyeS5TZXRDb21wYXJpc29uLlJlZHVjdGlvbk9wElAKDWNvbXBhcmlzb25fb3AYAiABKA4yOS5zdWJzdHJhaXQuRXhwcmVzc2lvbi5TdWJxdWVyeS5TZXRDb21wYXJpc29uLkNvbXBhcmlzb25PcBIjCgRsZWZ0GAMgASgLMhUuc3Vic3RyYWl0LkV4cHJlc3Npb24SHQoFcmlnaHQYBCABKAsyDi5zdWJzdHJhaXQuUmVsIrEBCgxDb21wYXJpc29uT3ASHQoZQ09NUEFSSVNPTl9PUF9VTlNQRUNJRklFRBAAEhQKEENPTVBBUklTT05fT1BfRVEQARIUChBDT01QQVJJU09OX09QX05FEAISFAoQQ09NUEFSSVNPTl9PUF9MVBADEhQKEENPTVBBUklTT05fT1BfR1QQBBIUChBDT01QQVJJU09OX09QX0xFEAUSFAoQQ09NUEFSSVNPTl9PUF9HRRAGIlcKC1JlZHVjdGlvbk9wEhwKGFJFRFVDVElPTl9PUF9VTlNQRUNJRklFRBAAEhQKEFJFRFVDVElPTl9PUF9BTlkQARIUChBSRURVQ1RJT05fT1BfQUxMEAJCDwoNc3VicXVlcnlfdHlwZUIKCghyZXhfdHlwZSJOChBEeW5hbWljUGFyYW1ldGVyEh0KBHR5cGUYASABKAsyDy5zdWJzdHJhaXQuVHlwZRIbChNwYXJhbWV0ZXJfcmVmZXJlbmNlGAIgASgNIv8CCglTb3J0RmllbGQSIwoEZXhwchgBIAEoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uEjcKCWRpcmVjdGlvbhgCIAEoDjIiLnN1YnN0cmFpdC5Tb3J0RmllbGQuU29ydERpcmVjdGlvbkgAEicKHWNvbXBhcmlzb25fZnVuY3Rpb25fcmVmZXJlbmNlGAMgASgNSAAi3QEKDVNvcnREaXJlY3Rpb24SHgoaU09SVF9ESVJFQ1RJT05fVU5TUEVDSUZJRUQQABIiCh5TT1JUX0RJUkVDVElPTl9BU0NfTlVMTFNfRklSU1QQARIhCh1TT1JUX0RJUkVDVElPTl9BU0NfTlVMTFNfTEFTVBACEiMKH1NPUlRfRElSRUNUSU9OX0RFU0NfTlVMTFNfRklSU1QQAxIiCh5TT1JUX0RJUkVDVElPTl9ERVNDX05VTExTX0xBU1QQBBIcChhTT1JUX0RJUkVDVElPTl9DTFVTVEVSRUQQBUILCglzb3J0X2tpbmQi+gMKEUFnZ3JlZ2F0ZUZ1bmN0aW9uEhoKEmZ1bmN0aW9uX3JlZmVyZW5jZRgBIAEoDRIuCglhcmd1bWVudHMYByADKAsyGy5zdWJzdHJhaXQuRnVuY3Rpb25Bcmd1bWVudBIqCgdvcHRpb25zGAggAygLMhkuc3Vic3RyYWl0LkZ1bmN0aW9uT3B0aW9uEiQKC291dHB1dF90eXBlGAUgASgLMg8uc3Vic3RyYWl0LlR5cGUSKgoFcGhhc2UYBCABKA4yGy5zdWJzdHJhaXQuQWdncmVnYXRpb25QaGFzZRIjCgVzb3J0cxgDIAMoCzIULnN1YnN0cmFpdC5Tb3J0RmllbGQSRgoKaW52b2NhdGlvbhgGIAEoDjIyLnN1YnN0cmFpdC5BZ2dyZWdhdGVGdW5jdGlvbi5BZ2dyZWdhdGlvbkludm9jYXRpb24SJwoEYXJncxgCIAMoCzIVLnN1YnN0cmFpdC5FeHByZXNzaW9uQgIYASKEAQoVQWdncmVnYXRpb25JbnZvY2F0aW9uEiYKIkFHR1JFR0FUSU9OX0lOVk9DQVRJT05fVU5TUEVDSUZJRUQQABIeChpBR0dSRUdBVElPTl9JTlZPQ0FUSU9OX0FMTBABEiMKH0FHR1JFR0FUSU9OX0lOVk9DQVRJT05fRElTVElOQ1QQAiInCgxSZWZlcmVuY2VSZWwSFwoPc3VidHJlZV9vcmRpbmFsGAEgASgFKu8BChBBZ2dyZWdhdGlvblBoYXNlEiEKHUFHR1JFR0FUSU9OX1BIQVNFX1VOU1BFQ0lGSUVEEAASLQopQUdHUkVHQVRJT05fUEhBU0VfSU5JVElBTF9UT19JTlRFUk1FRElBVEUQARIyCi5BR0dSRUdBVElPTl9QSEFTRV9JTlRFUk1FRElBVEVfVE9fSU5URVJNRURJQVRFEAISJwojQUdHUkVHQVRJT05fUEhBU0VfSU5JVElBTF9UT19SRVNVTFQQAxIsCihBR0dSRUdBVElPTl9QSEFTRV9JTlRFUk1FRElBVEVfVE9fUkVTVUxUEARCVwoSaW8uc3Vic3RyYWl0LnByb3RvUAFaKmdpdGh1Yi5jb20vc3Vic3RyYWl0LWlvL3N1YnN0cmFpdC1nby9wcm90b6oCElN1YnN0cmFpdC5Qcm90b2J1ZmIGcHJvdG8z", [file_google_protobuf_any, file_substrait_extensions_extensions, file_substrait_type]);

/**
 * Common fields for all relational operators
 *
 * @generated from message substrait.RelCommon
 */
export type RelCommon = Message<"substrait.RelCommon"> & {
  /**
   * @generated from oneof substrait.RelCommon.emit_kind
   */
  emitKind: {
    /**
     * The underlying relation is output as is (no reordering or projection of columns)
     *
     * @generated from field: substrait.RelCommon.Direct direct = 1;
     */
    value: RelCommon_Direct;
    case: "direct";
  } | {
    /**
     * Allows to control for order and inclusion of fields
     *
     * @generated from field: substrait.RelCommon.Emit emit = 2;
     */
    value: RelCommon_Emit;
    case: "emit";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: substrait.RelCommon.Hint hint = 3;
   */
  hint?: RelCommon_Hint;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 4;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.RelCommon.
 * Use `create(RelCommonSchema)` to create a new message.
 */
export const RelCommonSchema: GenMessage<RelCommon> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0);

/**
 * Direct indicates no change on presence and ordering of fields in the output
 *
 * @generated from message substrait.RelCommon.Direct
 */
export type RelCommon_Direct = Message<"substrait.RelCommon.Direct"> & {
};

/**
 * Describes the message substrait.RelCommon.Direct.
 * Use `create(RelCommon_DirectSchema)` to create a new message.
 */
export const RelCommon_DirectSchema: GenMessage<RelCommon_Direct> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 0);

/**
 * Remap which fields are output and in which order
 *
 * @generated from message substrait.RelCommon.Emit
 */
export type RelCommon_Emit = Message<"substrait.RelCommon.Emit"> & {
  /**
   * @generated from field: repeated int32 output_mapping = 1;
   */
  outputMapping: number[];
};

/**
 * Describes the message substrait.RelCommon.Emit.
 * Use `create(RelCommon_EmitSchema)` to create a new message.
 */
export const RelCommon_EmitSchema: GenMessage<RelCommon_Emit> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 1);

/**
 * Changes to the operation that can influence efficiency/performance but
 * should not impact correctness.
 *
 * @generated from message substrait.RelCommon.Hint
 */
export type RelCommon_Hint = Message<"substrait.RelCommon.Hint"> & {
  /**
   * @generated from field: substrait.RelCommon.Hint.Stats stats = 1;
   */
  stats?: RelCommon_Hint_Stats;

  /**
   * @generated from field: substrait.RelCommon.Hint.RuntimeConstraint constraint = 2;
   */
  constraint?: RelCommon_Hint_RuntimeConstraint;

  /**
   * Name (alias) for this relation. Can be used for e.g. qualifying the relation (see e.g.
   * Spark's SubqueryAlias), or debugging.
   *
   * @generated from field: string alias = 3;
   */
  alias: string;

  /**
   * Assigns alternative output field names for any relation.  Equivalent to the names field
   * in RelRoot but applies to the output of the relation this RelCommon is attached to.
   *
   * @generated from field: repeated string output_names = 4;
   */
  outputNames: string[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;

  /**
   * Save or load a system-specific computation for use in optimizing a remote operation.
   * The anchor refers to the source/destination of the computation.  The computation type
   * and number refer to the current relation.
   *
   * @generated from field: repeated substrait.RelCommon.Hint.SavedComputation saved_computations = 11;
   */
  savedComputations: RelCommon_Hint_SavedComputation[];

  /**
   * @generated from field: repeated substrait.RelCommon.Hint.LoadedComputation loaded_computations = 12;
   */
  loadedComputations: RelCommon_Hint_LoadedComputation[];
};

/**
 * Describes the message substrait.RelCommon.Hint.
 * Use `create(RelCommon_HintSchema)` to create a new message.
 */
export const RelCommon_HintSchema: GenMessage<RelCommon_Hint> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 2);

/**
 * The statistics related to a hint (physical properties of records)
 *
 * @generated from message substrait.RelCommon.Hint.Stats
 */
export type RelCommon_Hint_Stats = Message<"substrait.RelCommon.Hint.Stats"> & {
  /**
   * @generated from field: double row_count = 1;
   */
  rowCount: number;

  /**
   * @generated from field: double record_size = 2;
   */
  recordSize: number;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.RelCommon.Hint.Stats.
 * Use `create(RelCommon_Hint_StatsSchema)` to create a new message.
 */
export const RelCommon_Hint_StatsSchema: GenMessage<RelCommon_Hint_Stats> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 2, 0);

/**
 * TODO: nodes, cpu threads/%, memory, iops, etc.
 *
 * @generated from message substrait.RelCommon.Hint.RuntimeConstraint
 */
export type RelCommon_Hint_RuntimeConstraint = Message<"substrait.RelCommon.Hint.RuntimeConstraint"> & {
  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.RelCommon.Hint.RuntimeConstraint.
 * Use `create(RelCommon_Hint_RuntimeConstraintSchema)` to create a new message.
 */
export const RelCommon_Hint_RuntimeConstraintSchema: GenMessage<RelCommon_Hint_RuntimeConstraint> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 2, 1);

/**
 * @generated from message substrait.RelCommon.Hint.SavedComputation
 */
export type RelCommon_Hint_SavedComputation = Message<"substrait.RelCommon.Hint.SavedComputation"> & {
  /**
   * The value corresponds to a plan unique number for that datastructure.  Any particular
   * computation may be saved only once but it may be loaded multiple times.
   *
   * @generated from field: int32 computation_id = 1;
   */
  computationId: number;

  /**
   * The type of this computation.  While a plan may use COMPUTATION_TYPE_UNKNOWN for all
   * of its types it is recommended to use a more specific type so that the optimization
   * is more portable.  The consumer should be able to decide if an unknown type here
   * matches the same unknown type at a different plan and ignore the optimization if they
   * are mismatched.
   *
   * @generated from field: substrait.RelCommon.Hint.ComputationType type = 2;
   */
  type: RelCommon_Hint_ComputationType;
};

/**
 * Describes the message substrait.RelCommon.Hint.SavedComputation.
 * Use `create(RelCommon_Hint_SavedComputationSchema)` to create a new message.
 */
export const RelCommon_Hint_SavedComputationSchema: GenMessage<RelCommon_Hint_SavedComputation> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 2, 2);

/**
 * @generated from message substrait.RelCommon.Hint.LoadedComputation
 */
export type RelCommon_Hint_LoadedComputation = Message<"substrait.RelCommon.Hint.LoadedComputation"> & {
  /**
   * The value corresponds to a plan unique number for that datastructure.  Any particular
   * computation may be saved only once but it may be loaded multiple times.
   *
   * @generated from field: int32 computation_id_reference = 1;
   */
  computationIdReference: number;

  /**
   * The type of this computation.  While a plan may use COMPUTATION_TYPE_UNKNOWN for all
   * of its types it is recommended to use a more specific type so that the optimization
   * is more portable.  The consumer should be able to decide if an unknown type here
   * matches the same unknown type at a different plan and ignore the optimization if they
   * are mismatched.
   *
   * @generated from field: substrait.RelCommon.Hint.ComputationType type = 2;
   */
  type: RelCommon_Hint_ComputationType;
};

/**
 * Describes the message substrait.RelCommon.Hint.LoadedComputation.
 * Use `create(RelCommon_Hint_LoadedComputationSchema)` to create a new message.
 */
export const RelCommon_Hint_LoadedComputationSchema: GenMessage<RelCommon_Hint_LoadedComputation> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 0, 2, 3);

/**
 * @generated from enum substrait.RelCommon.Hint.ComputationType
 */
export enum RelCommon_Hint_ComputationType {
  /**
   * @generated from enum value: COMPUTATION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: COMPUTATION_TYPE_HASHTABLE = 1;
   */
  HASHTABLE = 1,

  /**
   * @generated from enum value: COMPUTATION_TYPE_BLOOM_FILTER = 2;
   */
  BLOOM_FILTER = 2,

  /**
   * @generated from enum value: COMPUTATION_TYPE_UNKNOWN = 9999;
   */
  UNKNOWN = 9999,
}

/**
 * Describes the enum substrait.RelCommon.Hint.ComputationType.
 */
export const RelCommon_Hint_ComputationTypeSchema: GenEnum<RelCommon_Hint_ComputationType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 0, 2, 0);

/**
 * The scan operator of base data (physical or virtual), including filtering and projection.
 *
 * @generated from message substrait.ReadRel
 */
export type ReadRel = Message<"substrait.ReadRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.NamedStruct base_schema = 2;
   */
  baseSchema?: NamedStruct;

  /**
   * @generated from field: substrait.Expression filter = 3;
   */
  filter?: Expression;

  /**
   * @generated from field: substrait.Expression best_effort_filter = 11;
   */
  bestEffortFilter?: Expression;

  /**
   * @generated from field: substrait.Expression.MaskExpression projection = 4;
   */
  projection?: Expression_MaskExpression;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;

  /**
   * Definition of which type of scan operation is to be performed
   *
   * @generated from oneof substrait.ReadRel.read_type
   */
  readType: {
    /**
     * @generated from field: substrait.ReadRel.VirtualTable virtual_table = 5;
     */
    value: ReadRel_VirtualTable;
    case: "virtualTable";
  } | {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles local_files = 6;
     */
    value: ReadRel_LocalFiles;
    case: "localFiles";
  } | {
    /**
     * @generated from field: substrait.ReadRel.NamedTable named_table = 7;
     */
    value: ReadRel_NamedTable;
    case: "namedTable";
  } | {
    /**
     * @generated from field: substrait.ReadRel.ExtensionTable extension_table = 8;
     */
    value: ReadRel_ExtensionTable;
    case: "extensionTable";
  } | {
    /**
     * @generated from field: substrait.ReadRel.IcebergTable iceberg_table = 9;
     */
    value: ReadRel_IcebergTable;
    case: "icebergTable";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ReadRel.
 * Use `create(ReadRelSchema)` to create a new message.
 */
export const ReadRelSchema: GenMessage<ReadRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1);

/**
 * A base table. The list of string is used to represent namespacing (e.g., mydb.mytable).
 * This assumes shared catalog between systems exchanging a message.
 *
 * @generated from message substrait.ReadRel.NamedTable
 */
export type ReadRel_NamedTable = Message<"substrait.ReadRel.NamedTable"> & {
  /**
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.ReadRel.NamedTable.
 * Use `create(ReadRel_NamedTableSchema)` to create a new message.
 */
export const ReadRel_NamedTableSchema: GenMessage<ReadRel_NamedTable> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 0);

/**
 * Read an Iceberg Table
 *
 * @generated from message substrait.ReadRel.IcebergTable
 */
export type ReadRel_IcebergTable = Message<"substrait.ReadRel.IcebergTable"> & {
  /**
   * @generated from oneof substrait.ReadRel.IcebergTable.table_type
   */
  tableType: {
    /**
     * future: add catalog table types (e.g. rest api, latest metadata in path, etc)
     *
     * @generated from field: substrait.ReadRel.IcebergTable.MetadataFileRead direct = 1;
     */
    value: ReadRel_IcebergTable_MetadataFileRead;
    case: "direct";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ReadRel.IcebergTable.
 * Use `create(ReadRel_IcebergTableSchema)` to create a new message.
 */
export const ReadRel_IcebergTableSchema: GenMessage<ReadRel_IcebergTable> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 1);

/**
 * Read an Iceberg table using a metadata file. Implicit assumption: required credentials are already known by plan consumer.
 *
 * @generated from message substrait.ReadRel.IcebergTable.MetadataFileRead
 */
export type ReadRel_IcebergTable_MetadataFileRead = Message<"substrait.ReadRel.IcebergTable.MetadataFileRead"> & {
  /**
   * the specific uri of a metadata file (e.g. s3://mybucket/mytable/<ver>-<uuid>.metadata.json)
   *
   * @generated from field: string metadata_uri = 1;
   */
  metadataUri: string;

  /**
   * snapshot options. if none set, uses the current snapshot listed in the metadata file
   *
   * @generated from oneof substrait.ReadRel.IcebergTable.MetadataFileRead.snapshot
   */
  snapshot: {
    /**
     * the snapshot id to read.
     *
     * @generated from field: string snapshot_id = 2;
     */
    value: string;
    case: "snapshotId";
  } | {
    /**
     * the timestamp that should be used to select the snapshot (Time passed in microseconds since 1970-01-01 00:00:00.000000 in UTC)
     *
     * @generated from field: int64 snapshot_timestamp = 3;
     */
    value: bigint;
    case: "snapshotTimestamp";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ReadRel.IcebergTable.MetadataFileRead.
 * Use `create(ReadRel_IcebergTable_MetadataFileReadSchema)` to create a new message.
 */
export const ReadRel_IcebergTable_MetadataFileReadSchema: GenMessage<ReadRel_IcebergTable_MetadataFileRead> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 1, 0);

/**
 * A table composed of expressions.
 *
 * @generated from message substrait.ReadRel.VirtualTable
 */
export type ReadRel_VirtualTable = Message<"substrait.ReadRel.VirtualTable"> & {
  /**
   * @generated from field: repeated substrait.Expression.Literal.Struct values = 1 [deprecated = true];
   * @deprecated
   */
  values: Expression_Literal_Struct[];

  /**
   * @generated from field: repeated substrait.Expression.Nested.Struct expressions = 2;
   */
  expressions: Expression_Nested_Struct[];
};

/**
 * Describes the message substrait.ReadRel.VirtualTable.
 * Use `create(ReadRel_VirtualTableSchema)` to create a new message.
 */
export const ReadRel_VirtualTableSchema: GenMessage<ReadRel_VirtualTable> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 2);

/**
 * A stub type that can be used to extend/introduce new table types outside
 * the specification.
 *
 * @generated from message substrait.ReadRel.ExtensionTable
 */
export type ReadRel_ExtensionTable = Message<"substrait.ReadRel.ExtensionTable"> & {
  /**
   * @generated from field: google.protobuf.Any detail = 1;
   */
  detail?: Any;
};

/**
 * Describes the message substrait.ReadRel.ExtensionTable.
 * Use `create(ReadRel_ExtensionTableSchema)` to create a new message.
 */
export const ReadRel_ExtensionTableSchema: GenMessage<ReadRel_ExtensionTable> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 3);

/**
 * Represents a list of files in input of a scan operation
 *
 * @generated from message substrait.ReadRel.LocalFiles
 */
export type ReadRel_LocalFiles = Message<"substrait.ReadRel.LocalFiles"> & {
  /**
   * @generated from field: repeated substrait.ReadRel.LocalFiles.FileOrFiles items = 1;
   */
  items: ReadRel_LocalFiles_FileOrFiles[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.
 * Use `create(ReadRel_LocalFilesSchema)` to create a new message.
 */
export const ReadRel_LocalFilesSchema: GenMessage<ReadRel_LocalFiles> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 4);

/**
 * Many files consist of indivisible chunks (e.g. parquet row groups
 * or CSV rows).  If a slice partially selects an indivisible chunk
 * then the consumer should employ some rule to decide which slice to
 * include the chunk in (e.g. include it in the slice that contains
 * the midpoint of the chunk)
 *
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles
 */
export type ReadRel_LocalFiles_FileOrFiles = Message<"substrait.ReadRel.LocalFiles.FileOrFiles"> & {
  /**
   * @generated from oneof substrait.ReadRel.LocalFiles.FileOrFiles.path_type
   */
  pathType: {
    /**
     * A URI that can refer to either a single folder or a single file
     *
     * @generated from field: string uri_path = 1;
     */
    value: string;
    case: "uriPath";
  } | {
    /**
     * A URI where the path portion is a glob expression that can
     * identify zero or more paths.
     * Consumers should support the POSIX syntax.  The recursive
     * globstar (**) may not be supported.
     *
     * @generated from field: string uri_path_glob = 2;
     */
    value: string;
    case: "uriPathGlob";
  } | {
    /**
     * A URI that refers to a single file
     *
     * @generated from field: string uri_file = 3;
     */
    value: string;
    case: "uriFile";
  } | {
    /**
     * A URI that refers to a single folder
     *
     * @generated from field: string uri_folder = 4;
     */
    value: string;
    case: "uriFolder";
  } | { case: undefined; value?: undefined };

  /**
   * The index of the partition this item belongs to
   *
   * @generated from field: uint64 partition_index = 6;
   */
  partitionIndex: bigint;

  /**
   * The start position in byte to read from this item
   *
   * @generated from field: uint64 start = 7;
   */
  start: bigint;

  /**
   * The length in byte to read from this item
   *
   * @generated from field: uint64 length = 8;
   */
  length: bigint;

  /**
   * The format of the files along with options for reading those files.
   *
   * @generated from oneof substrait.ReadRel.LocalFiles.FileOrFiles.file_format
   */
  fileFormat: {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions parquet = 9;
     */
    value: ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions;
    case: "parquet";
  } | {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions arrow = 10;
     */
    value: ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions;
    case: "arrow";
  } | {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions orc = 11;
     */
    value: ReadRel_LocalFiles_FileOrFiles_OrcReadOptions;
    case: "orc";
  } | {
    /**
     * @generated from field: google.protobuf.Any extension = 12;
     */
    value: Any;
    case: "extension";
  } | {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions dwrf = 13;
     */
    value: ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions;
    case: "dwrf";
  } | {
    /**
     * @generated from field: substrait.ReadRel.LocalFiles.FileOrFiles.DelimiterSeparatedTextReadOptions text = 14;
     */
    value: ReadRel_LocalFiles_FileOrFiles_DelimiterSeparatedTextReadOptions;
    case: "text";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.
 * Use `create(ReadRel_LocalFiles_FileOrFilesSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFilesSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 4, 0);

/**
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions
 */
export type ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions = Message<"substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions"> & {
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions.
 * Use `create(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptionsSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptionsSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 4, 0, 0);

/**
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions
 */
export type ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions = Message<"substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions"> & {
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions.
 * Use `create(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptionsSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptionsSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 4, 0, 1);

/**
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions
 */
export type ReadRel_LocalFiles_FileOrFiles_OrcReadOptions = Message<"substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions"> & {
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions.
 * Use `create(ReadRel_LocalFiles_FileOrFiles_OrcReadOptionsSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFiles_OrcReadOptionsSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles_OrcReadOptions> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 4, 0, 2);

/**
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions
 */
export type ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions = Message<"substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions"> & {
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions.
 * Use `create(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptionsSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptionsSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 4, 0, 3);

/**
 * Delimiter separated files may be compressed.  The reader should
 * autodetect this and decompress as needed.
 *
 * @generated from message substrait.ReadRel.LocalFiles.FileOrFiles.DelimiterSeparatedTextReadOptions
 */
export type ReadRel_LocalFiles_FileOrFiles_DelimiterSeparatedTextReadOptions = Message<"substrait.ReadRel.LocalFiles.FileOrFiles.DelimiterSeparatedTextReadOptions"> & {
  /**
   * The character(s) used to separate fields.  Common values are comma,
   * tab, and pipe.  Multiple characters are allowed.
   *
   * @generated from field: string field_delimiter = 1;
   */
  fieldDelimiter: string;

  /**
   * The maximum number of bytes to read from a single line.  If a line
   * exceeds this limit the resulting behavior is undefined.
   *
   * @generated from field: uint64 max_line_size = 2;
   */
  maxLineSize: bigint;

  /**
   * The character(s) used to quote strings.  Common values are single
   * and double quotation marks.
   *
   * @generated from field: string quote = 3;
   */
  quote: string;

  /**
   * The number of lines to skip at the beginning of the file.
   *
   * @generated from field: uint64 header_lines_to_skip = 4;
   */
  headerLinesToSkip: bigint;

  /**
   * The character used to escape characters in strings.  Backslash is
   * a common value.  Note that a double quote mark can also be used as an
   * escape character but the external quotes should be removed first.
   *
   * @generated from field: string escape = 5;
   */
  escape: string;

  /**
   * If this value is encountered (including empty string), the resulting
   * value is null instead.  Leave unset to disable.  If this value is
   * provided, the effective schema of this file is comprised entirely of
   * nullable strings.  If not provided, the effective schema is instead
   * made up of non-nullable strings.
   *
   * @generated from field: optional string value_treated_as_null = 6;
   */
  valueTreatedAsNull?: string;
};

/**
 * Describes the message substrait.ReadRel.LocalFiles.FileOrFiles.DelimiterSeparatedTextReadOptions.
 * Use `create(ReadRel_LocalFiles_FileOrFiles_DelimiterSeparatedTextReadOptionsSchema)` to create a new message.
 */
export const ReadRel_LocalFiles_FileOrFiles_DelimiterSeparatedTextReadOptionsSchema: GenMessage<ReadRel_LocalFiles_FileOrFiles_DelimiterSeparatedTextReadOptions> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 1, 4, 0, 4);

/**
 * This operator allows to represent calculated expressions of fields (e.g., a+b). Direct/Emit are used to represent classical relational projections
 *
 * @generated from message substrait.ProjectRel
 */
export type ProjectRel = Message<"substrait.ProjectRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: repeated substrait.Expression expressions = 3;
   */
  expressions: Expression[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.ProjectRel.
 * Use `create(ProjectRelSchema)` to create a new message.
 */
export const ProjectRelSchema: GenMessage<ProjectRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 2);

/**
 * The binary JOIN relational operator left-join-right, including various join types, a join condition and post_join_filter expression
 *
 * @generated from message substrait.JoinRel
 */
export type JoinRel = Message<"substrait.JoinRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel left = 2;
   */
  left?: Rel;

  /**
   * @generated from field: substrait.Rel right = 3;
   */
  right?: Rel;

  /**
   * @generated from field: substrait.Expression expression = 4;
   */
  expression?: Expression;

  /**
   * @generated from field: substrait.Expression post_join_filter = 5;
   */
  postJoinFilter?: Expression;

  /**
   * @generated from field: substrait.JoinRel.JoinType type = 6;
   */
  type: JoinRel_JoinType;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.JoinRel.
 * Use `create(JoinRelSchema)` to create a new message.
 */
export const JoinRelSchema: GenMessage<JoinRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 3);

/**
 * @generated from enum substrait.JoinRel.JoinType
 */
export enum JoinRel_JoinType {
  /**
   * @generated from enum value: JOIN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: JOIN_TYPE_INNER = 1;
   */
  INNER = 1,

  /**
   * @generated from enum value: JOIN_TYPE_OUTER = 2;
   */
  OUTER = 2,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT = 3;
   */
  LEFT = 3,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT = 4;
   */
  RIGHT = 4,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SEMI = 5;
   */
  LEFT_SEMI = 5,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_ANTI = 6;
   */
  LEFT_ANTI = 6,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SINGLE = 7;
   */
  LEFT_SINGLE = 7,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SEMI = 8;
   */
  RIGHT_SEMI = 8,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_ANTI = 9;
   */
  RIGHT_ANTI = 9,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SINGLE = 10;
   */
  RIGHT_SINGLE = 10,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_MARK = 11;
   */
  LEFT_MARK = 11,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_MARK = 12;
   */
  RIGHT_MARK = 12,
}

/**
 * Describes the enum substrait.JoinRel.JoinType.
 */
export const JoinRel_JoinTypeSchema: GenEnum<JoinRel_JoinType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 3, 0);

/**
 * Cartesian product relational operator of two tables (left and right)
 *
 * @generated from message substrait.CrossRel
 */
export type CrossRel = Message<"substrait.CrossRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel left = 2;
   */
  left?: Rel;

  /**
   * @generated from field: substrait.Rel right = 3;
   */
  right?: Rel;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.CrossRel.
 * Use `create(CrossRelSchema)` to create a new message.
 */
export const CrossRelSchema: GenMessage<CrossRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 4);

/**
 * The relational operator representing LIMIT/OFFSET or TOP type semantics.
 *
 * @generated from message substrait.FetchRel
 */
export type FetchRel = Message<"substrait.FetchRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * Note: A oneof field is inherently optional, whereas individual fields
   * within a oneof cannot be marked as optional. The unset state of offset
   * should therefore be checked at the oneof level. Unset is treated as 0.
   *
   * @generated from oneof substrait.FetchRel.offset_mode
   */
  offsetMode: {
    /**
     * the offset expressed in number of records
     * Deprecated: use `offset_expr` instead
     *
     * @generated from field: int64 offset = 3 [deprecated = true];
     * @deprecated
     */
    value: bigint;
    case: "offset";
  } | {
    /**
     * Expression evaluated into a non-negative integer specifying the number
     * of records to skip. An expression evaluating to null is treated as 0.
     * Evaluating to a negative integer should result in an error.
     * Recommended type for offset is int64.
     *
     * @generated from field: substrait.Expression offset_expr = 5;
     */
    value: Expression;
    case: "offsetExpr";
  } | { case: undefined; value?: undefined };

  /**
   * Note: A oneof field is inherently optional, whereas individual fields
   * within a oneof cannot be marked as optional. The unset state of count
   * should therefore be checked at the oneof level. Unset is treated as ALL.
   *
   * @generated from oneof substrait.FetchRel.count_mode
   */
  countMode: {
    /**
     * the amount of records to return
     * use -1 to signal that ALL records should be returned
     * Deprecated: use `count_expr` instead
     *
     * @generated from field: int64 count = 4 [deprecated = true];
     * @deprecated
     */
    value: bigint;
    case: "count";
  } | {
    /**
     * Expression evaluated into a non-negative integer specifying the number
     * of records to return. An expression evaluating to null signals that ALL
     * records should be returned.
     * Evaluating to a negative integer should result in an error.
     * Recommended type for count is int64.
     *
     * @generated from field: substrait.Expression count_expr = 6;
     */
    value: Expression;
    case: "countExpr";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.FetchRel.
 * Use `create(FetchRelSchema)` to create a new message.
 */
export const FetchRelSchema: GenMessage<FetchRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 5);

/**
 * The relational operator representing a GROUP BY Aggregate
 *
 * @generated from message substrait.AggregateRel
 */
export type AggregateRel = Message<"substrait.AggregateRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * Input of the aggregation
   *
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * A list of zero or more grouping sets that the aggregation measures should
   * be calculated for. There must be at least one grouping set if there are no
   * measures (but it can be the empty grouping set).
   *
   * @generated from field: repeated substrait.AggregateRel.Grouping groupings = 3;
   */
  groupings: AggregateRel_Grouping[];

  /**
   * A list of one or more aggregate expressions along with an optional filter.
   * Required if there are no groupings.
   *
   * @generated from field: repeated substrait.AggregateRel.Measure measures = 4;
   */
  measures: AggregateRel_Measure[];

  /**
   * A list of zero or more grouping expressions that grouping sets (i.e.,
   * `Grouping` messages in the `groupings` field) can reference. Each
   * expression in this list must be referred to by at least one
   * `Grouping.expression_references`.
   *
   * @generated from field: repeated substrait.Expression grouping_expressions = 5;
   */
  groupingExpressions: Expression[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.AggregateRel.
 * Use `create(AggregateRelSchema)` to create a new message.
 */
export const AggregateRelSchema: GenMessage<AggregateRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 6);

/**
 * @generated from message substrait.AggregateRel.Grouping
 */
export type AggregateRel_Grouping = Message<"substrait.AggregateRel.Grouping"> & {
  /**
   * Deprecated in favor of `expression_references` below.
   *
   * @generated from field: repeated substrait.Expression grouping_expressions = 1 [deprecated = true];
   * @deprecated
   */
  groupingExpressions: Expression[];

  /**
   * A list of zero or more references to grouping expressions, i.e., indices
   * into the `grouping_expression` list.
   *
   * @generated from field: repeated uint32 expression_references = 2;
   */
  expressionReferences: number[];
};

/**
 * Describes the message substrait.AggregateRel.Grouping.
 * Use `create(AggregateRel_GroupingSchema)` to create a new message.
 */
export const AggregateRel_GroupingSchema: GenMessage<AggregateRel_Grouping> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 6, 0);

/**
 * @generated from message substrait.AggregateRel.Measure
 */
export type AggregateRel_Measure = Message<"substrait.AggregateRel.Measure"> & {
  /**
   * @generated from field: substrait.AggregateFunction measure = 1;
   */
  measure?: AggregateFunction;

  /**
   * An optional boolean expression that acts to filter which records are
   * included in the measure. True means include this record for calculation
   * within the measure.
   * Helps to support SUM(<c>) FILTER(WHERE...) syntax without masking opportunities for optimization
   *
   * @generated from field: substrait.Expression filter = 2;
   */
  filter?: Expression;
};

/**
 * Describes the message substrait.AggregateRel.Measure.
 * Use `create(AggregateRel_MeasureSchema)` to create a new message.
 */
export const AggregateRel_MeasureSchema: GenMessage<AggregateRel_Measure> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 6, 1);

/**
 * ConsistentPartitionWindowRel provides the ability to perform calculations across sets of rows
 * that are related to the current query row. It can be used to execute window functions where
 * all the windows share the same partitioning and ordering.
 *
 * @generated from message substrait.ConsistentPartitionWindowRel
 */
export type ConsistentPartitionWindowRel = Message<"substrait.ConsistentPartitionWindowRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: repeated substrait.ConsistentPartitionWindowRel.WindowRelFunction window_functions = 3;
   */
  windowFunctions: ConsistentPartitionWindowRel_WindowRelFunction[];

  /**
   * @generated from field: repeated substrait.Expression partition_expressions = 4;
   */
  partitionExpressions: Expression[];

  /**
   * @generated from field: repeated substrait.SortField sorts = 5;
   */
  sorts: SortField[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.ConsistentPartitionWindowRel.
 * Use `create(ConsistentPartitionWindowRelSchema)` to create a new message.
 */
export const ConsistentPartitionWindowRelSchema: GenMessage<ConsistentPartitionWindowRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 7);

/**
 * This message mirrors the `WindowFunction` message but removes the fields defining the partition,
 * sorts, and bounds, since those must be consistent across the various functions in this rel.  Refer
 * to the `WindowFunction` message for a description of these fields.
 *
 * @generated from message substrait.ConsistentPartitionWindowRel.WindowRelFunction
 */
export type ConsistentPartitionWindowRel_WindowRelFunction = Message<"substrait.ConsistentPartitionWindowRel.WindowRelFunction"> & {
  /**
   * @generated from field: uint32 function_reference = 1;
   */
  functionReference: number;

  /**
   * @generated from field: repeated substrait.FunctionArgument arguments = 9;
   */
  arguments: FunctionArgument[];

  /**
   * @generated from field: repeated substrait.FunctionOption options = 11;
   */
  options: FunctionOption[];

  /**
   * @generated from field: substrait.Type output_type = 7;
   */
  outputType?: Type;

  /**
   * @generated from field: substrait.AggregationPhase phase = 6;
   */
  phase: AggregationPhase;

  /**
   * @generated from field: substrait.AggregateFunction.AggregationInvocation invocation = 10;
   */
  invocation: AggregateFunction_AggregationInvocation;

  /**
   * @generated from field: substrait.Expression.WindowFunction.Bound lower_bound = 5;
   */
  lowerBound?: Expression_WindowFunction_Bound;

  /**
   * @generated from field: substrait.Expression.WindowFunction.Bound upper_bound = 4;
   */
  upperBound?: Expression_WindowFunction_Bound;

  /**
   * @generated from field: substrait.Expression.WindowFunction.BoundsType bounds_type = 12;
   */
  boundsType: Expression_WindowFunction_BoundsType;
};

/**
 * Describes the message substrait.ConsistentPartitionWindowRel.WindowRelFunction.
 * Use `create(ConsistentPartitionWindowRel_WindowRelFunctionSchema)` to create a new message.
 */
export const ConsistentPartitionWindowRel_WindowRelFunctionSchema: GenMessage<ConsistentPartitionWindowRel_WindowRelFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 7, 0);

/**
 * The ORDERY BY (or sorting) relational operator. Beside describing a base relation, it includes a list of fields to sort on
 *
 * @generated from message substrait.SortRel
 */
export type SortRel = Message<"substrait.SortRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: repeated substrait.SortField sorts = 3;
   */
  sorts: SortField[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.SortRel.
 * Use `create(SortRelSchema)` to create a new message.
 */
export const SortRelSchema: GenMessage<SortRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 8);

/**
 * The relational operator capturing simple FILTERs (as in the WHERE clause of SQL)
 *
 * @generated from message substrait.FilterRel
 */
export type FilterRel = Message<"substrait.FilterRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: substrait.Expression condition = 3;
   */
  condition?: Expression;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.FilterRel.
 * Use `create(FilterRelSchema)` to create a new message.
 */
export const FilterRelSchema: GenMessage<FilterRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 9);

/**
 * The relational set operators (intersection/union/etc..)
 *
 * @generated from message substrait.SetRel
 */
export type SetRel = Message<"substrait.SetRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * The first input is the primary input, the remaining are secondary
   * inputs.  There must be at least two inputs.
   *
   * @generated from field: repeated substrait.Rel inputs = 2;
   */
  inputs: Rel[];

  /**
   * @generated from field: substrait.SetRel.SetOp op = 3;
   */
  op: SetRel_SetOp;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.SetRel.
 * Use `create(SetRelSchema)` to create a new message.
 */
export const SetRelSchema: GenMessage<SetRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 10);

/**
 * @generated from enum substrait.SetRel.SetOp
 */
export enum SetRel_SetOp {
  /**
   * @generated from enum value: SET_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SET_OP_MINUS_PRIMARY = 1;
   */
  MINUS_PRIMARY = 1,

  /**
   * @generated from enum value: SET_OP_MINUS_PRIMARY_ALL = 7;
   */
  MINUS_PRIMARY_ALL = 7,

  /**
   * @generated from enum value: SET_OP_MINUS_MULTISET = 2;
   */
  MINUS_MULTISET = 2,

  /**
   * @generated from enum value: SET_OP_INTERSECTION_PRIMARY = 3;
   */
  INTERSECTION_PRIMARY = 3,

  /**
   * @generated from enum value: SET_OP_INTERSECTION_MULTISET = 4;
   */
  INTERSECTION_MULTISET = 4,

  /**
   * @generated from enum value: SET_OP_INTERSECTION_MULTISET_ALL = 8;
   */
  INTERSECTION_MULTISET_ALL = 8,

  /**
   * @generated from enum value: SET_OP_UNION_DISTINCT = 5;
   */
  UNION_DISTINCT = 5,

  /**
   * @generated from enum value: SET_OP_UNION_ALL = 6;
   */
  UNION_ALL = 6,
}

/**
 * Describes the enum substrait.SetRel.SetOp.
 */
export const SetRel_SetOpSchema: GenEnum<SetRel_SetOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 10, 0);

/**
 * Stub to support extension with a single input
 *
 * @generated from message substrait.ExtensionSingleRel
 */
export type ExtensionSingleRel = Message<"substrait.ExtensionSingleRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: google.protobuf.Any detail = 3;
   */
  detail?: Any;
};

/**
 * Describes the message substrait.ExtensionSingleRel.
 * Use `create(ExtensionSingleRelSchema)` to create a new message.
 */
export const ExtensionSingleRelSchema: GenMessage<ExtensionSingleRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 11);

/**
 * Stub to support extension with a zero inputs
 *
 * @generated from message substrait.ExtensionLeafRel
 */
export type ExtensionLeafRel = Message<"substrait.ExtensionLeafRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: google.protobuf.Any detail = 2;
   */
  detail?: Any;
};

/**
 * Describes the message substrait.ExtensionLeafRel.
 * Use `create(ExtensionLeafRelSchema)` to create a new message.
 */
export const ExtensionLeafRelSchema: GenMessage<ExtensionLeafRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 12);

/**
 * Stub to support extension with multiple inputs
 *
 * @generated from message substrait.ExtensionMultiRel
 */
export type ExtensionMultiRel = Message<"substrait.ExtensionMultiRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: repeated substrait.Rel inputs = 2;
   */
  inputs: Rel[];

  /**
   * @generated from field: google.protobuf.Any detail = 3;
   */
  detail?: Any;
};

/**
 * Describes the message substrait.ExtensionMultiRel.
 * Use `create(ExtensionMultiRelSchema)` to create a new message.
 */
export const ExtensionMultiRelSchema: GenMessage<ExtensionMultiRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 13);

/**
 * A redistribution operation
 *
 * @generated from message substrait.ExchangeRel
 */
export type ExchangeRel = Message<"substrait.ExchangeRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * @generated from field: int32 partition_count = 3;
   */
  partitionCount: number;

  /**
   * @generated from field: repeated substrait.ExchangeRel.ExchangeTarget targets = 4;
   */
  targets: ExchangeRel_ExchangeTarget[];

  /**
   * the type of exchange used
   *
   * @generated from oneof substrait.ExchangeRel.exchange_kind
   */
  exchangeKind: {
    /**
     * @generated from field: substrait.ExchangeRel.ScatterFields scatter_by_fields = 5;
     */
    value: ExchangeRel_ScatterFields;
    case: "scatterByFields";
  } | {
    /**
     * @generated from field: substrait.ExchangeRel.SingleBucketExpression single_target = 6;
     */
    value: ExchangeRel_SingleBucketExpression;
    case: "singleTarget";
  } | {
    /**
     * @generated from field: substrait.ExchangeRel.MultiBucketExpression multi_target = 7;
     */
    value: ExchangeRel_MultiBucketExpression;
    case: "multiTarget";
  } | {
    /**
     * @generated from field: substrait.ExchangeRel.RoundRobin round_robin = 8;
     */
    value: ExchangeRel_RoundRobin;
    case: "roundRobin";
  } | {
    /**
     * @generated from field: substrait.ExchangeRel.Broadcast broadcast = 9;
     */
    value: ExchangeRel_Broadcast;
    case: "broadcast";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.ExchangeRel.
 * Use `create(ExchangeRelSchema)` to create a new message.
 */
export const ExchangeRelSchema: GenMessage<ExchangeRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14);

/**
 * @generated from message substrait.ExchangeRel.ScatterFields
 */
export type ExchangeRel_ScatterFields = Message<"substrait.ExchangeRel.ScatterFields"> & {
  /**
   * @generated from field: repeated substrait.Expression.FieldReference fields = 1;
   */
  fields: Expression_FieldReference[];
};

/**
 * Describes the message substrait.ExchangeRel.ScatterFields.
 * Use `create(ExchangeRel_ScatterFieldsSchema)` to create a new message.
 */
export const ExchangeRel_ScatterFieldsSchema: GenMessage<ExchangeRel_ScatterFields> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 0);

/**
 * Returns a single bucket number per record.
 *
 * @generated from message substrait.ExchangeRel.SingleBucketExpression
 */
export type ExchangeRel_SingleBucketExpression = Message<"substrait.ExchangeRel.SingleBucketExpression"> & {
  /**
   * @generated from field: substrait.Expression expression = 1;
   */
  expression?: Expression;
};

/**
 * Describes the message substrait.ExchangeRel.SingleBucketExpression.
 * Use `create(ExchangeRel_SingleBucketExpressionSchema)` to create a new message.
 */
export const ExchangeRel_SingleBucketExpressionSchema: GenMessage<ExchangeRel_SingleBucketExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 1);

/**
 * Returns zero or more bucket numbers per record
 *
 * @generated from message substrait.ExchangeRel.MultiBucketExpression
 */
export type ExchangeRel_MultiBucketExpression = Message<"substrait.ExchangeRel.MultiBucketExpression"> & {
  /**
   * @generated from field: substrait.Expression expression = 1;
   */
  expression?: Expression;

  /**
   * @generated from field: bool constrained_to_count = 2;
   */
  constrainedToCount: boolean;
};

/**
 * Describes the message substrait.ExchangeRel.MultiBucketExpression.
 * Use `create(ExchangeRel_MultiBucketExpressionSchema)` to create a new message.
 */
export const ExchangeRel_MultiBucketExpressionSchema: GenMessage<ExchangeRel_MultiBucketExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 2);

/**
 * Send all data to every target.
 *
 * @generated from message substrait.ExchangeRel.Broadcast
 */
export type ExchangeRel_Broadcast = Message<"substrait.ExchangeRel.Broadcast"> & {
};

/**
 * Describes the message substrait.ExchangeRel.Broadcast.
 * Use `create(ExchangeRel_BroadcastSchema)` to create a new message.
 */
export const ExchangeRel_BroadcastSchema: GenMessage<ExchangeRel_Broadcast> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 3);

/**
 * Route approximately
 *
 * @generated from message substrait.ExchangeRel.RoundRobin
 */
export type ExchangeRel_RoundRobin = Message<"substrait.ExchangeRel.RoundRobin"> & {
  /**
   * whether the round robin behavior is required to exact (per record) or
   * approximate. Defaults to approximate.
   *
   * @generated from field: bool exact = 1;
   */
  exact: boolean;
};

/**
 * Describes the message substrait.ExchangeRel.RoundRobin.
 * Use `create(ExchangeRel_RoundRobinSchema)` to create a new message.
 */
export const ExchangeRel_RoundRobinSchema: GenMessage<ExchangeRel_RoundRobin> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 4);

/**
 * The message to describe partition targets of an exchange
 *
 * @generated from message substrait.ExchangeRel.ExchangeTarget
 */
export type ExchangeRel_ExchangeTarget = Message<"substrait.ExchangeRel.ExchangeTarget"> & {
  /**
   * Describes the partition id(s) to send. If this is empty, all data is sent
   * to this target.
   *
   * @generated from field: repeated int32 partition_id = 1;
   */
  partitionId: number[];

  /**
   * @generated from oneof substrait.ExchangeRel.ExchangeTarget.target_type
   */
  targetType: {
    /**
     * @generated from field: string uri = 2;
     */
    value: string;
    case: "uri";
  } | {
    /**
     * @generated from field: google.protobuf.Any extended = 3;
     */
    value: Any;
    case: "extended";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ExchangeRel.ExchangeTarget.
 * Use `create(ExchangeRel_ExchangeTargetSchema)` to create a new message.
 */
export const ExchangeRel_ExchangeTargetSchema: GenMessage<ExchangeRel_ExchangeTarget> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 14, 5);

/**
 * Duplicates records by emitting one or more rows per input row.  The number of rows emitted per
 * input row is the same for all input rows.
 *
 * In addition to a field being emitted per input field an extra int64 field is emitted which
 * contains a zero-indexed ordinal corresponding to the duplicate definition.
 *
 * @generated from message substrait.ExpandRel
 */
export type ExpandRel = Message<"substrait.ExpandRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel input = 2;
   */
  input?: Rel;

  /**
   * There should be one definition here for each input field.  Any fields beyond the provided
   * definitions will be emitted as is (as if a consistent_field record with an identity
   * expression was provided).
   *
   * @generated from field: repeated substrait.ExpandRel.ExpandField fields = 4;
   */
  fields: ExpandRel_ExpandField[];
};

/**
 * Describes the message substrait.ExpandRel.
 * Use `create(ExpandRelSchema)` to create a new message.
 */
export const ExpandRelSchema: GenMessage<ExpandRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 15);

/**
 * @generated from message substrait.ExpandRel.ExpandField
 */
export type ExpandRel_ExpandField = Message<"substrait.ExpandRel.ExpandField"> & {
  /**
   * @generated from oneof substrait.ExpandRel.ExpandField.field_type
   */
  fieldType: {
    /**
     * Field that switches output based on which duplicate is being output.  Every
     * switching_field should contain the same number of duplicates (so that the output rows
     * are of consistent size and type).  If there are not enough switching field definitions
     * to match the other field definitions NULL will be returned to fill the extras.
     *
     * @generated from field: substrait.ExpandRel.SwitchingField switching_field = 2;
     */
    value: ExpandRel_SwitchingField;
    case: "switchingField";
  } | {
    /**
     * Field that outputs the same value no matter which duplicate is being output.  Equivalent
     * to a switching_field that lists the same expression multiple times.
     *
     * @generated from field: substrait.Expression consistent_field = 3;
     */
    value: Expression;
    case: "consistentField";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ExpandRel.ExpandField.
 * Use `create(ExpandRel_ExpandFieldSchema)` to create a new message.
 */
export const ExpandRel_ExpandFieldSchema: GenMessage<ExpandRel_ExpandField> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 15, 0);

/**
 * @generated from message substrait.ExpandRel.SwitchingField
 */
export type ExpandRel_SwitchingField = Message<"substrait.ExpandRel.SwitchingField"> & {
  /**
   * All duplicates must return the same type class but may differ in nullability.  The effective
   * type of the output field will be nullable if any of the duplicate expressions are nullable.
   *
   * @generated from field: repeated substrait.Expression duplicates = 1;
   */
  duplicates: Expression[];
};

/**
 * Describes the message substrait.ExpandRel.SwitchingField.
 * Use `create(ExpandRel_SwitchingFieldSchema)` to create a new message.
 */
export const ExpandRel_SwitchingFieldSchema: GenMessage<ExpandRel_SwitchingField> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 15, 1);

/**
 * A relation with output field names.
 *
 * This is for use at the root of a `Rel` tree.
 *
 * @generated from message substrait.RelRoot
 */
export type RelRoot = Message<"substrait.RelRoot"> & {
  /**
   * A relation
   *
   * @generated from field: substrait.Rel input = 1;
   */
  input?: Rel;

  /**
   * Field names in depth-first order
   *
   * @generated from field: repeated string names = 2;
   */
  names: string[];
};

/**
 * Describes the message substrait.RelRoot.
 * Use `create(RelRootSchema)` to create a new message.
 */
export const RelRootSchema: GenMessage<RelRoot> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 16);

/**
 * A relation (used internally in a plan)
 *
 * @generated from message substrait.Rel
 */
export type Rel = Message<"substrait.Rel"> & {
  /**
   * @generated from oneof substrait.Rel.rel_type
   */
  relType: {
    /**
     * @generated from field: substrait.ReadRel read = 1;
     */
    value: ReadRel;
    case: "read";
  } | {
    /**
     * @generated from field: substrait.FilterRel filter = 2;
     */
    value: FilterRel;
    case: "filter";
  } | {
    /**
     * @generated from field: substrait.FetchRel fetch = 3;
     */
    value: FetchRel;
    case: "fetch";
  } | {
    /**
     * @generated from field: substrait.AggregateRel aggregate = 4;
     */
    value: AggregateRel;
    case: "aggregate";
  } | {
    /**
     * @generated from field: substrait.SortRel sort = 5;
     */
    value: SortRel;
    case: "sort";
  } | {
    /**
     * @generated from field: substrait.JoinRel join = 6;
     */
    value: JoinRel;
    case: "join";
  } | {
    /**
     * @generated from field: substrait.ProjectRel project = 7;
     */
    value: ProjectRel;
    case: "project";
  } | {
    /**
     * @generated from field: substrait.SetRel set = 8;
     */
    value: SetRel;
    case: "set";
  } | {
    /**
     * @generated from field: substrait.ExtensionSingleRel extension_single = 9;
     */
    value: ExtensionSingleRel;
    case: "extensionSingle";
  } | {
    /**
     * @generated from field: substrait.ExtensionMultiRel extension_multi = 10;
     */
    value: ExtensionMultiRel;
    case: "extensionMulti";
  } | {
    /**
     * @generated from field: substrait.ExtensionLeafRel extension_leaf = 11;
     */
    value: ExtensionLeafRel;
    case: "extensionLeaf";
  } | {
    /**
     * @generated from field: substrait.CrossRel cross = 12;
     */
    value: CrossRel;
    case: "cross";
  } | {
    /**
     * @generated from field: substrait.ReferenceRel reference = 21;
     */
    value: ReferenceRel;
    case: "reference";
  } | {
    /**
     * @generated from field: substrait.WriteRel write = 19;
     */
    value: WriteRel;
    case: "write";
  } | {
    /**
     * @generated from field: substrait.DdlRel ddl = 20;
     */
    value: DdlRel;
    case: "ddl";
  } | {
    /**
     * @generated from field: substrait.UpdateRel update = 22;
     */
    value: UpdateRel;
    case: "update";
  } | {
    /**
     * Physical relations
     *
     * @generated from field: substrait.HashJoinRel hash_join = 13;
     */
    value: HashJoinRel;
    case: "hashJoin";
  } | {
    /**
     * @generated from field: substrait.MergeJoinRel merge_join = 14;
     */
    value: MergeJoinRel;
    case: "mergeJoin";
  } | {
    /**
     * @generated from field: substrait.NestedLoopJoinRel nested_loop_join = 18;
     */
    value: NestedLoopJoinRel;
    case: "nestedLoopJoin";
  } | {
    /**
     * @generated from field: substrait.ConsistentPartitionWindowRel window = 17;
     */
    value: ConsistentPartitionWindowRel;
    case: "window";
  } | {
    /**
     * @generated from field: substrait.ExchangeRel exchange = 15;
     */
    value: ExchangeRel;
    case: "exchange";
  } | {
    /**
     * @generated from field: substrait.ExpandRel expand = 16;
     */
    value: ExpandRel;
    case: "expand";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Rel.
 * Use `create(RelSchema)` to create a new message.
 */
export const RelSchema: GenMessage<Rel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 17);

/**
 * A base object for writing (e.g., a table or a view).
 *
 * @generated from message substrait.NamedObjectWrite
 */
export type NamedObjectWrite = Message<"substrait.NamedObjectWrite"> & {
  /**
   * The list of string is used to represent namespacing (e.g., mydb.mytable).
   * This assumes shared catalog between systems exchanging a message.
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.NamedObjectWrite.
 * Use `create(NamedObjectWriteSchema)` to create a new message.
 */
export const NamedObjectWriteSchema: GenMessage<NamedObjectWrite> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 18);

/**
 * A stub type that can be used to extend/introduce new table types outside
 * the specification.
 *
 * @generated from message substrait.ExtensionObject
 */
export type ExtensionObject = Message<"substrait.ExtensionObject"> & {
  /**
   * @generated from field: google.protobuf.Any detail = 1;
   */
  detail?: Any;
};

/**
 * Describes the message substrait.ExtensionObject.
 * Use `create(ExtensionObjectSchema)` to create a new message.
 */
export const ExtensionObjectSchema: GenMessage<ExtensionObject> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 19);

/**
 * @generated from message substrait.DdlRel
 */
export type DdlRel = Message<"substrait.DdlRel"> & {
  /**
   * Definition of which type of object we are operating on
   *
   * @generated from oneof substrait.DdlRel.write_type
   */
  writeType: {
    /**
     * @generated from field: substrait.NamedObjectWrite named_object = 1;
     */
    value: NamedObjectWrite;
    case: "namedObject";
  } | {
    /**
     * @generated from field: substrait.ExtensionObject extension_object = 2;
     */
    value: ExtensionObject;
    case: "extensionObject";
  } | { case: undefined; value?: undefined };

  /**
   * The columns that will be modified (representing after-image of a schema change)
   *
   * @generated from field: substrait.NamedStruct table_schema = 3;
   */
  tableSchema?: NamedStruct;

  /**
   * The default values for the columns (representing after-image of a schema change)
   * E.g., in case of an ALTER TABLE that changes some of the column default values, we expect
   * the table_defaults Struct to report a full list of default values reflecting the result of applying
   * the ALTER TABLE operator successfully
   *
   * @generated from field: substrait.Expression.Literal.Struct table_defaults = 4;
   */
  tableDefaults?: Expression_Literal_Struct;

  /**
   * Which type of object we operate on
   *
   * @generated from field: substrait.DdlRel.DdlObject object = 5;
   */
  object: DdlRel_DdlObject;

  /**
   * The type of operation to perform
   *
   * @generated from field: substrait.DdlRel.DdlOp op = 6;
   */
  op: DdlRel_DdlOp;

  /**
   * The body of the CREATE VIEW
   *
   * @generated from field: substrait.Rel view_definition = 7;
   */
  viewDefinition?: Rel;

  /**
   * @generated from field: substrait.RelCommon common = 8;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 9;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.DdlRel.
 * Use `create(DdlRelSchema)` to create a new message.
 */
export const DdlRelSchema: GenMessage<DdlRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 20);

/**
 * @generated from enum substrait.DdlRel.DdlObject
 */
export enum DdlRel_DdlObject {
  /**
   * @generated from enum value: DDL_OBJECT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * A Table object in the system
   *
   * @generated from enum value: DDL_OBJECT_TABLE = 1;
   */
  TABLE = 1,

  /**
   * A View object in the system
   *
   * @generated from enum value: DDL_OBJECT_VIEW = 2;
   */
  VIEW = 2,
}

/**
 * Describes the enum substrait.DdlRel.DdlObject.
 */
export const DdlRel_DdlObjectSchema: GenEnum<DdlRel_DdlObject> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 20, 0);

/**
 * @generated from enum substrait.DdlRel.DdlOp
 */
export enum DdlRel_DdlOp {
  /**
   * @generated from enum value: DDL_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * A create operation (for any object)
   *
   * @generated from enum value: DDL_OP_CREATE = 1;
   */
  CREATE = 1,

  /**
   * A create operation if the object does not exist, or replaces it (equivalent to a DROP + CREATE) if the object already exists
   *
   * @generated from enum value: DDL_OP_CREATE_OR_REPLACE = 2;
   */
  CREATE_OR_REPLACE = 2,

  /**
   * An operation that modifies the schema (e.g., column names, types, default values) for the target object
   *
   * @generated from enum value: DDL_OP_ALTER = 3;
   */
  ALTER = 3,

  /**
   * An operation that removes an object from the system
   *
   * @generated from enum value: DDL_OP_DROP = 4;
   */
  DROP = 4,

  /**
   * An operation that removes an object from the system (without throwing an exception if the object did not exist)
   *
   * @generated from enum value: DDL_OP_DROP_IF_EXIST = 5;
   */
  DROP_IF_EXIST = 5,
}

/**
 * Describes the enum substrait.DdlRel.DdlOp.
 */
export const DdlRel_DdlOpSchema: GenEnum<DdlRel_DdlOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 20, 1);

/**
 * The operator that modifies the content of a database (operates on 1 table at a time, but record-selection/source can be
 * based on joining of multiple tables).
 *
 * @generated from message substrait.WriteRel
 */
export type WriteRel = Message<"substrait.WriteRel"> & {
  /**
   * Definition of which TABLE we are operating on
   *
   * @generated from oneof substrait.WriteRel.write_type
   */
  writeType: {
    /**
     * @generated from field: substrait.NamedObjectWrite named_table = 1;
     */
    value: NamedObjectWrite;
    case: "namedTable";
  } | {
    /**
     * @generated from field: substrait.ExtensionObject extension_table = 2;
     */
    value: ExtensionObject;
    case: "extensionTable";
  } | { case: undefined; value?: undefined };

  /**
   * The schema of the table (must align with Rel input (e.g., number of leaf fields must match))
   *
   * @generated from field: substrait.NamedStruct table_schema = 3;
   */
  tableSchema?: NamedStruct;

  /**
   * The type of operation to perform
   *
   * @generated from field: substrait.WriteRel.WriteOp op = 4;
   */
  op: WriteRel_WriteOp;

  /**
   * The relation that determines the records to add/remove/modify
   * the schema must match with table_schema. Default values must be explicitly stated
   * in a ProjectRel at the top of the input. The match must also
   * occur in case of DELETE to ensure multi-engine plans are unequivocal.
   *
   * @generated from field: substrait.Rel input = 5;
   */
  input?: Rel;

  /**
   * Used with CTAS to determine what to do if the table already exists
   *
   * @generated from field: substrait.WriteRel.CreateMode create_mode = 8;
   */
  createMode: WriteRel_CreateMode;

  /**
   * Output mode determines what is the output of executing this rel
   *
   * @generated from field: substrait.WriteRel.OutputMode output = 6;
   */
  output: WriteRel_OutputMode;

  /**
   * @generated from field: substrait.RelCommon common = 7;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 9;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.WriteRel.
 * Use `create(WriteRelSchema)` to create a new message.
 */
export const WriteRelSchema: GenMessage<WriteRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 21);

/**
 * @generated from enum substrait.WriteRel.WriteOp
 */
export enum WriteRel_WriteOp {
  /**
   * @generated from enum value: WRITE_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The insert of new records in a table
   *
   * @generated from enum value: WRITE_OP_INSERT = 1;
   */
  INSERT = 1,

  /**
   * The removal of records from a table
   *
   * @generated from enum value: WRITE_OP_DELETE = 2;
   */
  DELETE = 2,

  /**
   * The modification of existing records within a table
   *
   * @generated from enum value: WRITE_OP_UPDATE = 3;
   */
  UPDATE = 3,

  /**
   * The Creation of a new table, and the insert of new records in the table
   *
   * @generated from enum value: WRITE_OP_CTAS = 4;
   */
  CTAS = 4,
}

/**
 * Describes the enum substrait.WriteRel.WriteOp.
 */
export const WriteRel_WriteOpSchema: GenEnum<WriteRel_WriteOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 21, 0);

/**
 * @generated from enum substrait.WriteRel.CreateMode
 */
export enum WriteRel_CreateMode {
  /**
   * @generated from enum value: CREATE_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Append the data to the table if it already exists
   *
   * @generated from enum value: CREATE_MODE_APPEND_IF_EXISTS = 1;
   */
  APPEND_IF_EXISTS = 1,

  /**
   * Replace the table if it already exists ("OR REPLACE")
   *
   * @generated from enum value: CREATE_MODE_REPLACE_IF_EXISTS = 2;
   */
  REPLACE_IF_EXISTS = 2,

  /**
   * Ignore the request if the table already exists ("IF NOT EXISTS")
   *
   * @generated from enum value: CREATE_MODE_IGNORE_IF_EXISTS = 3;
   */
  IGNORE_IF_EXISTS = 3,

  /**
   * Throw an error if the table already exists (default behavior)
   *
   * @generated from enum value: CREATE_MODE_ERROR_IF_EXISTS = 4;
   */
  ERROR_IF_EXISTS = 4,
}

/**
 * Describes the enum substrait.WriteRel.CreateMode.
 */
export const WriteRel_CreateModeSchema: GenEnum<WriteRel_CreateMode> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 21, 1);

/**
 * @generated from enum substrait.WriteRel.OutputMode
 */
export enum WriteRel_OutputMode {
  /**
   * @generated from enum value: OUTPUT_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * return no records at all
   *
   * @generated from enum value: OUTPUT_MODE_NO_OUTPUT = 1;
   */
  NO_OUTPUT = 1,

  /**
   * this mode makes the operator return all the record INSERTED/DELETED/UPDATED by the operator.
   * The operator returns the AFTER-image of any change. This can be further manipulated by operators upstreams
   * (e.g., retunring the typical "count of modified records").
   * For scenarios in which the BEFORE image is required, the user must implement a spool (via references to
   * subplans in the body of the Rel input) and return those with anounter PlanRel.relations.
   *
   * @generated from enum value: OUTPUT_MODE_MODIFIED_RECORDS = 2;
   */
  MODIFIED_RECORDS = 2,
}

/**
 * Describes the enum substrait.WriteRel.OutputMode.
 */
export const WriteRel_OutputModeSchema: GenEnum<WriteRel_OutputMode> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 21, 2);

/**
 * The operator that modifies the columns of a table
 *
 * @generated from message substrait.UpdateRel
 */
export type UpdateRel = Message<"substrait.UpdateRel"> & {
  /**
   * @generated from oneof substrait.UpdateRel.update_type
   */
  updateType: {
    /**
     * @generated from field: substrait.NamedTable named_table = 1;
     */
    value: NamedTable;
    case: "namedTable";
  } | { case: undefined; value?: undefined };

  /**
   * The full schema of the named_table
   *
   * @generated from field: substrait.NamedStruct table_schema = 2;
   */
  tableSchema?: NamedStruct;

  /**
   * condition to be met for the update to be applied on a record
   *
   * @generated from field: substrait.Expression condition = 3;
   */
  condition?: Expression;

  /**
   * The list of transformations to apply to the columns of the named_table
   *
   * @generated from field: repeated substrait.UpdateRel.TransformExpression transformations = 4;
   */
  transformations: UpdateRel_TransformExpression[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 5;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.UpdateRel.
 * Use `create(UpdateRelSchema)` to create a new message.
 */
export const UpdateRelSchema: GenMessage<UpdateRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 22);

/**
 * @generated from message substrait.UpdateRel.TransformExpression
 */
export type UpdateRel_TransformExpression = Message<"substrait.UpdateRel.TransformExpression"> & {
  /**
   * the transformation to apply
   *
   * @generated from field: substrait.Expression transformation = 1;
   */
  transformation?: Expression;

  /**
   * index of the column to apply the transformation to
   *
   * @generated from field: int32 column_target = 2;
   */
  columnTarget: number;
};

/**
 * Describes the message substrait.UpdateRel.TransformExpression.
 * Use `create(UpdateRel_TransformExpressionSchema)` to create a new message.
 */
export const UpdateRel_TransformExpressionSchema: GenMessage<UpdateRel_TransformExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 22, 0);

/**
 * A base table. The list of string is used to represent namespacing (e.g., mydb.mytable).
 * This assumes shared catalog between systems exchanging a message.
 *
 * @generated from message substrait.NamedTable
 */
export type NamedTable = Message<"substrait.NamedTable"> & {
  /**
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.NamedTable.
 * Use `create(NamedTableSchema)` to create a new message.
 */
export const NamedTableSchema: GenMessage<NamedTable> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 23);

/**
 * Hash joins and merge joins are a specialization of the general join where the join
 * expression is an series of comparisons between fields that are ANDed together.  The
 * behavior of this comparison is flexible
 *
 * @generated from message substrait.ComparisonJoinKey
 */
export type ComparisonJoinKey = Message<"substrait.ComparisonJoinKey"> & {
  /**
   * The key to compare from the left table
   *
   * @generated from field: substrait.Expression.FieldReference left = 1;
   */
  left?: Expression_FieldReference;

  /**
   * The key to compare from the right table
   *
   * @generated from field: substrait.Expression.FieldReference right = 2;
   */
  right?: Expression_FieldReference;

  /**
   * Describes how to compare the two keys
   *
   * @generated from field: substrait.ComparisonJoinKey.ComparisonType comparison = 3;
   */
  comparison?: ComparisonJoinKey_ComparisonType;
};

/**
 * Describes the message substrait.ComparisonJoinKey.
 * Use `create(ComparisonJoinKeySchema)` to create a new message.
 */
export const ComparisonJoinKeySchema: GenMessage<ComparisonJoinKey> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 24);

/**
 * Describes how the relation should consider if two rows are a match
 *
 * @generated from message substrait.ComparisonJoinKey.ComparisonType
 */
export type ComparisonJoinKey_ComparisonType = Message<"substrait.ComparisonJoinKey.ComparisonType"> & {
  /**
   * @generated from oneof substrait.ComparisonJoinKey.ComparisonType.inner_type
   */
  innerType: {
    /**
     * One of the simple comparison behaviors is used
     *
     * @generated from field: substrait.ComparisonJoinKey.SimpleComparisonType simple = 1;
     */
    value: ComparisonJoinKey_SimpleComparisonType;
    case: "simple";
  } | {
    /**
     * A custom comparison behavior is used.  This can happen, for example, when using
     * collations, where we might want to do something like a case-insensitive comparison.
     *
     * This must be a binary function with a boolean return type
     *
     * @generated from field: uint32 custom_function_reference = 2;
     */
    value: number;
    case: "customFunctionReference";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.ComparisonJoinKey.ComparisonType.
 * Use `create(ComparisonJoinKey_ComparisonTypeSchema)` to create a new message.
 */
export const ComparisonJoinKey_ComparisonTypeSchema: GenMessage<ComparisonJoinKey_ComparisonType> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 24, 0);

/**
 * Most joins will use one of the following behaviors.  To avoid the complexity
 * of a function lookup we define the common behaviors here
 *
 * @generated from enum substrait.ComparisonJoinKey.SimpleComparisonType
 */
export enum ComparisonJoinKey_SimpleComparisonType {
  /**
   * @generated from enum value: SIMPLE_COMPARISON_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Returns true only if both values are equal and not null
   *
   * @generated from enum value: SIMPLE_COMPARISON_TYPE_EQ = 1;
   */
  EQ = 1,

  /**
   * Returns true if both values are equal and not null
   * Returns true if both values are null
   * Returns false if one value is null and the other value is not null
   *
   * This can be expressed as a = b OR (isnull(a) AND isnull(b))
   *
   * @generated from enum value: SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM = 2;
   */
  IS_NOT_DISTINCT_FROM = 2,

  /**
   * Returns true if both values are equal and not null
   * Returns true if either value is null
   *
   * This can be expressed as a = b OR isnull(a = b)
   *
   * @generated from enum value: SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL = 3;
   */
  MIGHT_EQUAL = 3,
}

/**
 * Describes the enum substrait.ComparisonJoinKey.SimpleComparisonType.
 */
export const ComparisonJoinKey_SimpleComparisonTypeSchema: GenEnum<ComparisonJoinKey_SimpleComparisonType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 24, 0);

/**
 * The hash equijoin join operator will build a hash table out of the right input based on a set of join keys.
 * It will then probe that hash table for incoming inputs, finding matches.
 *
 * Two rows are a match if the comparison function returns true for all keys
 *
 * @generated from message substrait.HashJoinRel
 */
export type HashJoinRel = Message<"substrait.HashJoinRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel left = 2;
   */
  left?: Rel;

  /**
   * @generated from field: substrait.Rel right = 3;
   */
  right?: Rel;

  /**
   * These fields are deprecated in favor of `keys`.  If they are set then
   * the two lists (left_keys and right_keys) must have the same length and
   * the comparion function is considered to be SimpleEqualityType::EQ
   *
   * @generated from field: repeated substrait.Expression.FieldReference left_keys = 4 [deprecated = true];
   * @deprecated
   */
  leftKeys: Expression_FieldReference[];

  /**
   * @generated from field: repeated substrait.Expression.FieldReference right_keys = 5 [deprecated = true];
   * @deprecated
   */
  rightKeys: Expression_FieldReference[];

  /**
   * One or more keys to join on.  The relation is invalid if this is empty
   * (unless the deprecated left_keys/right_keys fields are being used).
   *
   * If a custom comparison function is used then it must be consistent with
   * the hash function used for the keys.
   *
   * In other words, the hash function must return the same hash code when the
   * comparison returns true.  For example, if the comparison function is
   * "equals ignoring case" then the hash function must return the same hash
   * code for strings that differ only by case.  Note: the hash function is not
   * specified here.  It is the responsibility of the consumer to find an appropriate
   * hash function for a given comparsion function or to reject the plan if it cannot
   * do so.
   *
   * @generated from field: repeated substrait.ComparisonJoinKey keys = 8;
   */
  keys: ComparisonJoinKey[];

  /**
   * @generated from field: substrait.Expression post_join_filter = 6;
   */
  postJoinFilter?: Expression;

  /**
   * @generated from field: substrait.HashJoinRel.JoinType type = 7;
   */
  type: HashJoinRel_JoinType;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.HashJoinRel.
 * Use `create(HashJoinRelSchema)` to create a new message.
 */
export const HashJoinRelSchema: GenMessage<HashJoinRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 25);

/**
 * @generated from enum substrait.HashJoinRel.JoinType
 */
export enum HashJoinRel_JoinType {
  /**
   * @generated from enum value: JOIN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: JOIN_TYPE_INNER = 1;
   */
  INNER = 1,

  /**
   * @generated from enum value: JOIN_TYPE_OUTER = 2;
   */
  OUTER = 2,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT = 3;
   */
  LEFT = 3,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT = 4;
   */
  RIGHT = 4,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SEMI = 5;
   */
  LEFT_SEMI = 5,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SEMI = 6;
   */
  RIGHT_SEMI = 6,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_ANTI = 7;
   */
  LEFT_ANTI = 7,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_ANTI = 8;
   */
  RIGHT_ANTI = 8,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SINGLE = 9;
   */
  LEFT_SINGLE = 9,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SINGLE = 10;
   */
  RIGHT_SINGLE = 10,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_MARK = 11;
   */
  LEFT_MARK = 11,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_MARK = 12;
   */
  RIGHT_MARK = 12,
}

/**
 * Describes the enum substrait.HashJoinRel.JoinType.
 */
export const HashJoinRel_JoinTypeSchema: GenEnum<HashJoinRel_JoinType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 25, 0);

/**
 * The merge equijoin does a join by taking advantage of two sets that are sorted on the join keys.
 * This allows the join operation to be done in a streaming fashion.
 *
 * @generated from message substrait.MergeJoinRel
 */
export type MergeJoinRel = Message<"substrait.MergeJoinRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel left = 2;
   */
  left?: Rel;

  /**
   * @generated from field: substrait.Rel right = 3;
   */
  right?: Rel;

  /**
   * These fields are deprecated in favor of `keys`.  If they are set then
   * the two lists (left_keys and right_keys) must have the same length and
   * the comparion function is considered to be SimpleEqualityType::EQ
   *
   * @generated from field: repeated substrait.Expression.FieldReference left_keys = 4 [deprecated = true];
   * @deprecated
   */
  leftKeys: Expression_FieldReference[];

  /**
   * @generated from field: repeated substrait.Expression.FieldReference right_keys = 5 [deprecated = true];
   * @deprecated
   */
  rightKeys: Expression_FieldReference[];

  /**
   * One or more keys to join on.  The relation is invalid if this is empty
   * (unless the deprecated left_keys/right_keys fields are being used).
   *
   * If a custom comparison function is used then it must be consistent with
   * the ordering of the input data.  For example, if the comparison function
   * is "<" then we generally expect the data to be sorted in ascending order.
   *
   * If the comparison function is something like "less than ignoring case" then
   * the data should be sorted appropriately (e.g. both "A" and "a" should come
   * before "b")
   *
   * The sort order is not specified here.  It is typically the responsibility of
   * the producer to ensure the plan sorts the data if needed (although the consumer
   * is free to do so as well).  If possible, the consumer should verify the sort
   * order and reject invalid plans.
   *
   * @generated from field: repeated substrait.ComparisonJoinKey keys = 8;
   */
  keys: ComparisonJoinKey[];

  /**
   * @generated from field: substrait.Expression post_join_filter = 6;
   */
  postJoinFilter?: Expression;

  /**
   * @generated from field: substrait.MergeJoinRel.JoinType type = 7;
   */
  type: MergeJoinRel_JoinType;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.MergeJoinRel.
 * Use `create(MergeJoinRelSchema)` to create a new message.
 */
export const MergeJoinRelSchema: GenMessage<MergeJoinRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 26);

/**
 * @generated from enum substrait.MergeJoinRel.JoinType
 */
export enum MergeJoinRel_JoinType {
  /**
   * @generated from enum value: JOIN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: JOIN_TYPE_INNER = 1;
   */
  INNER = 1,

  /**
   * @generated from enum value: JOIN_TYPE_OUTER = 2;
   */
  OUTER = 2,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT = 3;
   */
  LEFT = 3,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT = 4;
   */
  RIGHT = 4,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SEMI = 5;
   */
  LEFT_SEMI = 5,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SEMI = 6;
   */
  RIGHT_SEMI = 6,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_ANTI = 7;
   */
  LEFT_ANTI = 7,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_ANTI = 8;
   */
  RIGHT_ANTI = 8,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SINGLE = 9;
   */
  LEFT_SINGLE = 9,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SINGLE = 10;
   */
  RIGHT_SINGLE = 10,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_MARK = 11;
   */
  LEFT_MARK = 11,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_MARK = 12;
   */
  RIGHT_MARK = 12,
}

/**
 * Describes the enum substrait.MergeJoinRel.JoinType.
 */
export const MergeJoinRel_JoinTypeSchema: GenEnum<MergeJoinRel_JoinType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 26, 0);

/**
 * The nested loop join (NLJ) operator will hold the entire right input and iterate over it using the
 * left input, evaluating the join expression on the Cartesian product of all rows.
 *
 * @generated from message substrait.NestedLoopJoinRel
 */
export type NestedLoopJoinRel = Message<"substrait.NestedLoopJoinRel"> & {
  /**
   * @generated from field: substrait.RelCommon common = 1;
   */
  common?: RelCommon;

  /**
   * @generated from field: substrait.Rel left = 2;
   */
  left?: Rel;

  /**
   * @generated from field: substrait.Rel right = 3;
   */
  right?: Rel;

  /**
   * optional, defaults to true (a cartesian join)
   *
   * @generated from field: substrait.Expression expression = 4;
   */
  expression?: Expression;

  /**
   * @generated from field: substrait.NestedLoopJoinRel.JoinType type = 5;
   */
  type: NestedLoopJoinRel_JoinType;

  /**
   * @generated from field: substrait.extensions.AdvancedExtension advanced_extension = 10;
   */
  advancedExtension?: AdvancedExtension;
};

/**
 * Describes the message substrait.NestedLoopJoinRel.
 * Use `create(NestedLoopJoinRelSchema)` to create a new message.
 */
export const NestedLoopJoinRelSchema: GenMessage<NestedLoopJoinRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 27);

/**
 * @generated from enum substrait.NestedLoopJoinRel.JoinType
 */
export enum NestedLoopJoinRel_JoinType {
  /**
   * @generated from enum value: JOIN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: JOIN_TYPE_INNER = 1;
   */
  INNER = 1,

  /**
   * @generated from enum value: JOIN_TYPE_OUTER = 2;
   */
  OUTER = 2,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT = 3;
   */
  LEFT = 3,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT = 4;
   */
  RIGHT = 4,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SEMI = 5;
   */
  LEFT_SEMI = 5,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SEMI = 6;
   */
  RIGHT_SEMI = 6,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_ANTI = 7;
   */
  LEFT_ANTI = 7,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_ANTI = 8;
   */
  RIGHT_ANTI = 8,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_SINGLE = 9;
   */
  LEFT_SINGLE = 9,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_SINGLE = 10;
   */
  RIGHT_SINGLE = 10,

  /**
   * @generated from enum value: JOIN_TYPE_LEFT_MARK = 11;
   */
  LEFT_MARK = 11,

  /**
   * @generated from enum value: JOIN_TYPE_RIGHT_MARK = 12;
   */
  RIGHT_MARK = 12,
}

/**
 * Describes the enum substrait.NestedLoopJoinRel.JoinType.
 */
export const NestedLoopJoinRel_JoinTypeSchema: GenEnum<NestedLoopJoinRel_JoinType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 27, 0);

/**
 * The argument of a function
 *
 * @generated from message substrait.FunctionArgument
 */
export type FunctionArgument = Message<"substrait.FunctionArgument"> & {
  /**
   * @generated from oneof substrait.FunctionArgument.arg_type
   */
  argType: {
    /**
     * @generated from field: string enum = 1;
     */
    value: string;
    case: "enum";
  } | {
    /**
     * @generated from field: substrait.Type type = 2;
     */
    value: Type;
    case: "type";
  } | {
    /**
     * @generated from field: substrait.Expression value = 3;
     */
    value: Expression;
    case: "value";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.FunctionArgument.
 * Use `create(FunctionArgumentSchema)` to create a new message.
 */
export const FunctionArgumentSchema: GenMessage<FunctionArgument> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 28);

/**
 * An optional function argument.  Typically used for specifying behavior in
 * invalid or corner cases.
 *
 * @generated from message substrait.FunctionOption
 */
export type FunctionOption = Message<"substrait.FunctionOption"> & {
  /**
   * Name of the option to set. If the consumer does not recognize the
   * option, it must reject the plan. The name is matched case-insensitively
   * with option names defined for the function.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * List of behavior options allowed by the producer. At least one must be
   * specified; to leave an option unspecified, simply don't add an entry to
   * `options`. The consumer must use the first option from the list that it
   * supports. If the consumer supports none of the specified options, it
   * must reject the plan. The name is matched case-insensitively and must
   * match one of the option values defined for the option.
   *
   * @generated from field: repeated string preference = 2;
   */
  preference: string[];
};

/**
 * Describes the message substrait.FunctionOption.
 * Use `create(FunctionOptionSchema)` to create a new message.
 */
export const FunctionOptionSchema: GenMessage<FunctionOption> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 29);

/**
 * @generated from message substrait.Expression
 */
export type Expression = Message<"substrait.Expression"> & {
  /**
   * @generated from oneof substrait.Expression.rex_type
   */
  rexType: {
    /**
     * @generated from field: substrait.Expression.Literal literal = 1;
     */
    value: Expression_Literal;
    case: "literal";
  } | {
    /**
     * @generated from field: substrait.Expression.FieldReference selection = 2;
     */
    value: Expression_FieldReference;
    case: "selection";
  } | {
    /**
     * @generated from field: substrait.Expression.ScalarFunction scalar_function = 3;
     */
    value: Expression_ScalarFunction;
    case: "scalarFunction";
  } | {
    /**
     * @generated from field: substrait.Expression.WindowFunction window_function = 5;
     */
    value: Expression_WindowFunction;
    case: "windowFunction";
  } | {
    /**
     * @generated from field: substrait.Expression.IfThen if_then = 6;
     */
    value: Expression_IfThen;
    case: "ifThen";
  } | {
    /**
     * @generated from field: substrait.Expression.SwitchExpression switch_expression = 7;
     */
    value: Expression_SwitchExpression;
    case: "switchExpression";
  } | {
    /**
     * @generated from field: substrait.Expression.SingularOrList singular_or_list = 8;
     */
    value: Expression_SingularOrList;
    case: "singularOrList";
  } | {
    /**
     * @generated from field: substrait.Expression.MultiOrList multi_or_list = 9;
     */
    value: Expression_MultiOrList;
    case: "multiOrList";
  } | {
    /**
     * @generated from field: substrait.Expression.Cast cast = 11;
     */
    value: Expression_Cast;
    case: "cast";
  } | {
    /**
     * @generated from field: substrait.Expression.Subquery subquery = 12;
     */
    value: Expression_Subquery;
    case: "subquery";
  } | {
    /**
     * @generated from field: substrait.Expression.Nested nested = 13;
     */
    value: Expression_Nested;
    case: "nested";
  } | {
    /**
     * @generated from field: substrait.DynamicParameter dynamic_parameter = 14;
     */
    value: DynamicParameter;
    case: "dynamicParameter";
  } | {
    /**
     * deprecated: enum literals are only sensible in the context of
     * function arguments, for which FunctionArgument should now be
     * used
     *
     * @generated from field: substrait.Expression.Enum enum = 10 [deprecated = true];
     * @deprecated
     */
    value: Expression_Enum;
    case: "enum";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.
 * Use `create(ExpressionSchema)` to create a new message.
 */
export const ExpressionSchema: GenMessage<Expression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30);

/**
 * @generated from message substrait.Expression.Enum
 * @deprecated
 */
export type Expression_Enum = Message<"substrait.Expression.Enum"> & {
  /**
   * @generated from oneof substrait.Expression.Enum.enum_kind
   * @deprecated
   */
  enumKind: {
    /**
     * @generated from field: string specified = 1;
     */
    value: string;
    case: "specified";
  } | {
    /**
     * @generated from field: substrait.Expression.Enum.Empty unspecified = 2;
     */
    value: Expression_Enum_Empty;
    case: "unspecified";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.Enum.
 * Use `create(Expression_EnumSchema)` to create a new message.
 * @deprecated
 */
export const Expression_EnumSchema: GenMessage<Expression_Enum> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 0);

/**
 * @generated from message substrait.Expression.Enum.Empty
 * @deprecated
 */
export type Expression_Enum_Empty = Message<"substrait.Expression.Enum.Empty"> & {
};

/**
 * Describes the message substrait.Expression.Enum.Empty.
 * Use `create(Expression_Enum_EmptySchema)` to create a new message.
 * @deprecated
 */
export const Expression_Enum_EmptySchema: GenMessage<Expression_Enum_Empty> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 0, 0);

/**
 * @generated from message substrait.Expression.Literal
 */
export type Expression_Literal = Message<"substrait.Expression.Literal"> & {
  /**
   * @generated from oneof substrait.Expression.Literal.literal_type
   */
  literalType: {
    /**
     * @generated from field: bool boolean = 1;
     */
    value: boolean;
    case: "boolean";
  } | {
    /**
     * @generated from field: int32 i8 = 2;
     */
    value: number;
    case: "i8";
  } | {
    /**
     * @generated from field: int32 i16 = 3;
     */
    value: number;
    case: "i16";
  } | {
    /**
     * @generated from field: int32 i32 = 5;
     */
    value: number;
    case: "i32";
  } | {
    /**
     * @generated from field: int64 i64 = 7;
     */
    value: bigint;
    case: "i64";
  } | {
    /**
     * @generated from field: float fp32 = 10;
     */
    value: number;
    case: "fp32";
  } | {
    /**
     * @generated from field: double fp64 = 11;
     */
    value: number;
    case: "fp64";
  } | {
    /**
     * @generated from field: string string = 12;
     */
    value: string;
    case: "string";
  } | {
    /**
     * @generated from field: bytes binary = 13;
     */
    value: Uint8Array;
    case: "binary";
  } | {
    /**
     * Timestamp in units of microseconds since the UNIX epoch.
     * Deprecated in favor of `precision_timestamp`
     *
     * @generated from field: int64 timestamp = 14 [deprecated = true];
     * @deprecated
     */
    value: bigint;
    case: "timestamp";
  } | {
    /**
     * Date in units of days since the UNIX epoch.
     *
     * @generated from field: int32 date = 16;
     */
    value: number;
    case: "date";
  } | {
    /**
     * Time in units of microseconds past midnight
     *
     * @generated from field: int64 time = 17;
     */
    value: bigint;
    case: "time";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 19;
     */
    value: Expression_Literal_IntervalYearToMonth;
    case: "intervalYearToMonth";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 20;
     */
    value: Expression_Literal_IntervalDayToSecond;
    case: "intervalDayToSecond";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.IntervalCompound interval_compound = 36;
     */
    value: Expression_Literal_IntervalCompound;
    case: "intervalCompound";
  } | {
    /**
     * @generated from field: string fixed_char = 21;
     */
    value: string;
    case: "fixedChar";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.VarChar var_char = 22;
     */
    value: Expression_Literal_VarChar;
    case: "varChar";
  } | {
    /**
     * @generated from field: bytes fixed_binary = 23;
     */
    value: Uint8Array;
    case: "fixedBinary";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.Decimal decimal = 24;
     */
    value: Expression_Literal_Decimal;
    case: "decimal";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.PrecisionTimestamp precision_timestamp = 34;
     */
    value: Expression_Literal_PrecisionTimestamp;
    case: "precisionTimestamp";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.PrecisionTimestamp precision_timestamp_tz = 35;
     */
    value: Expression_Literal_PrecisionTimestamp;
    case: "precisionTimestampTz";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.Struct struct = 25;
     */
    value: Expression_Literal_Struct;
    case: "struct";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.Map map = 26;
     */
    value: Expression_Literal_Map;
    case: "map";
  } | {
    /**
     * Timestamp in units of microseconds since the UNIX epoch.
     * Deprecated in favor of `precision_timestamp_tz`
     *
     * @generated from field: int64 timestamp_tz = 27 [deprecated = true];
     * @deprecated
     */
    value: bigint;
    case: "timestampTz";
  } | {
    /**
     * @generated from field: bytes uuid = 28;
     */
    value: Uint8Array;
    case: "uuid";
  } | {
    /**
     * a typed null literal
     *
     * @generated from field: substrait.Type null = 29;
     */
    value: Type;
    case: "null";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.List list = 30;
     */
    value: Expression_Literal_List;
    case: "list";
  } | {
    /**
     * @generated from field: substrait.Type.List empty_list = 31;
     */
    value: Type_List;
    case: "emptyList";
  } | {
    /**
     * @generated from field: substrait.Type.Map empty_map = 32;
     */
    value: Type_Map;
    case: "emptyMap";
  } | {
    /**
     * @generated from field: substrait.Expression.Literal.UserDefined user_defined = 33;
     */
    value: Expression_Literal_UserDefined;
    case: "userDefined";
  } | { case: undefined; value?: undefined };

  /**
   * Whether the literal_type above should be treated as a nullable type.
   * Applies to all members of the literal_type oneof EXCEPT:
   *  * Type null             (must be nullable by definition)
   *  * Type.List empty_list  (use Type.List::nullability)
   *  * Type.Map empty_map    (use Type.Map::nullability)
   *
   * @generated from field: bool nullable = 50;
   */
  nullable: boolean;

  /**
   * optionally points to a type_variation_anchor defined in this plan.
   * Applies to all members of union other than the Typed null (which should
   * directly declare the type variation).
   *
   * @generated from field: uint32 type_variation_reference = 51;
   */
  typeVariationReference: number;
};

/**
 * Describes the message substrait.Expression.Literal.
 * Use `create(Expression_LiteralSchema)` to create a new message.
 */
export const Expression_LiteralSchema: GenMessage<Expression_Literal> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1);

/**
 * @generated from message substrait.Expression.Literal.VarChar
 */
export type Expression_Literal_VarChar = Message<"substrait.Expression.Literal.VarChar"> & {
  /**
   * @generated from field: string value = 1;
   */
  value: string;

  /**
   * @generated from field: uint32 length = 2;
   */
  length: number;
};

/**
 * Describes the message substrait.Expression.Literal.VarChar.
 * Use `create(Expression_Literal_VarCharSchema)` to create a new message.
 */
export const Expression_Literal_VarCharSchema: GenMessage<Expression_Literal_VarChar> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 0);

/**
 * @generated from message substrait.Expression.Literal.Decimal
 */
export type Expression_Literal_Decimal = Message<"substrait.Expression.Literal.Decimal"> & {
  /**
   * little-endian twos-complement integer representation of complete value
   * (ignoring precision) Always 16 bytes in length
   *
   * @generated from field: bytes value = 1;
   */
  value: Uint8Array;

  /**
   * The maximum number of digits allowed in the value.
   * the maximum precision is 38.
   *
   * @generated from field: int32 precision = 2;
   */
  precision: number;

  /**
   * declared scale of decimal literal
   *
   * @generated from field: int32 scale = 3;
   */
  scale: number;
};

/**
 * Describes the message substrait.Expression.Literal.Decimal.
 * Use `create(Expression_Literal_DecimalSchema)` to create a new message.
 */
export const Expression_Literal_DecimalSchema: GenMessage<Expression_Literal_Decimal> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 1);

/**
 * @generated from message substrait.Expression.Literal.PrecisionTimestamp
 */
export type Expression_Literal_PrecisionTimestamp = Message<"substrait.Expression.Literal.PrecisionTimestamp"> & {
  /**
   * Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds, 12 is picoseconds
   *
   * @generated from field: int32 precision = 1;
   */
  precision: number;

  /**
   * Time passed since 1970-01-01 00:00:00.000000 in UTC for PrecisionTimestampTZ and unspecified timezone for PrecisionTimestamp
   *
   * @generated from field: int64 value = 2;
   */
  value: bigint;
};

/**
 * Describes the message substrait.Expression.Literal.PrecisionTimestamp.
 * Use `create(Expression_Literal_PrecisionTimestampSchema)` to create a new message.
 */
export const Expression_Literal_PrecisionTimestampSchema: GenMessage<Expression_Literal_PrecisionTimestamp> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 2);

/**
 * @generated from message substrait.Expression.Literal.Map
 */
export type Expression_Literal_Map = Message<"substrait.Expression.Literal.Map"> & {
  /**
   * @generated from field: repeated substrait.Expression.Literal.Map.KeyValue key_values = 1;
   */
  keyValues: Expression_Literal_Map_KeyValue[];
};

/**
 * Describes the message substrait.Expression.Literal.Map.
 * Use `create(Expression_Literal_MapSchema)` to create a new message.
 */
export const Expression_Literal_MapSchema: GenMessage<Expression_Literal_Map> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 3);

/**
 * @generated from message substrait.Expression.Literal.Map.KeyValue
 */
export type Expression_Literal_Map_KeyValue = Message<"substrait.Expression.Literal.Map.KeyValue"> & {
  /**
   * @generated from field: substrait.Expression.Literal key = 1;
   */
  key?: Expression_Literal;

  /**
   * @generated from field: substrait.Expression.Literal value = 2;
   */
  value?: Expression_Literal;
};

/**
 * Describes the message substrait.Expression.Literal.Map.KeyValue.
 * Use `create(Expression_Literal_Map_KeyValueSchema)` to create a new message.
 */
export const Expression_Literal_Map_KeyValueSchema: GenMessage<Expression_Literal_Map_KeyValue> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 3, 0);

/**
 * @generated from message substrait.Expression.Literal.IntervalYearToMonth
 */
export type Expression_Literal_IntervalYearToMonth = Message<"substrait.Expression.Literal.IntervalYearToMonth"> & {
  /**
   * @generated from field: int32 years = 1;
   */
  years: number;

  /**
   * @generated from field: int32 months = 2;
   */
  months: number;
};

/**
 * Describes the message substrait.Expression.Literal.IntervalYearToMonth.
 * Use `create(Expression_Literal_IntervalYearToMonthSchema)` to create a new message.
 */
export const Expression_Literal_IntervalYearToMonthSchema: GenMessage<Expression_Literal_IntervalYearToMonth> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 4);

/**
 * @generated from message substrait.Expression.Literal.IntervalDayToSecond
 */
export type Expression_Literal_IntervalDayToSecond = Message<"substrait.Expression.Literal.IntervalDayToSecond"> & {
  /**
   * @generated from field: int32 days = 1;
   */
  days: number;

  /**
   * @generated from field: int32 seconds = 2;
   */
  seconds: number;

  /**
   * Consumers should expect either (miroseconds) to be set or (precision and subseconds) to be set
   *
   * @generated from oneof substrait.Expression.Literal.IntervalDayToSecond.precision_mode
   */
  precisionMode: {
    /**
     * use precision and subseconds below, they cover and replace microseconds.
     *
     * @generated from field: int32 microseconds = 3 [deprecated = true];
     * @deprecated
     */
    value: number;
    case: "microseconds";
  } | {
    /**
     * Sub-second precision, 0 means the value given is in seconds, 3 is milliseconds, 6 microseconds, 9 is nanoseconds. Should be used with subseconds below.
     *
     * @generated from field: int32 precision = 4;
     */
    value: number;
    case: "precision";
  } | { case: undefined; value?: undefined };

  /**
   * the number of fractional seconds using 1e(-precision) units. Should only be used with precision field, not microseconds.
   *
   * @generated from field: int64 subseconds = 5;
   */
  subseconds: bigint;
};

/**
 * Describes the message substrait.Expression.Literal.IntervalDayToSecond.
 * Use `create(Expression_Literal_IntervalDayToSecondSchema)` to create a new message.
 */
export const Expression_Literal_IntervalDayToSecondSchema: GenMessage<Expression_Literal_IntervalDayToSecond> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 5);

/**
 * @generated from message substrait.Expression.Literal.IntervalCompound
 */
export type Expression_Literal_IntervalCompound = Message<"substrait.Expression.Literal.IntervalCompound"> & {
  /**
   * @generated from field: substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 1;
   */
  intervalYearToMonth?: Expression_Literal_IntervalYearToMonth;

  /**
   * @generated from field: substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 2;
   */
  intervalDayToSecond?: Expression_Literal_IntervalDayToSecond;
};

/**
 * Describes the message substrait.Expression.Literal.IntervalCompound.
 * Use `create(Expression_Literal_IntervalCompoundSchema)` to create a new message.
 */
export const Expression_Literal_IntervalCompoundSchema: GenMessage<Expression_Literal_IntervalCompound> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 6);

/**
 * @generated from message substrait.Expression.Literal.Struct
 */
export type Expression_Literal_Struct = Message<"substrait.Expression.Literal.Struct"> & {
  /**
   * A possibly heterogeneously typed list of literals
   *
   * @generated from field: repeated substrait.Expression.Literal fields = 1;
   */
  fields: Expression_Literal[];
};

/**
 * Describes the message substrait.Expression.Literal.Struct.
 * Use `create(Expression_Literal_StructSchema)` to create a new message.
 */
export const Expression_Literal_StructSchema: GenMessage<Expression_Literal_Struct> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 7);

/**
 * @generated from message substrait.Expression.Literal.List
 */
export type Expression_Literal_List = Message<"substrait.Expression.Literal.List"> & {
  /**
   * A homogeneously typed list of literals
   *
   * @generated from field: repeated substrait.Expression.Literal values = 1;
   */
  values: Expression_Literal[];
};

/**
 * Describes the message substrait.Expression.Literal.List.
 * Use `create(Expression_Literal_ListSchema)` to create a new message.
 */
export const Expression_Literal_ListSchema: GenMessage<Expression_Literal_List> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 8);

/**
 * @generated from message substrait.Expression.Literal.UserDefined
 */
export type Expression_Literal_UserDefined = Message<"substrait.Expression.Literal.UserDefined"> & {
  /**
   * points to a type_anchor defined in this plan
   *
   * @generated from field: uint32 type_reference = 1;
   */
  typeReference: number;

  /**
   * The parameters to be bound to the type class, if the type class is
   * parameterizable.
   *
   * @generated from field: repeated substrait.Type.Parameter type_parameters = 3;
   */
  typeParameters: Type_Parameter[];

  /**
   * a user-defined literal can be encoded in one of two ways
   *
   * @generated from oneof substrait.Expression.Literal.UserDefined.val
   */
  val: {
    /**
     * the value of the literal, serialized using some type-specific protobuf message
     *
     * @generated from field: google.protobuf.Any value = 2;
     */
    value: Any;
    case: "value";
  } | {
    /**
     * the value of the literal, serialized using the structure definition in its declaration
     *
     * @generated from field: substrait.Expression.Literal.Struct struct = 4;
     */
    value: Expression_Literal_Struct;
    case: "struct";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.Literal.UserDefined.
 * Use `create(Expression_Literal_UserDefinedSchema)` to create a new message.
 */
export const Expression_Literal_UserDefinedSchema: GenMessage<Expression_Literal_UserDefined> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 1, 9);

/**
 * Expression to dynamically construct nested types.
 *
 * @generated from message substrait.Expression.Nested
 */
export type Expression_Nested = Message<"substrait.Expression.Nested"> & {
  /**
   * Whether the returned nested type is nullable.
   *
   * @generated from field: bool nullable = 1;
   */
  nullable: boolean;

  /**
   * Optionally points to a type_variation_anchor defined in this plan for
   * the returned nested type.
   *
   * @generated from field: uint32 type_variation_reference = 2;
   */
  typeVariationReference: number;

  /**
   * @generated from oneof substrait.Expression.Nested.nested_type
   */
  nestedType: {
    /**
     * @generated from field: substrait.Expression.Nested.Struct struct = 3;
     */
    value: Expression_Nested_Struct;
    case: "struct";
  } | {
    /**
     * @generated from field: substrait.Expression.Nested.List list = 4;
     */
    value: Expression_Nested_List;
    case: "list";
  } | {
    /**
     * @generated from field: substrait.Expression.Nested.Map map = 5;
     */
    value: Expression_Nested_Map;
    case: "map";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.Nested.
 * Use `create(Expression_NestedSchema)` to create a new message.
 */
export const Expression_NestedSchema: GenMessage<Expression_Nested> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 2);

/**
 * @generated from message substrait.Expression.Nested.Map
 */
export type Expression_Nested_Map = Message<"substrait.Expression.Nested.Map"> & {
  /**
   * One or more key-value pairs. To specify an empty map, use
   * Literal.empty_map (otherwise type information would be missing).
   *
   * @generated from field: repeated substrait.Expression.Nested.Map.KeyValue key_values = 1;
   */
  keyValues: Expression_Nested_Map_KeyValue[];
};

/**
 * Describes the message substrait.Expression.Nested.Map.
 * Use `create(Expression_Nested_MapSchema)` to create a new message.
 */
export const Expression_Nested_MapSchema: GenMessage<Expression_Nested_Map> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 2, 0);

/**
 * @generated from message substrait.Expression.Nested.Map.KeyValue
 */
export type Expression_Nested_Map_KeyValue = Message<"substrait.Expression.Nested.Map.KeyValue"> & {
  /**
   * Mandatory key/value expressions.
   *
   * @generated from field: substrait.Expression key = 1;
   */
  key?: Expression;

  /**
   * @generated from field: substrait.Expression value = 2;
   */
  value?: Expression;
};

/**
 * Describes the message substrait.Expression.Nested.Map.KeyValue.
 * Use `create(Expression_Nested_Map_KeyValueSchema)` to create a new message.
 */
export const Expression_Nested_Map_KeyValueSchema: GenMessage<Expression_Nested_Map_KeyValue> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 2, 0, 0);

/**
 * @generated from message substrait.Expression.Nested.Struct
 */
export type Expression_Nested_Struct = Message<"substrait.Expression.Nested.Struct"> & {
  /**
   * Zero or more possibly heterogeneously-typed list of expressions that
   * form the struct fields.
   *
   * @generated from field: repeated substrait.Expression fields = 1;
   */
  fields: Expression[];
};

/**
 * Describes the message substrait.Expression.Nested.Struct.
 * Use `create(Expression_Nested_StructSchema)` to create a new message.
 */
export const Expression_Nested_StructSchema: GenMessage<Expression_Nested_Struct> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 2, 1);

/**
 * @generated from message substrait.Expression.Nested.List
 */
export type Expression_Nested_List = Message<"substrait.Expression.Nested.List"> & {
  /**
   * A homogeneously-typed list of one or more expressions that form the
   * list entries. To specify an empty list, use Literal.empty_list
   * (otherwise type information would be missing).
   *
   * @generated from field: repeated substrait.Expression values = 1;
   */
  values: Expression[];
};

/**
 * Describes the message substrait.Expression.Nested.List.
 * Use `create(Expression_Nested_ListSchema)` to create a new message.
 */
export const Expression_Nested_ListSchema: GenMessage<Expression_Nested_List> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 2, 2);

/**
 * A scalar function call.
 *
 * @generated from message substrait.Expression.ScalarFunction
 */
export type Expression_ScalarFunction = Message<"substrait.Expression.ScalarFunction"> & {
  /**
   * Points to a function_anchor defined in this plan, which must refer
   * to a scalar function in the associated YAML file. Required; avoid
   * using anchor/reference zero.
   *
   * @generated from field: uint32 function_reference = 1;
   */
  functionReference: number;

  /**
   * The arguments to be bound to the function. This must have exactly the
   * number of arguments specified in the function definition, and the
   * argument types must also match exactly:
   *
   *  - Value arguments must be bound using FunctionArgument.value, and
   *    the expression in that must yield a value of a type that a function
   *    overload is defined for.
   *  - Type arguments must be bound using FunctionArgument.type.
   *  - Enum arguments must be bound using FunctionArgument.enum
   *    followed by Enum.specified, with a string that case-insensitively
   *    matches one of the allowed options.
   *
   * @generated from field: repeated substrait.FunctionArgument arguments = 4;
   */
  arguments: FunctionArgument[];

  /**
   * Options to specify behavior for corner cases, or leave behavior
   * unspecified if the consumer does not need specific behavior in these
   * cases.
   *
   * @generated from field: repeated substrait.FunctionOption options = 5;
   */
  options: FunctionOption[];

  /**
   * Must be set to the return type of the function, exactly as derived
   * using the declaration in the extension.
   *
   * @generated from field: substrait.Type output_type = 3;
   */
  outputType?: Type;

  /**
   * Deprecated; use arguments instead.
   *
   * @generated from field: repeated substrait.Expression args = 2 [deprecated = true];
   * @deprecated
   */
  args: Expression[];
};

/**
 * Describes the message substrait.Expression.ScalarFunction.
 * Use `create(Expression_ScalarFunctionSchema)` to create a new message.
 */
export const Expression_ScalarFunctionSchema: GenMessage<Expression_ScalarFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 3);

/**
 * A window function call.
 *
 * @generated from message substrait.Expression.WindowFunction
 */
export type Expression_WindowFunction = Message<"substrait.Expression.WindowFunction"> & {
  /**
   * Points to a function_anchor defined in this plan. The function must be:
   *  - a window function
   *  - an aggregate function
   *
   * An aggregate function referenced here should be treated as a window
   * function with Window Type STREAMING
   *
   * Required; 0 is considered to be a valid anchor/reference.
   *
   * @generated from field: uint32 function_reference = 1;
   */
  functionReference: number;

  /**
   * The arguments to be bound to the function. This must have exactly the
   * number of arguments specified in the function definition, and the
   * argument types must also match exactly:
   *
   *  - Value arguments must be bound using FunctionArgument.value, and
   *    the expression in that must yield a value of a type that a function
   *    overload is defined for.
   *  - Type arguments must be bound using FunctionArgument.type, and a
   *    function overload must be defined for that type.
   *  - Enum arguments must be bound using FunctionArgument.enum
   *    followed by Enum.specified, with a string that case-insensitively
   *    matches one of the allowed options.
   *
   * @generated from field: repeated substrait.FunctionArgument arguments = 9;
   */
  arguments: FunctionArgument[];

  /**
   * Options to specify behavior for corner cases, or leave behavior
   * unspecified if the consumer does not need specific behavior in these
   * cases.
   *
   * @generated from field: repeated substrait.FunctionOption options = 11;
   */
  options: FunctionOption[];

  /**
   * Must be set to the return type of the function, exactly as derived
   * using the declaration in the extension.
   *
   * @generated from field: substrait.Type output_type = 7;
   */
  outputType?: Type;

  /**
   * Describes which part of the window function to perform within the
   * context of distributed algorithms. Required. Must be set to
   * INITIAL_TO_RESULT for window functions that are not decomposable.
   *
   * @generated from field: substrait.AggregationPhase phase = 6;
   */
  phase: AggregationPhase;

  /**
   * If specified, the records that are part of the window defined by
   * upper_bound and lower_bound are ordered according to this list
   * before they are aggregated. The first sort field has the highest
   * priority; only if a sort field determines two records to be equivalent
   * is the next field queried. This field is optional, and is only allowed
   * if the window function is defined to support sorting.
   *
   * @generated from field: repeated substrait.SortField sorts = 3;
   */
  sorts: SortField[];

  /**
   * Specifies whether equivalent records are merged before being aggregated.
   * Optional, defaults to AGGREGATION_INVOCATION_ALL.
   *
   * @generated from field: substrait.AggregateFunction.AggregationInvocation invocation = 10;
   */
  invocation: AggregateFunction_AggregationInvocation;

  /**
   * When one or more partition expressions are specified, two records are
   * considered to be in the same partition if and only if these expressions
   * yield an equal record of values for both. When computing the window
   * function, only the subset of records within the bounds that are also in
   * the same partition as the current record are aggregated.
   *
   * @generated from field: repeated substrait.Expression partitions = 2;
   */
  partitions: Expression[];

  /**
   * Defines the bounds type: ROWS, RANGE
   *
   * @generated from field: substrait.Expression.WindowFunction.BoundsType bounds_type = 12;
   */
  boundsType: Expression_WindowFunction_BoundsType;

  /**
   * Defines the record relative to the current record from which the window
   * extends. The bound is inclusive. If the lower bound indexes a record
   * greater than the upper bound, TODO (null range/no records passed?
   * wrapping around as if lower/upper were swapped? error? null?).
   * Optional; defaults to the start of the partition.
   *
   * @generated from field: substrait.Expression.WindowFunction.Bound lower_bound = 5;
   */
  lowerBound?: Expression_WindowFunction_Bound;

  /**
   * Defines the record relative to the current record up to which the window
   * extends. The bound is inclusive. If the upper bound indexes a record
   * less than the lower bound, TODO (null range/no records passed?
   * wrapping around as if lower/upper were swapped? error? null?).
   * Optional; defaults to the end of the partition.
   *
   * @generated from field: substrait.Expression.WindowFunction.Bound upper_bound = 4;
   */
  upperBound?: Expression_WindowFunction_Bound;

  /**
   * Deprecated; use arguments instead.
   *
   * @generated from field: repeated substrait.Expression args = 8 [deprecated = true];
   * @deprecated
   */
  args: Expression[];
};

/**
 * Describes the message substrait.Expression.WindowFunction.
 * Use `create(Expression_WindowFunctionSchema)` to create a new message.
 */
export const Expression_WindowFunctionSchema: GenMessage<Expression_WindowFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 4);

/**
 * Defines one of the two boundaries for the window of a window function.
 *
 * @generated from message substrait.Expression.WindowFunction.Bound
 */
export type Expression_WindowFunction_Bound = Message<"substrait.Expression.WindowFunction.Bound"> & {
  /**
   * @generated from oneof substrait.Expression.WindowFunction.Bound.kind
   */
  kind: {
    /**
     * The bound extends some number of records behind the current record.
     *
     * @generated from field: substrait.Expression.WindowFunction.Bound.Preceding preceding = 1;
     */
    value: Expression_WindowFunction_Bound_Preceding;
    case: "preceding";
  } | {
    /**
     * The bound extends some number of records ahead of the current
     * record.
     *
     * @generated from field: substrait.Expression.WindowFunction.Bound.Following following = 2;
     */
    value: Expression_WindowFunction_Bound_Following;
    case: "following";
  } | {
    /**
     * The bound extends to the current record.
     *
     * @generated from field: substrait.Expression.WindowFunction.Bound.CurrentRow current_row = 3;
     */
    value: Expression_WindowFunction_Bound_CurrentRow;
    case: "currentRow";
  } | {
    /**
     * The bound extends to the start of the partition or the end of the
     * partition, depending on whether this represents the upper or lower
     * bound.
     *
     * @generated from field: substrait.Expression.WindowFunction.Bound.Unbounded unbounded = 4;
     */
    value: Expression_WindowFunction_Bound_Unbounded;
    case: "unbounded";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.WindowFunction.Bound.
 * Use `create(Expression_WindowFunction_BoundSchema)` to create a new message.
 */
export const Expression_WindowFunction_BoundSchema: GenMessage<Expression_WindowFunction_Bound> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 4, 0);

/**
 * Defines that the bound extends this far back from the current record.
 *
 * @generated from message substrait.Expression.WindowFunction.Bound.Preceding
 */
export type Expression_WindowFunction_Bound_Preceding = Message<"substrait.Expression.WindowFunction.Bound.Preceding"> & {
  /**
   * A strictly positive integer specifying the number of records that
   * the window extends back from the current record. Required. Use
   * CurrentRow for offset zero and Following for negative offsets.
   *
   * @generated from field: int64 offset = 1;
   */
  offset: bigint;
};

/**
 * Describes the message substrait.Expression.WindowFunction.Bound.Preceding.
 * Use `create(Expression_WindowFunction_Bound_PrecedingSchema)` to create a new message.
 */
export const Expression_WindowFunction_Bound_PrecedingSchema: GenMessage<Expression_WindowFunction_Bound_Preceding> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 4, 0, 0);

/**
 * Defines that the bound extends this far ahead of the current record.
 *
 * @generated from message substrait.Expression.WindowFunction.Bound.Following
 */
export type Expression_WindowFunction_Bound_Following = Message<"substrait.Expression.WindowFunction.Bound.Following"> & {
  /**
   * A strictly positive integer specifying the number of records that
   * the window extends ahead of the current record. Required. Use
   * CurrentRow for offset zero and Preceding for negative offsets.
   *
   * @generated from field: int64 offset = 1;
   */
  offset: bigint;
};

/**
 * Describes the message substrait.Expression.WindowFunction.Bound.Following.
 * Use `create(Expression_WindowFunction_Bound_FollowingSchema)` to create a new message.
 */
export const Expression_WindowFunction_Bound_FollowingSchema: GenMessage<Expression_WindowFunction_Bound_Following> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 4, 0, 1);

/**
 * Defines that the bound extends to or from the current record.
 *
 * @generated from message substrait.Expression.WindowFunction.Bound.CurrentRow
 */
export type Expression_WindowFunction_Bound_CurrentRow = Message<"substrait.Expression.WindowFunction.Bound.CurrentRow"> & {
};

/**
 * Describes the message substrait.Expression.WindowFunction.Bound.CurrentRow.
 * Use `create(Expression_WindowFunction_Bound_CurrentRowSchema)` to create a new message.
 */
export const Expression_WindowFunction_Bound_CurrentRowSchema: GenMessage<Expression_WindowFunction_Bound_CurrentRow> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 4, 0, 2);

/**
 * Defines an "unbounded bound": for lower bounds this means the start
 * of the partition, and for upper bounds this means the end of the
 * partition.
 *
 * @generated from message substrait.Expression.WindowFunction.Bound.Unbounded
 */
export type Expression_WindowFunction_Bound_Unbounded = Message<"substrait.Expression.WindowFunction.Bound.Unbounded"> & {
};

/**
 * Describes the message substrait.Expression.WindowFunction.Bound.Unbounded.
 * Use `create(Expression_WindowFunction_Bound_UnboundedSchema)` to create a new message.
 */
export const Expression_WindowFunction_Bound_UnboundedSchema: GenMessage<Expression_WindowFunction_Bound_Unbounded> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 4, 0, 3);

/**
 * @generated from enum substrait.Expression.WindowFunction.BoundsType
 */
export enum Expression_WindowFunction_BoundsType {
  /**
   * @generated from enum value: BOUNDS_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The lower and upper bound specify how many rows before and after the current row
   * the window should extend.
   *
   * @generated from enum value: BOUNDS_TYPE_ROWS = 1;
   */
  ROWS = 1,

  /**
   * The lower and upper bound describe a range of values.  The window should include all rows
   * where the value of the ordering column is greater than or equal to (current_value - lower bound)
   * and less than or equal to (current_value + upper bound).  This bounds type is only valid if there
   * is a single ordering column.
   *
   * @generated from enum value: BOUNDS_TYPE_RANGE = 2;
   */
  RANGE = 2,
}

/**
 * Describes the enum substrait.Expression.WindowFunction.BoundsType.
 */
export const Expression_WindowFunction_BoundsTypeSchema: GenEnum<Expression_WindowFunction_BoundsType> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 30, 4, 0);

/**
 * @generated from message substrait.Expression.IfThen
 */
export type Expression_IfThen = Message<"substrait.Expression.IfThen"> & {
  /**
   * A list of one or more IfClauses
   *
   * @generated from field: repeated substrait.Expression.IfThen.IfClause ifs = 1;
   */
  ifs: Expression_IfThen_IfClause[];

  /**
   * The returned Expression if no IfClauses are satisified
   *
   * @generated from field: substrait.Expression else = 2;
   */
  else?: Expression;
};

/**
 * Describes the message substrait.Expression.IfThen.
 * Use `create(Expression_IfThenSchema)` to create a new message.
 */
export const Expression_IfThenSchema: GenMessage<Expression_IfThen> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 5);

/**
 * @generated from message substrait.Expression.IfThen.IfClause
 */
export type Expression_IfThen_IfClause = Message<"substrait.Expression.IfThen.IfClause"> & {
  /**
   * @generated from field: substrait.Expression if = 1;
   */
  if?: Expression;

  /**
   * @generated from field: substrait.Expression then = 2;
   */
  then?: Expression;
};

/**
 * Describes the message substrait.Expression.IfThen.IfClause.
 * Use `create(Expression_IfThen_IfClauseSchema)` to create a new message.
 */
export const Expression_IfThen_IfClauseSchema: GenMessage<Expression_IfThen_IfClause> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 5, 0);

/**
 * @generated from message substrait.Expression.Cast
 */
export type Expression_Cast = Message<"substrait.Expression.Cast"> & {
  /**
   * @generated from field: substrait.Type type = 1;
   */
  type?: Type;

  /**
   * @generated from field: substrait.Expression input = 2;
   */
  input?: Expression;

  /**
   * @generated from field: substrait.Expression.Cast.FailureBehavior failure_behavior = 3;
   */
  failureBehavior: Expression_Cast_FailureBehavior;
};

/**
 * Describes the message substrait.Expression.Cast.
 * Use `create(Expression_CastSchema)` to create a new message.
 */
export const Expression_CastSchema: GenMessage<Expression_Cast> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 6);

/**
 * @generated from enum substrait.Expression.Cast.FailureBehavior
 */
export enum Expression_Cast_FailureBehavior {
  /**
   * @generated from enum value: FAILURE_BEHAVIOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FAILURE_BEHAVIOR_RETURN_NULL = 1;
   */
  RETURN_NULL = 1,

  /**
   * @generated from enum value: FAILURE_BEHAVIOR_THROW_EXCEPTION = 2;
   */
  THROW_EXCEPTION = 2,
}

/**
 * Describes the enum substrait.Expression.Cast.FailureBehavior.
 */
export const Expression_Cast_FailureBehaviorSchema: GenEnum<Expression_Cast_FailureBehavior> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 30, 6, 0);

/**
 * @generated from message substrait.Expression.SwitchExpression
 */
export type Expression_SwitchExpression = Message<"substrait.Expression.SwitchExpression"> & {
  /**
   * @generated from field: substrait.Expression match = 3;
   */
  match?: Expression;

  /**
   * @generated from field: repeated substrait.Expression.SwitchExpression.IfValue ifs = 1;
   */
  ifs: Expression_SwitchExpression_IfValue[];

  /**
   * @generated from field: substrait.Expression else = 2;
   */
  else?: Expression;
};

/**
 * Describes the message substrait.Expression.SwitchExpression.
 * Use `create(Expression_SwitchExpressionSchema)` to create a new message.
 */
export const Expression_SwitchExpressionSchema: GenMessage<Expression_SwitchExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 7);

/**
 * @generated from message substrait.Expression.SwitchExpression.IfValue
 */
export type Expression_SwitchExpression_IfValue = Message<"substrait.Expression.SwitchExpression.IfValue"> & {
  /**
   * @generated from field: substrait.Expression.Literal if = 1;
   */
  if?: Expression_Literal;

  /**
   * @generated from field: substrait.Expression then = 2;
   */
  then?: Expression;
};

/**
 * Describes the message substrait.Expression.SwitchExpression.IfValue.
 * Use `create(Expression_SwitchExpression_IfValueSchema)` to create a new message.
 */
export const Expression_SwitchExpression_IfValueSchema: GenMessage<Expression_SwitchExpression_IfValue> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 7, 0);

/**
 * @generated from message substrait.Expression.SingularOrList
 */
export type Expression_SingularOrList = Message<"substrait.Expression.SingularOrList"> & {
  /**
   * @generated from field: substrait.Expression value = 1;
   */
  value?: Expression;

  /**
   * @generated from field: repeated substrait.Expression options = 2;
   */
  options: Expression[];
};

/**
 * Describes the message substrait.Expression.SingularOrList.
 * Use `create(Expression_SingularOrListSchema)` to create a new message.
 */
export const Expression_SingularOrListSchema: GenMessage<Expression_SingularOrList> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 8);

/**
 * @generated from message substrait.Expression.MultiOrList
 */
export type Expression_MultiOrList = Message<"substrait.Expression.MultiOrList"> & {
  /**
   * @generated from field: repeated substrait.Expression value = 1;
   */
  value: Expression[];

  /**
   * @generated from field: repeated substrait.Expression.MultiOrList.Record options = 2;
   */
  options: Expression_MultiOrList_Record[];
};

/**
 * Describes the message substrait.Expression.MultiOrList.
 * Use `create(Expression_MultiOrListSchema)` to create a new message.
 */
export const Expression_MultiOrListSchema: GenMessage<Expression_MultiOrList> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 9);

/**
 * @generated from message substrait.Expression.MultiOrList.Record
 */
export type Expression_MultiOrList_Record = Message<"substrait.Expression.MultiOrList.Record"> & {
  /**
   * @generated from field: repeated substrait.Expression fields = 1;
   */
  fields: Expression[];
};

/**
 * Describes the message substrait.Expression.MultiOrList.Record.
 * Use `create(Expression_MultiOrList_RecordSchema)` to create a new message.
 */
export const Expression_MultiOrList_RecordSchema: GenMessage<Expression_MultiOrList_Record> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 9, 0);

/**
 * @generated from message substrait.Expression.EmbeddedFunction
 */
export type Expression_EmbeddedFunction = Message<"substrait.Expression.EmbeddedFunction"> & {
  /**
   * @generated from field: repeated substrait.Expression arguments = 1;
   */
  arguments: Expression[];

  /**
   * @generated from field: substrait.Type output_type = 2;
   */
  outputType?: Type;

  /**
   * @generated from oneof substrait.Expression.EmbeddedFunction.kind
   */
  kind: {
    /**
     * @generated from field: substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function = 3;
     */
    value: Expression_EmbeddedFunction_PythonPickleFunction;
    case: "pythonPickleFunction";
  } | {
    /**
     * @generated from field: substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function = 4;
     */
    value: Expression_EmbeddedFunction_WebAssemblyFunction;
    case: "webAssemblyFunction";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.EmbeddedFunction.
 * Use `create(Expression_EmbeddedFunctionSchema)` to create a new message.
 */
export const Expression_EmbeddedFunctionSchema: GenMessage<Expression_EmbeddedFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 10);

/**
 * @generated from message substrait.Expression.EmbeddedFunction.PythonPickleFunction
 */
export type Expression_EmbeddedFunction_PythonPickleFunction = Message<"substrait.Expression.EmbeddedFunction.PythonPickleFunction"> & {
  /**
   * @generated from field: bytes function = 1;
   */
  function: Uint8Array;

  /**
   * @generated from field: repeated string prerequisite = 2;
   */
  prerequisite: string[];
};

/**
 * Describes the message substrait.Expression.EmbeddedFunction.PythonPickleFunction.
 * Use `create(Expression_EmbeddedFunction_PythonPickleFunctionSchema)` to create a new message.
 */
export const Expression_EmbeddedFunction_PythonPickleFunctionSchema: GenMessage<Expression_EmbeddedFunction_PythonPickleFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 10, 0);

/**
 * @generated from message substrait.Expression.EmbeddedFunction.WebAssemblyFunction
 */
export type Expression_EmbeddedFunction_WebAssemblyFunction = Message<"substrait.Expression.EmbeddedFunction.WebAssemblyFunction"> & {
  /**
   * @generated from field: bytes script = 1;
   */
  script: Uint8Array;

  /**
   * @generated from field: repeated string prerequisite = 2;
   */
  prerequisite: string[];
};

/**
 * Describes the message substrait.Expression.EmbeddedFunction.WebAssemblyFunction.
 * Use `create(Expression_EmbeddedFunction_WebAssemblyFunctionSchema)` to create a new message.
 */
export const Expression_EmbeddedFunction_WebAssemblyFunctionSchema: GenMessage<Expression_EmbeddedFunction_WebAssemblyFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 10, 1);

/**
 * A way to reference the inner property of a complex record. Can reference
 * either a map key by literal, a struct field by the ordinal position of
 * the desired field or a particular element in an array. Supports
 * expressions that would roughly translate to something similar to:
 * a.b[2].c['my_map_key'].x where a,b,c and x are struct field references
 * (ordinalized in the internal representation here), [2] is a list offset
 * and ['my_map_key'] is a reference into a map field.
 *
 * @generated from message substrait.Expression.ReferenceSegment
 */
export type Expression_ReferenceSegment = Message<"substrait.Expression.ReferenceSegment"> & {
  /**
   * @generated from oneof substrait.Expression.ReferenceSegment.reference_type
   */
  referenceType: {
    /**
     * @generated from field: substrait.Expression.ReferenceSegment.MapKey map_key = 1;
     */
    value: Expression_ReferenceSegment_MapKey;
    case: "mapKey";
  } | {
    /**
     * @generated from field: substrait.Expression.ReferenceSegment.StructField struct_field = 2;
     */
    value: Expression_ReferenceSegment_StructField;
    case: "structField";
  } | {
    /**
     * @generated from field: substrait.Expression.ReferenceSegment.ListElement list_element = 3;
     */
    value: Expression_ReferenceSegment_ListElement;
    case: "listElement";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.ReferenceSegment.
 * Use `create(Expression_ReferenceSegmentSchema)` to create a new message.
 */
export const Expression_ReferenceSegmentSchema: GenMessage<Expression_ReferenceSegment> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 11);

/**
 * @generated from message substrait.Expression.ReferenceSegment.MapKey
 */
export type Expression_ReferenceSegment_MapKey = Message<"substrait.Expression.ReferenceSegment.MapKey"> & {
  /**
   * literal based reference to specific possible value in map.
   *
   * @generated from field: substrait.Expression.Literal map_key = 1;
   */
  mapKey?: Expression_Literal;

  /**
   * Optional child segment
   *
   * @generated from field: substrait.Expression.ReferenceSegment child = 2;
   */
  child?: Expression_ReferenceSegment;
};

/**
 * Describes the message substrait.Expression.ReferenceSegment.MapKey.
 * Use `create(Expression_ReferenceSegment_MapKeySchema)` to create a new message.
 */
export const Expression_ReferenceSegment_MapKeySchema: GenMessage<Expression_ReferenceSegment_MapKey> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 11, 0);

/**
 * @generated from message substrait.Expression.ReferenceSegment.StructField
 */
export type Expression_ReferenceSegment_StructField = Message<"substrait.Expression.ReferenceSegment.StructField"> & {
  /**
   * zero-indexed ordinal position of field in struct
   *
   * @generated from field: int32 field = 1;
   */
  field: number;

  /**
   * Optional child segment
   *
   * @generated from field: substrait.Expression.ReferenceSegment child = 2;
   */
  child?: Expression_ReferenceSegment;
};

/**
 * Describes the message substrait.Expression.ReferenceSegment.StructField.
 * Use `create(Expression_ReferenceSegment_StructFieldSchema)` to create a new message.
 */
export const Expression_ReferenceSegment_StructFieldSchema: GenMessage<Expression_ReferenceSegment_StructField> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 11, 1);

/**
 * @generated from message substrait.Expression.ReferenceSegment.ListElement
 */
export type Expression_ReferenceSegment_ListElement = Message<"substrait.Expression.ReferenceSegment.ListElement"> & {
  /**
   * zero-indexed ordinal position of element in list
   *
   * @generated from field: int32 offset = 1;
   */
  offset: number;

  /**
   * Optional child segment
   *
   * @generated from field: substrait.Expression.ReferenceSegment child = 2;
   */
  child?: Expression_ReferenceSegment;
};

/**
 * Describes the message substrait.Expression.ReferenceSegment.ListElement.
 * Use `create(Expression_ReferenceSegment_ListElementSchema)` to create a new message.
 */
export const Expression_ReferenceSegment_ListElementSchema: GenMessage<Expression_ReferenceSegment_ListElement> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 11, 2);

/**
 * A reference that takes an existing subtype and selectively removes fields
 * from it. For example, one might initially have an inner struct with 100
 * fields but a a particular operation only needs to interact with only 2 of
 * those 100 fields. In this situation, one would use a mask expression to
 * eliminate the 98 fields that are not relevant to the rest of the operation
 * pipeline.
 *
 * Note that this does not fundamentally alter the structure of data beyond
 * the elimination of unnecessary elements.
 *
 * @generated from message substrait.Expression.MaskExpression
 */
export type Expression_MaskExpression = Message<"substrait.Expression.MaskExpression"> & {
  /**
   * @generated from field: substrait.Expression.MaskExpression.StructSelect select = 1;
   */
  select?: Expression_MaskExpression_StructSelect;

  /**
   * @generated from field: bool maintain_singular_struct = 2;
   */
  maintainSingularStruct: boolean;
};

/**
 * Describes the message substrait.Expression.MaskExpression.
 * Use `create(Expression_MaskExpressionSchema)` to create a new message.
 */
export const Expression_MaskExpressionSchema: GenMessage<Expression_MaskExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12);

/**
 * @generated from message substrait.Expression.MaskExpression.Select
 */
export type Expression_MaskExpression_Select = Message<"substrait.Expression.MaskExpression.Select"> & {
  /**
   * @generated from oneof substrait.Expression.MaskExpression.Select.type
   */
  type: {
    /**
     * @generated from field: substrait.Expression.MaskExpression.StructSelect struct = 1;
     */
    value: Expression_MaskExpression_StructSelect;
    case: "struct";
  } | {
    /**
     * @generated from field: substrait.Expression.MaskExpression.ListSelect list = 2;
     */
    value: Expression_MaskExpression_ListSelect;
    case: "list";
  } | {
    /**
     * @generated from field: substrait.Expression.MaskExpression.MapSelect map = 3;
     */
    value: Expression_MaskExpression_MapSelect;
    case: "map";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.MaskExpression.Select.
 * Use `create(Expression_MaskExpression_SelectSchema)` to create a new message.
 */
export const Expression_MaskExpression_SelectSchema: GenMessage<Expression_MaskExpression_Select> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12, 0);

/**
 * @generated from message substrait.Expression.MaskExpression.StructSelect
 */
export type Expression_MaskExpression_StructSelect = Message<"substrait.Expression.MaskExpression.StructSelect"> & {
  /**
   * @generated from field: repeated substrait.Expression.MaskExpression.StructItem struct_items = 1;
   */
  structItems: Expression_MaskExpression_StructItem[];
};

/**
 * Describes the message substrait.Expression.MaskExpression.StructSelect.
 * Use `create(Expression_MaskExpression_StructSelectSchema)` to create a new message.
 */
export const Expression_MaskExpression_StructSelectSchema: GenMessage<Expression_MaskExpression_StructSelect> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12, 1);

/**
 * @generated from message substrait.Expression.MaskExpression.StructItem
 */
export type Expression_MaskExpression_StructItem = Message<"substrait.Expression.MaskExpression.StructItem"> & {
  /**
   * @generated from field: int32 field = 1;
   */
  field: number;

  /**
   * @generated from field: substrait.Expression.MaskExpression.Select child = 2;
   */
  child?: Expression_MaskExpression_Select;
};

/**
 * Describes the message substrait.Expression.MaskExpression.StructItem.
 * Use `create(Expression_MaskExpression_StructItemSchema)` to create a new message.
 */
export const Expression_MaskExpression_StructItemSchema: GenMessage<Expression_MaskExpression_StructItem> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12, 2);

/**
 * @generated from message substrait.Expression.MaskExpression.ListSelect
 */
export type Expression_MaskExpression_ListSelect = Message<"substrait.Expression.MaskExpression.ListSelect"> & {
  /**
   * @generated from field: repeated substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection = 1;
   */
  selection: Expression_MaskExpression_ListSelect_ListSelectItem[];

  /**
   * @generated from field: substrait.Expression.MaskExpression.Select child = 2;
   */
  child?: Expression_MaskExpression_Select;
};

/**
 * Describes the message substrait.Expression.MaskExpression.ListSelect.
 * Use `create(Expression_MaskExpression_ListSelectSchema)` to create a new message.
 */
export const Expression_MaskExpression_ListSelectSchema: GenMessage<Expression_MaskExpression_ListSelect> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12, 3);

/**
 * @generated from message substrait.Expression.MaskExpression.ListSelect.ListSelectItem
 */
export type Expression_MaskExpression_ListSelect_ListSelectItem = Message<"substrait.Expression.MaskExpression.ListSelect.ListSelectItem"> & {
  /**
   * @generated from oneof substrait.Expression.MaskExpression.ListSelect.ListSelectItem.type
   */
  type: {
    /**
     * @generated from field: substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1;
     */
    value: Expression_MaskExpression_ListSelect_ListSelectItem_ListElement;
    case: "item";
  } | {
    /**
     * @generated from field: substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2;
     */
    value: Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice;
    case: "slice";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.
 * Use `create(Expression_MaskExpression_ListSelect_ListSelectItemSchema)` to create a new message.
 */
export const Expression_MaskExpression_ListSelect_ListSelectItemSchema: GenMessage<Expression_MaskExpression_ListSelect_ListSelectItem> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12, 3, 0);

/**
 * @generated from message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement
 */
export type Expression_MaskExpression_ListSelect_ListSelectItem_ListElement = Message<"substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement"> & {
  /**
   * @generated from field: int32 field = 1;
   */
  field: number;
};

/**
 * Describes the message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement.
 * Use `create(Expression_MaskExpression_ListSelect_ListSelectItem_ListElementSchema)` to create a new message.
 */
export const Expression_MaskExpression_ListSelect_ListSelectItem_ListElementSchema: GenMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListElement> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12, 3, 0, 0);

/**
 * @generated from message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice
 */
export type Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice = Message<"substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice"> & {
  /**
   * @generated from field: int32 start = 1;
   */
  start: number;

  /**
   * @generated from field: int32 end = 2;
   */
  end: number;
};

/**
 * Describes the message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.
 * Use `create(Expression_MaskExpression_ListSelect_ListSelectItem_ListSliceSchema)` to create a new message.
 */
export const Expression_MaskExpression_ListSelect_ListSelectItem_ListSliceSchema: GenMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12, 3, 0, 1);

/**
 * @generated from message substrait.Expression.MaskExpression.MapSelect
 */
export type Expression_MaskExpression_MapSelect = Message<"substrait.Expression.MaskExpression.MapSelect"> & {
  /**
   * @generated from oneof substrait.Expression.MaskExpression.MapSelect.select
   */
  select: {
    /**
     * @generated from field: substrait.Expression.MaskExpression.MapSelect.MapKey key = 1;
     */
    value: Expression_MaskExpression_MapSelect_MapKey;
    case: "key";
  } | {
    /**
     * @generated from field: substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression = 2;
     */
    value: Expression_MaskExpression_MapSelect_MapKeyExpression;
    case: "expression";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: substrait.Expression.MaskExpression.Select child = 3;
   */
  child?: Expression_MaskExpression_Select;
};

/**
 * Describes the message substrait.Expression.MaskExpression.MapSelect.
 * Use `create(Expression_MaskExpression_MapSelectSchema)` to create a new message.
 */
export const Expression_MaskExpression_MapSelectSchema: GenMessage<Expression_MaskExpression_MapSelect> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12, 4);

/**
 * @generated from message substrait.Expression.MaskExpression.MapSelect.MapKey
 */
export type Expression_MaskExpression_MapSelect_MapKey = Message<"substrait.Expression.MaskExpression.MapSelect.MapKey"> & {
  /**
   * @generated from field: string map_key = 1;
   */
  mapKey: string;
};

/**
 * Describes the message substrait.Expression.MaskExpression.MapSelect.MapKey.
 * Use `create(Expression_MaskExpression_MapSelect_MapKeySchema)` to create a new message.
 */
export const Expression_MaskExpression_MapSelect_MapKeySchema: GenMessage<Expression_MaskExpression_MapSelect_MapKey> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12, 4, 0);

/**
 * @generated from message substrait.Expression.MaskExpression.MapSelect.MapKeyExpression
 */
export type Expression_MaskExpression_MapSelect_MapKeyExpression = Message<"substrait.Expression.MaskExpression.MapSelect.MapKeyExpression"> & {
  /**
   * @generated from field: string map_key_expression = 1;
   */
  mapKeyExpression: string;
};

/**
 * Describes the message substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.
 * Use `create(Expression_MaskExpression_MapSelect_MapKeyExpressionSchema)` to create a new message.
 */
export const Expression_MaskExpression_MapSelect_MapKeyExpressionSchema: GenMessage<Expression_MaskExpression_MapSelect_MapKeyExpression> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 12, 4, 1);

/**
 * A reference to an inner part of a complex object. Can reference reference a
 * single element or a masked version of elements
 *
 * @generated from message substrait.Expression.FieldReference
 */
export type Expression_FieldReference = Message<"substrait.Expression.FieldReference"> & {
  /**
   * Whether this is composed of a single element reference or a masked
   * element subtree
   *
   * @generated from oneof substrait.Expression.FieldReference.reference_type
   */
  referenceType: {
    /**
     * @generated from field: substrait.Expression.ReferenceSegment direct_reference = 1;
     */
    value: Expression_ReferenceSegment;
    case: "directReference";
  } | {
    /**
     * @generated from field: substrait.Expression.MaskExpression masked_reference = 2;
     */
    value: Expression_MaskExpression;
    case: "maskedReference";
  } | { case: undefined; value?: undefined };

  /**
   * Whether this reference has an origin of a root struct or is based on the
   * ouput of an expression. When this is a RootReference and direct_reference
   * above is used, the direct_reference must be of a type StructField.
   *
   * @generated from oneof substrait.Expression.FieldReference.root_type
   */
  rootType: {
    /**
     * @generated from field: substrait.Expression expression = 3;
     */
    value: Expression;
    case: "expression";
  } | {
    /**
     * @generated from field: substrait.Expression.FieldReference.RootReference root_reference = 4;
     */
    value: Expression_FieldReference_RootReference;
    case: "rootReference";
  } | {
    /**
     * @generated from field: substrait.Expression.FieldReference.OuterReference outer_reference = 5;
     */
    value: Expression_FieldReference_OuterReference;
    case: "outerReference";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.FieldReference.
 * Use `create(Expression_FieldReferenceSchema)` to create a new message.
 */
export const Expression_FieldReferenceSchema: GenMessage<Expression_FieldReference> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 13);

/**
 * Singleton that expresses this FieldReference is rooted off the root
 * incoming record type
 *
 * @generated from message substrait.Expression.FieldReference.RootReference
 */
export type Expression_FieldReference_RootReference = Message<"substrait.Expression.FieldReference.RootReference"> & {
};

/**
 * Describes the message substrait.Expression.FieldReference.RootReference.
 * Use `create(Expression_FieldReference_RootReferenceSchema)` to create a new message.
 */
export const Expression_FieldReference_RootReferenceSchema: GenMessage<Expression_FieldReference_RootReference> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 13, 0);

/**
 * A root reference for the outer relation's subquery
 *
 * @generated from message substrait.Expression.FieldReference.OuterReference
 */
export type Expression_FieldReference_OuterReference = Message<"substrait.Expression.FieldReference.OuterReference"> & {
  /**
   * number of subquery boundaries to traverse up for this field's reference
   *
   * This value must be >= 1
   *
   * @generated from field: uint32 steps_out = 1;
   */
  stepsOut: number;
};

/**
 * Describes the message substrait.Expression.FieldReference.OuterReference.
 * Use `create(Expression_FieldReference_OuterReferenceSchema)` to create a new message.
 */
export const Expression_FieldReference_OuterReferenceSchema: GenMessage<Expression_FieldReference_OuterReference> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 13, 1);

/**
 * Subquery relation expression
 *
 * @generated from message substrait.Expression.Subquery
 */
export type Expression_Subquery = Message<"substrait.Expression.Subquery"> & {
  /**
   * @generated from oneof substrait.Expression.Subquery.subquery_type
   */
  subqueryType: {
    /**
     * Scalar subquery
     *
     * @generated from field: substrait.Expression.Subquery.Scalar scalar = 1;
     */
    value: Expression_Subquery_Scalar;
    case: "scalar";
  } | {
    /**
     * x IN y predicate
     *
     * @generated from field: substrait.Expression.Subquery.InPredicate in_predicate = 2;
     */
    value: Expression_Subquery_InPredicate;
    case: "inPredicate";
  } | {
    /**
     * EXISTS/UNIQUE predicate
     *
     * @generated from field: substrait.Expression.Subquery.SetPredicate set_predicate = 3;
     */
    value: Expression_Subquery_SetPredicate;
    case: "setPredicate";
  } | {
    /**
     * ANY/ALL predicate
     *
     * @generated from field: substrait.Expression.Subquery.SetComparison set_comparison = 4;
     */
    value: Expression_Subquery_SetComparison;
    case: "setComparison";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.Expression.Subquery.
 * Use `create(Expression_SubquerySchema)` to create a new message.
 */
export const Expression_SubquerySchema: GenMessage<Expression_Subquery> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 14);

/**
 * A subquery with one row and one column. This is often an aggregate
 * though not required to be.
 *
 * @generated from message substrait.Expression.Subquery.Scalar
 */
export type Expression_Subquery_Scalar = Message<"substrait.Expression.Subquery.Scalar"> & {
  /**
   * @generated from field: substrait.Rel input = 1;
   */
  input?: Rel;
};

/**
 * Describes the message substrait.Expression.Subquery.Scalar.
 * Use `create(Expression_Subquery_ScalarSchema)` to create a new message.
 */
export const Expression_Subquery_ScalarSchema: GenMessage<Expression_Subquery_Scalar> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 14, 0);

/**
 * Predicate checking that the left expression is contained in the right
 * subquery
 *
 * Examples:
 *
 * x IN (SELECT * FROM t)
 * (x, y) IN (SELECT a, b FROM t)
 *
 * @generated from message substrait.Expression.Subquery.InPredicate
 */
export type Expression_Subquery_InPredicate = Message<"substrait.Expression.Subquery.InPredicate"> & {
  /**
   * @generated from field: repeated substrait.Expression needles = 1;
   */
  needles: Expression[];

  /**
   * @generated from field: substrait.Rel haystack = 2;
   */
  haystack?: Rel;
};

/**
 * Describes the message substrait.Expression.Subquery.InPredicate.
 * Use `create(Expression_Subquery_InPredicateSchema)` to create a new message.
 */
export const Expression_Subquery_InPredicateSchema: GenMessage<Expression_Subquery_InPredicate> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 14, 1);

/**
 * A predicate over a set of rows in the form of a subquery
 * EXISTS and UNIQUE are common SQL forms of this operation.
 *
 * @generated from message substrait.Expression.Subquery.SetPredicate
 */
export type Expression_Subquery_SetPredicate = Message<"substrait.Expression.Subquery.SetPredicate"> & {
  /**
   * TODO: should allow expressions
   *
   * @generated from field: substrait.Expression.Subquery.SetPredicate.PredicateOp predicate_op = 1;
   */
  predicateOp: Expression_Subquery_SetPredicate_PredicateOp;

  /**
   * @generated from field: substrait.Rel tuples = 2;
   */
  tuples?: Rel;
};

/**
 * Describes the message substrait.Expression.Subquery.SetPredicate.
 * Use `create(Expression_Subquery_SetPredicateSchema)` to create a new message.
 */
export const Expression_Subquery_SetPredicateSchema: GenMessage<Expression_Subquery_SetPredicate> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 14, 2);

/**
 * @generated from enum substrait.Expression.Subquery.SetPredicate.PredicateOp
 */
export enum Expression_Subquery_SetPredicate_PredicateOp {
  /**
   * @generated from enum value: PREDICATE_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PREDICATE_OP_EXISTS = 1;
   */
  EXISTS = 1,

  /**
   * @generated from enum value: PREDICATE_OP_UNIQUE = 2;
   */
  UNIQUE = 2,
}

/**
 * Describes the enum substrait.Expression.Subquery.SetPredicate.PredicateOp.
 */
export const Expression_Subquery_SetPredicate_PredicateOpSchema: GenEnum<Expression_Subquery_SetPredicate_PredicateOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 30, 14, 2, 0);

/**
 * A subquery comparison using ANY or ALL.
 * Examples:
 *
 * SELECT *
 * FROM t1
 * WHERE x < ANY(SELECT y from t2)
 *
 * @generated from message substrait.Expression.Subquery.SetComparison
 */
export type Expression_Subquery_SetComparison = Message<"substrait.Expression.Subquery.SetComparison"> & {
  /**
   * ANY or ALL
   *
   * @generated from field: substrait.Expression.Subquery.SetComparison.ReductionOp reduction_op = 1;
   */
  reductionOp: Expression_Subquery_SetComparison_ReductionOp;

  /**
   * A comparison operator
   *
   * @generated from field: substrait.Expression.Subquery.SetComparison.ComparisonOp comparison_op = 2;
   */
  comparisonOp: Expression_Subquery_SetComparison_ComparisonOp;

  /**
   * left side of the expression
   *
   * @generated from field: substrait.Expression left = 3;
   */
  left?: Expression;

  /**
   * right side of the expression
   *
   * @generated from field: substrait.Rel right = 4;
   */
  right?: Rel;
};

/**
 * Describes the message substrait.Expression.Subquery.SetComparison.
 * Use `create(Expression_Subquery_SetComparisonSchema)` to create a new message.
 */
export const Expression_Subquery_SetComparisonSchema: GenMessage<Expression_Subquery_SetComparison> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 30, 14, 3);

/**
 * @generated from enum substrait.Expression.Subquery.SetComparison.ComparisonOp
 */
export enum Expression_Subquery_SetComparison_ComparisonOp {
  /**
   * @generated from enum value: COMPARISON_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: COMPARISON_OP_EQ = 1;
   */
  EQ = 1,

  /**
   * @generated from enum value: COMPARISON_OP_NE = 2;
   */
  NE = 2,

  /**
   * @generated from enum value: COMPARISON_OP_LT = 3;
   */
  LT = 3,

  /**
   * @generated from enum value: COMPARISON_OP_GT = 4;
   */
  GT = 4,

  /**
   * @generated from enum value: COMPARISON_OP_LE = 5;
   */
  LE = 5,

  /**
   * @generated from enum value: COMPARISON_OP_GE = 6;
   */
  GE = 6,
}

/**
 * Describes the enum substrait.Expression.Subquery.SetComparison.ComparisonOp.
 */
export const Expression_Subquery_SetComparison_ComparisonOpSchema: GenEnum<Expression_Subquery_SetComparison_ComparisonOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 30, 14, 3, 0);

/**
 * @generated from enum substrait.Expression.Subquery.SetComparison.ReductionOp
 */
export enum Expression_Subquery_SetComparison_ReductionOp {
  /**
   * @generated from enum value: REDUCTION_OP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REDUCTION_OP_ANY = 1;
   */
  ANY = 1,

  /**
   * @generated from enum value: REDUCTION_OP_ALL = 2;
   */
  ALL = 2,
}

/**
 * Describes the enum substrait.Expression.Subquery.SetComparison.ReductionOp.
 */
export const Expression_Subquery_SetComparison_ReductionOpSchema: GenEnum<Expression_Subquery_SetComparison_ReductionOp> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 30, 14, 3, 1);

/**
 * Expression that represents a dynamic parameter.
 * Dynamic parameters are identified by a surrogate key within a plan.
 *
 * @generated from message substrait.DynamicParameter
 */
export type DynamicParameter = Message<"substrait.DynamicParameter"> & {
  /**
   * The type of the dynamic parameter.
   *
   * @generated from field: substrait.Type type = 1;
   */
  type?: Type;

  /**
   * The surrogate key used within a plan to reference a specific parameter binding.
   *
   * @generated from field: uint32 parameter_reference = 2;
   */
  parameterReference: number;
};

/**
 * Describes the message substrait.DynamicParameter.
 * Use `create(DynamicParameterSchema)` to create a new message.
 */
export const DynamicParameterSchema: GenMessage<DynamicParameter> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 31);

/**
 * The description of a field to sort on (including the direction of sorting and null semantics)
 *
 * @generated from message substrait.SortField
 */
export type SortField = Message<"substrait.SortField"> & {
  /**
   * @generated from field: substrait.Expression expr = 1;
   */
  expr?: Expression;

  /**
   * @generated from oneof substrait.SortField.sort_kind
   */
  sortKind: {
    /**
     * @generated from field: substrait.SortField.SortDirection direction = 2;
     */
    value: SortField_SortDirection;
    case: "direction";
  } | {
    /**
     * @generated from field: uint32 comparison_function_reference = 3;
     */
    value: number;
    case: "comparisonFunctionReference";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message substrait.SortField.
 * Use `create(SortFieldSchema)` to create a new message.
 */
export const SortFieldSchema: GenMessage<SortField> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 32);

/**
 * @generated from enum substrait.SortField.SortDirection
 */
export enum SortField_SortDirection {
  /**
   * @generated from enum value: SORT_DIRECTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SORT_DIRECTION_ASC_NULLS_FIRST = 1;
   */
  ASC_NULLS_FIRST = 1,

  /**
   * @generated from enum value: SORT_DIRECTION_ASC_NULLS_LAST = 2;
   */
  ASC_NULLS_LAST = 2,

  /**
   * @generated from enum value: SORT_DIRECTION_DESC_NULLS_FIRST = 3;
   */
  DESC_NULLS_FIRST = 3,

  /**
   * @generated from enum value: SORT_DIRECTION_DESC_NULLS_LAST = 4;
   */
  DESC_NULLS_LAST = 4,

  /**
   * @generated from enum value: SORT_DIRECTION_CLUSTERED = 5;
   */
  CLUSTERED = 5,
}

/**
 * Describes the enum substrait.SortField.SortDirection.
 */
export const SortField_SortDirectionSchema: GenEnum<SortField_SortDirection> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 32, 0);

/**
 * An aggregate function.
 *
 * @generated from message substrait.AggregateFunction
 */
export type AggregateFunction = Message<"substrait.AggregateFunction"> & {
  /**
   * Points to a function_anchor defined in this plan, which must refer
   * to an aggregate function in the associated YAML file. Required; 0 is
   * considered to be a valid anchor/reference.
   *
   * @generated from field: uint32 function_reference = 1;
   */
  functionReference: number;

  /**
   * The arguments to be bound to the function. This must have exactly the
   * number of arguments specified in the function definition, and the
   * argument types must also match exactly:
   *
   *  - Value arguments must be bound using FunctionArgument.value, and
   *    the expression in that must yield a value of a type that a function
   *    overload is defined for.
   *  - Type arguments must be bound using FunctionArgument.type, and a
   *    function overload must be defined for that type.
   *  - Enum arguments must be bound using FunctionArgument.enum
   *    followed by Enum.specified, with a string that case-insensitively
   *    matches one of the allowed options.
   *  - Optional enum arguments must be bound using FunctionArgument.enum
   *    followed by either Enum.specified or Enum.unspecified. If specified,
   *    the string must case-insensitively match one of the allowed options.
   *
   * @generated from field: repeated substrait.FunctionArgument arguments = 7;
   */
  arguments: FunctionArgument[];

  /**
   * Options to specify behavior for corner cases, or leave behavior
   * unspecified if the consumer does not need specific behavior in these
   * cases.
   *
   * @generated from field: repeated substrait.FunctionOption options = 8;
   */
  options: FunctionOption[];

  /**
   * Must be set to the return type of the function, exactly as derived
   * using the declaration in the extension.
   *
   * @generated from field: substrait.Type output_type = 5;
   */
  outputType?: Type;

  /**
   * Describes which part of the aggregation to perform within the context of
   * distributed algorithms. Required. Must be set to INITIAL_TO_RESULT for
   * aggregate functions that are not decomposable.
   *
   * @generated from field: substrait.AggregationPhase phase = 4;
   */
  phase: AggregationPhase;

  /**
   * If specified, the aggregated records are ordered according to this list
   * before they are aggregated. The first sort field has the highest
   * priority; only if a sort field determines two records to be equivalent is
   * the next field queried. This field is optional.
   *
   * @generated from field: repeated substrait.SortField sorts = 3;
   */
  sorts: SortField[];

  /**
   * Specifies whether equivalent records are merged before being aggregated.
   * Optional, defaults to AGGREGATION_INVOCATION_ALL.
   *
   * @generated from field: substrait.AggregateFunction.AggregationInvocation invocation = 6;
   */
  invocation: AggregateFunction_AggregationInvocation;

  /**
   * deprecated; use arguments instead
   *
   * @generated from field: repeated substrait.Expression args = 2 [deprecated = true];
   * @deprecated
   */
  args: Expression[];
};

/**
 * Describes the message substrait.AggregateFunction.
 * Use `create(AggregateFunctionSchema)` to create a new message.
 */
export const AggregateFunctionSchema: GenMessage<AggregateFunction> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 33);

/**
 * Method in which equivalent records are merged before being aggregated.
 *
 * @generated from enum substrait.AggregateFunction.AggregationInvocation
 */
export enum AggregateFunction_AggregationInvocation {
  /**
   * This default value implies AGGREGATION_INVOCATION_ALL.
   *
   * @generated from enum value: AGGREGATION_INVOCATION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Use all values in the aggregation calculation.
   *
   * @generated from enum value: AGGREGATION_INVOCATION_ALL = 1;
   */
  ALL = 1,

  /**
   * Use only distinct values in the aggregation calculation.
   *
   * @generated from enum value: AGGREGATION_INVOCATION_DISTINCT = 2;
   */
  DISTINCT = 2,
}

/**
 * Describes the enum substrait.AggregateFunction.AggregationInvocation.
 */
export const AggregateFunction_AggregationInvocationSchema: GenEnum<AggregateFunction_AggregationInvocation> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 33, 0);

/**
 * This rel is used  to create references,
 * in case we refer to a RelRoot field names will be ignored
 *
 * @generated from message substrait.ReferenceRel
 */
export type ReferenceRel = Message<"substrait.ReferenceRel"> & {
  /**
   * @generated from field: int32 subtree_ordinal = 1;
   */
  subtreeOrdinal: number;
};

/**
 * Describes the message substrait.ReferenceRel.
 * Use `create(ReferenceRelSchema)` to create a new message.
 */
export const ReferenceRelSchema: GenMessage<ReferenceRel> = /*@__PURE__*/
  messageDesc(file_substrait_algebra, 34);

/**
 * Describes which part of an aggregation or window function to perform within
 * the context of distributed algorithms.
 *
 * @generated from enum substrait.AggregationPhase
 */
export enum AggregationPhase {
  /**
   * Implies `INTERMEDIATE_TO_RESULT`.
   *
   * @generated from enum value: AGGREGATION_PHASE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Specifies that the function should be run only up to the point of
   * generating an intermediate value, to be further aggregated later using
   * INTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.
   *
   * @generated from enum value: AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE = 1;
   */
  INITIAL_TO_INTERMEDIATE = 1,

  /**
   * Specifies that the inputs of the aggregate or window function are the
   * intermediate values of the function, and that the output should also be
   * an intermediate value, to be further aggregated later using
   * INTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.
   *
   * @generated from enum value: AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE = 2;
   */
  INTERMEDIATE_TO_INTERMEDIATE = 2,

  /**
   * A complete invocation: the function should aggregate the given set of
   * inputs to yield a single return value. This style must be used for
   * aggregate or window functions that are not decomposable.
   *
   * @generated from enum value: AGGREGATION_PHASE_INITIAL_TO_RESULT = 3;
   */
  INITIAL_TO_RESULT = 3,

  /**
   * Specifies that the inputs of the aggregate or window function are the
   * intermediate values of the function, generated previously using
   * INITIAL_TO_INTERMEDIATE and possibly INTERMEDIATE_TO_INTERMEDIATE calls.
   * This call should combine the intermediate values to yield the final
   * return value.
   *
   * @generated from enum value: AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT = 4;
   */
  INTERMEDIATE_TO_RESULT = 4,
}

/**
 * Describes the enum substrait.AggregationPhase.
 */
export const AggregationPhaseSchema: GenEnum<AggregationPhase> = /*@__PURE__*/
  enumDesc(file_substrait_algebra, 0);

